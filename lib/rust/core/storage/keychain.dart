// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:skiffy/rust/core/storage.dart';
import 'package:skiffy/rust/frb_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_service_name`, `map_keychain_error`
// These functions are ignored because they have generic arguments: `clear`, `delete`, `get`, `set`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`

/// Keychain-based secure storage for macOS and iOS
///
/// This implementation uses the Apple Keychain Services to securely store
/// credentials. The Keychain provides hardware-encrypted storage that persists
/// across application restarts and is protected by the user's login credentials
/// or biometric authentication.
///
/// # Security Features
///
/// - Data is encrypted using the device's hardware security module when available
/// - Access is protected by the user's login credentials or biometric authentication
/// - Data persists securely across application restarts and system reboots
/// - Integration with iOS/macOS security policies and user consent flows
///
/// # Platform Support
///
/// - **macOS**: Uses the user's default keychain
/// - **iOS**: Uses the application's keychain partition
class KeychainStorage {
  const KeychainStorage({
    required this.serviceName,
  });
  final String serviceName;

  static Future<KeychainStorage> default_() =>
      RustLib.instance.api.crateCoreStorageKeychainKeychainStorageDefault();

  Future<SessionStatus> isPersistent() =>
      RustLib.instance.api.crateCoreStorageKeychainKeychainStorageIsPersistent(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new Keychain storage instance
  ///
  /// # Arguments
  ///
  /// * `service_name` - Optional service name to use for keychain entries.
  ///   If None, uses the application bundle identifier.
  ///
  /// # Returns
  ///
  /// Returns `Ok(KeychainStorage)` on success, or an error if initialization fails.
  static Future<KeychainStorage> newInstance() =>
      RustLib.instance.api.crateCoreStorageKeychainKeychainStorageNew();

  /// Creates a new Keychain storage instance with a custom service name
  ///
  /// # Arguments
  ///
  /// * `service_name` - The service name to use for keychain entries
  ///
  /// # Returns
  ///
  /// Returns a new `KeychainStorage` instance.
  static Future<KeychainStorage> withServiceName({
    required String serviceName,
  }) => RustLib.instance.api
      .crateCoreStorageKeychainKeychainStorageWithServiceName(
        serviceName: serviceName,
      );

  @override
  int get hashCode => serviceName.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeychainStorage &&
          runtimeType == other.runtimeType &&
          serviceName == other.serviceName;
}
