// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:skiffy/rust/frb_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `from`, `from`

/// Initialize the secure storage system
///
/// This function must be called before using any other secure storage functions.
/// It creates the appropriate storage backend for the current platform.
///
/// # Returns
///
/// Returns `Ok(())` on success, or an error message on failure.
Future<void> initializeSecureStorage() =>
    RustLib.instance.api.crateApiSecureStorageInitializeSecureStorage();

/// Store a key-value pair in secure storage
///
/// # Arguments
///
/// * `key` - The key to store the value under
/// * `value` - The secret value to store
///
/// # Returns
///
/// Returns `Ok(())` on success, or an error on failure.
Future<void> secureStorageSet({required String key, required String value}) =>
    RustLib.instance.api.crateApiSecureStorageSecureStorageSet(
      key: key,
      value: value,
    );

/// Retrieve a value from secure storage by key
///
/// # Arguments
///
/// * `key` - The key to retrieve the value for
///
/// # Returns
///
/// Returns `Ok(String)` with the stored value on success, or an error on failure.
Future<String> secureStorageGet({required String key}) =>
    RustLib.instance.api.crateApiSecureStorageSecureStorageGet(key: key);

/// Delete a key-value pair from secure storage
///
/// # Arguments
///
/// * `key` - The key to delete
///
/// # Returns
///
/// Returns `Ok(())` on success, or an error on failure.
Future<void> secureStorageDelete({required String key}) =>
    RustLib.instance.api.crateApiSecureStorageSecureStorageDelete(key: key);

/// Clear all stored values from secure storage
///
/// # Returns
///
/// Returns `Ok(())` on success, or an error on failure.
Future<void> secureStorageClear() =>
    RustLib.instance.api.crateApiSecureStorageSecureStorageClear();

/// Check if the current storage backend provides persistent storage
///
/// # Returns
///
/// Returns the session status indicating whether data will persist across app restarts.
Future<FfiSessionStatus> secureStorageSessionStatus() =>
    RustLib.instance.api.crateApiSecureStorageSecureStorageSessionStatus();

/// Check if secure storage is initialized
///
/// # Returns
///
/// Returns `true` if secure storage is initialized, `false` otherwise.
Future<bool> isSecureStorageInitialized() =>
    RustLib.instance.api.crateApiSecureStorageIsSecureStorageInitialized();

/// Session status for FFI layer
enum FfiSessionStatus {
  /// Session data is securely persisted across app restarts
  persistent,

  /// Session data is only stored in memory and will be lost on app restart
  nonPersistent,
}

/// Error types for secure storage operations exposed to Flutter
class SecureStorageApiError implements FrbException {
  const SecureStorageApiError({
    required this.message,
    required this.errorType,
  });
  final String message;
  final String errorType;

  static Future<SecureStorageApiError> accessDenied({required String key}) =>
      RustLib.instance.api
          .crateApiSecureStorageSecureStorageApiErrorAccessDenied(key: key);

  static Future<SecureStorageApiError> backendNotAvailable({
    required String reason,
  }) => RustLib.instance.api
      .crateApiSecureStorageSecureStorageApiErrorBackendNotAvailable(
        reason: reason,
      );

  static Future<SecureStorageApiError> internalError({
    required String message,
  }) => RustLib.instance.api
      .crateApiSecureStorageSecureStorageApiErrorInternalError(
        message: message,
      );

  static Future<SecureStorageApiError> invalidInput({
    required String message,
  }) => RustLib.instance.api
      .crateApiSecureStorageSecureStorageApiErrorInvalidInput(message: message);

  static Future<SecureStorageApiError> keyNotFound({required String key}) =>
      RustLib.instance.api
          .crateApiSecureStorageSecureStorageApiErrorKeyNotFound(key: key);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<SecureStorageApiError> newInstance({
    required String message,
    required String errorType,
  }) => RustLib.instance.api.crateApiSecureStorageSecureStorageApiErrorNew(
    message: message,
    errorType: errorType,
  );

  @override
  int get hashCode => message.hashCode ^ errorType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SecureStorageApiError &&
          runtimeType == other.runtimeType &&
          message == other.message &&
          errorType == other.errorType;
}
