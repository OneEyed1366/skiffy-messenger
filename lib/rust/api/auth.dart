// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'package:skiffy/rust/core/storage.dart';
import 'package:skiffy/rust/frb_generated.dart';

part 'auth.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `source`

/// Login with username and password
Future<User> login({
  required String homeServerUrl,
  required String username,
  required String password,
}) => RustLib.instance.api.crateApiAuthLogin(
  homeServerUrl: homeServerUrl,
  username: username,
  password: password,
);

/// Restore a previous session from secure storage
Future<User?> restoreSession({required String homeServerUrl}) => RustLib
    .instance
    .api
    .crateApiAuthRestoreSession(homeServerUrl: homeServerUrl);

/// Logout and clear all session data
Future<void> logout({required String homeServerUrl}) =>
    RustLib.instance.api.crateApiAuthLogout(homeServerUrl: homeServerUrl);

/// Check if there is a stored session
Future<bool> hasStoredSession() =>
    RustLib.instance.api.crateApiAuthHasStoredSession();

/// Verify that a homeserver URL is valid and points to a Matrix server
Future<bool> verifyHomeserver({required String homeServerUrl}) => RustLib
    .instance
    .api
    .crateApiAuthVerifyHomeserver(homeServerUrl: homeServerUrl);

@freezed
sealed class AuthError with _$AuthError implements FrbException {
  const AuthError._();

  const factory AuthError.authentication(
    String field0,
  ) = AuthError_Authentication;
  const factory AuthError.storage(
    SecureStorageError field0,
  ) = AuthError_Storage;
  const factory AuthError.sessionNotFound() = AuthError_SessionNotFound;
  const factory AuthError.network(
    String field0,
  ) = AuthError_Network;
  const factory AuthError.invalidInput(
    String field0,
  ) = AuthError_InvalidInput;
}

@freezed
sealed class HomeserverError with _$HomeserverError implements FrbException {
  const HomeserverError._();

  const factory HomeserverError.connectionTimeout() =
      HomeserverError_ConnectionTimeout;
  const factory HomeserverError.readTimeout() = HomeserverError_ReadTimeout;
  const factory HomeserverError.dnsResolutionFailed() =
      HomeserverError_DnsResolutionFailed;
  const factory HomeserverError.networkUnavailable() =
      HomeserverError_NetworkUnavailable;
  const factory HomeserverError.invalidUrl() = HomeserverError_InvalidUrl;
  const factory HomeserverError.notHttps() = HomeserverError_NotHttps;
  const factory HomeserverError.notMatrixServer() =
      HomeserverError_NotMatrixServer;
  const factory HomeserverError.malformedResponse() =
      HomeserverError_MalformedResponse;
  const factory HomeserverError.unsupportedVersion() =
      HomeserverError_UnsupportedVersion;
  const factory HomeserverError.serverError(
    int field0,
  ) = HomeserverError_ServerError;
}

/// User information returned after successful authentication
class User {
  const User({
    required this.userId,
    required this.isRestoredSession,
  });
  final String userId;
  final bool isRestoredSession;

  @override
  int get hashCode => userId.hashCode ^ isRestoredSession.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is User &&
          runtimeType == other.runtimeType &&
          userId == other.userId &&
          isRestoredSession == other.isRestoredSession;
}
