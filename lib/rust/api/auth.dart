// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'package:skiffy/rust/core/storage.dart';
import 'package:skiffy/rust/frb_generated.dart';

part 'auth.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`, `fmt`, `fmt`, `from`, `from`, `source`

/// Login with username and password
Future<User> login({
  required String homeServerUrl,
  required String username,
  required String password,
}) => RustLib.instance.api.crateApiAuthLogin(
  homeServerUrl: homeServerUrl,
  username: username,
  password: password,
);

/// Restore a previous session from secure storage
Future<User?> restoreSession({required String homeServerUrl}) => RustLib
    .instance
    .api
    .crateApiAuthRestoreSession(homeServerUrl: homeServerUrl);

/// Logout and clear all session data
Future<void> logout({required String homeServerUrl}) =>
    RustLib.instance.api.crateApiAuthLogout(homeServerUrl: homeServerUrl);

/// Check if there is a stored session
Future<bool> hasStoredSession() =>
    RustLib.instance.api.crateApiAuthHasStoredSession();

@freezed
sealed class AuthError with _$AuthError implements FrbException {
  const AuthError._();

  const factory AuthError.authentication(
    String field0,
  ) = AuthError_Authentication;
  const factory AuthError.storage(
    SecureStorageError field0,
  ) = AuthError_Storage;
  const factory AuthError.sessionNotFound() = AuthError_SessionNotFound;
  const factory AuthError.network(
    String field0,
  ) = AuthError_Network;
  const factory AuthError.invalidInput(
    String field0,
  ) = AuthError_InvalidInput;
}

/// User information returned after successful authentication
class User {
  const User({
    required this.userId,
    required this.isRestoredSession,
  });
  final String userId;
  final bool isRestoredSession;

  @override
  int get hashCode => userId.hashCode ^ isRestoredSession.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is User &&
          runtimeType == other.runtimeType &&
          userId == other.userId &&
          isRestoredSession == other.isRestoredSession;
}
