# Epic 2: Authentication & Room Management

**Цель:** Реализация полной функциональности аутентификации пользователя и отображения списка чатов (комнат).

**Ключевые фичи:** Вход по паролю, поддержка SSO (Google, Apple, GitHub), обнаружение и отображение списка комнат, обработка CAPTCHA.

## Story 2.0: Настройка Homeserver

**Как** пользователь,
**я хочу** иметь возможность указать адрес своего Matrix homeserver,
**чтобы** я мог подключиться как к стандартному, так и к приватному серверу.

**Критерии приемки:**

1. На экране входа в систему присутствует поле для ввода URL-адреса homeserver.
2. По умолчанию это поле заполнено адресом публичного сервера (`https://matrix.org`), но является редактируемым.
3. Приложение выполняет валидацию введенного URL на корректность формата (например, должен начинаться с `https://`).
4. Перед попыткой аутентификации приложение проверяет доступность сервера и то, что он является валидным Matrix-сервером (например, по наличию `/.well-known/matrix/client`).
5. В случае, если сервер недоступен или не является Matrix-сервером, пользователь получает понятное сообщение об ошибке (например, «Не удалось подключиться к серверу» или «Указанный адрес не является Matrix-сервером»).
6. Выбранный адрес сервера сохраняется для будущих сессий, чтобы пользователю не приходилось вводить его каждый раз.

## Story 2.1: Определение поддерживаемых способов аутентификации

**Как** пользователь,
**я хочу**, чтобы приложение автоматически определяло, какие способы входа поддерживает мой homeserver,
**чтобы** на экране входа отображались только актуальные для меня варианты (пароль, SSO и т.д.).

**Критерии приемки:**

1. Сразу после того, как пользователь ввел URL своего homeserver (`Story 2.0`) или при запуске приложения с уже сохраненным URL, Rust-ядро выполняет запрос на эндпоинт `/_matrix/client/v3/login`.
2. Запрос инкапсулирован с помощью метода `matrix-rust-sdk`, предположительно `client.matrix_auth().get_login_types().await`.
3. На основе полученного ответа (`flows`) Rust-ядро определяет, поддерживаются ли `m.login.password` и `m.login.sso`.
4. Эта информация (например, в виде набора флагов `supports_password`, `supports_sso`) передается во Flutter-часть приложения через FFI-мост.
5. **UI на Flutter динамически адаптируется**:
    - Если `supports_password` равен `true`, на экране отображаются поля для ввода логина и пароля.
    - Если `supports_sso` равен `true`, на экране отображается кнопка «Войти через SSO» (или набор кнопок для провайдеров из `Story 2.5` и далее).
    - Если поддерживается только один метод, то отображается только он.
6. **Обработка ошибок**: Если запрос к `/_matrix/client/v3/login` завершается ошибкой (например, из-за неверного URL или проблем с сетью), пользователю выводится понятное сообщение об ошибке, и UI не показывает никаких вариантов входа до успешного определения.

## Story 2.2: User Authentication

**Как** пользователь,
**я хочу** войти в свой существующий аккаунт Matrix, используя логин и пароль на указанном homeserver,
**чтобы** безопасно получить доступ к своим чатам.

**Критерии приемки:**

1. Экран входа содержит поля для **Matrix ID** (например, `@user:matrix.org`) и **пароля**. Поле для адреса сервера регулируется `Story 2.0`.
2. Аутентификация выполняется через `matrix-rust-sdk` путем отправки учетных данных на указанный homeserver по защищенному протоколу HTTPS.
3. В случае успешной аутентификации:
    - Приложение получает от сервера `access_token` и `device_id`.
    - Эти данные сохраняются с использованием кросс-платформенного механизма безопасного хранения, реализованного в **`Story 1.3`**.
    - Состояние приложения меняется на «аутентифицирован», и пользователь перенаправляется на экран со списком чатов (`Story 2.2`).
4. **Обработка ошибок детализирована**:
    - При неверном логине/пароле выводится ошибка: «Неверное имя пользователя или пароль».
    - При проблемах с сетью выводится ошибка: «Ошибка сети, проверьте подключение к интернету».
    - Другие ошибки сервера отображаются в понятном для пользователя виде.
5. Сохраненная сессия (токен) используется для автоматического входа при последующих запусках приложения, избавляя пользователя от необходимости повторного ввода пароля.

## Story 2.3: Room Discovery and Listing

**Как** пользователь,
**я хочу** видеть полный список своих чатов, отсортированный по последней активности,
**чтобы** я мог быстро найти нужный диалог.

**Критерии приемки:**

1. После успешной аутентификации открывается главный экран со списком всех чатов пользователя.
2. Для каждого чата в списке отображается следующая **критически важная мета-информация**:
    - Аватар и название чата. Для 1-на-1 чатов — аватар и имя другого пользователя.
    - Текст **последнего сообщения** в чате.
    - **Время** отправки последнего сообщения.
    - **Индикатор непрочитанных сообщений** с их количеством.
3. Чаты в списке отсортированы по времени последнего события (новое сообщение, смена названия и т.д.), самые свежие — наверху.
4. **Pull-to-refresh** (жест «потянуть для обновления») запускает принудительную синхронизацию с homeserver через `matrix-rust-sdk`, обновляя список чатов и счетчики непрочитанных сообщений.
5. **Обработка состояний загрузки**:
    - При первом входе в систему отображается полноэкранный индикатор загрузки, пока выполняется первоначальная синхронизация.
    - Во время pull-to-refresh отображается компактный индикатор вверху списка.
    - Если устройство офлайн, список чатов загружается из локальной базы данных (`Story 5.1`), а вверху экрана отображается плашка «Нет подключения».

## Story 2.4: Аутентификация через SSO (OAuth)

**Как** пользователь,  
**Я хочу** иметь возможность войти в свой аккаунт, используя сторонних провайдеров (например, Google, Apple, GitHub),  
**Чтобы** не создавать и не запоминать еще один пароль.

**Критерии приемки:**

1. **Обнаружение провайдеров**:
    - На экране входа, после того как пользователь ввел адрес своего homeserver (`Story 2.0`), приложение отправляет запрос на сервер, чтобы определить доступные методы входа.
    - Если homeserver поддерживает SSO, на экране динамически появляются кнопки для соответствующих провайдеров (например, «Войти через Google»). Если SSO не настроен на сервере, эти кнопки не отображаются.
2. **Инициирование входа**:
   - При нажатии на кнопку SSO-провайдера приложение обращается к `matrix-rust-sdk`, чтобы получить URL для аутентификации.
3. **Безопасная аутентификация через Flutter-пакет**:
    - Приложение открывает URL для аутентификации с использованием Flutter-пакета (например, `flutter_appauth` или `flutter_web_auth`), который под капотом вызывает нативные, безопасные браузерные компоненты: `SFSafariViewController` на iOS и `Chrome Custom Tabs` на Android.
    - **Важное уточнение**: Мы не используем обычный `WebView` виджет внутри приложения, так как он не обеспечивает должного уровня безопасности (приложение имеет доступ к его состоянию). Использование `SFSafariViewController`/`Custom Tabs` гарантирует, что процесс входа происходит в отдельном, доверенном процессе операционной системы.
4. **Обработка перенаправления (Callback)**:
    - После успешной аутентификации у провайдера, он перенаправляет пользователя на `callback URI` с кастомной схемой (например, `skiffymessenger://auth`).
    - Приложение должно быть зарегистрировано в ОС для обработки этой схемы. Flutter-пакет (например, `uni_links`) перехватывает этот `callback`, извлекает из него данные и возвращает управление приложению, закрывая браузерную вкладку.
5. **Завершение аутентификации**:
   - Перехваченные данные передаются обратно в `matrix-rust-sdk`.
   - SDK завершает процесс аутентификации с homeserver, получает `access_token` и `device_id`.
   - Дальнейшие шаги (сохранение сессии, переход на главный экран) идентичны `Story 2.1`.
6. **Обработка ошибок**:
   - Если пользователь закрывает окно аутентификации, не завершив вход, приложение возвращается на экран входа без ошибки.
   - В случае сбоя аутентификации на стороне провайдера или сервера, пользователь получает понятное сообщение об ошибке (например, «Не удалось войти через...»).

## Story 2.5: Реализация базовых SSO-провайдеров (Уровень 1)

**Как** пользователь,
**я хочу** войти в систему с помощью своего аккаунта Google или Apple,
**чтобы** пройти аутентификацию максимально быстро и привычным способом.

**Критерии приемки:**

1. На экране входа, если homeserver поддерживает SSO, отображаются кнопки **«Sign in with Google»** и **«Sign in with Apple»**.
2. Реализован полный флоу аутентификации для провайдера **Google** в соответствии с архитектурой, заложенной в `Story 2.4`.
3. Реализован полный флоу аутентификации для провайдера **Apple** в соответствии с `Story 2.4`.
4. Функционал корректно работает на платформах iOS и Android.
5. Приложение успешно проходит проверку в App Store, выполняя требование Apple по обязательной интеграции «Sign in with Apple».

## Story 2.6: Реализация стратегически важных SSO-провайдеров (Уровень 2)

**Как** технически-ориентированный пользователь,
**я хочу** войти в систему с помощью своего **GitHub** аккаунта или **собственного OIDC-сервера**,
**чтобы** использовать доверенного провайдера и соответствовать корпоративным политикам безопасности.

**Критерии приемки:**

1. К списку SSO-провайдеров, если они поддерживаются сервером, добавлена кнопка **«Sign in with GitHub»**.
2. Реализован полный флоу аутентификации для провайдера **GitHub**.
3. Реализована возможность подключения к любому OIDC-совместимому серверу.
    - **Критическое замечание**: это может потребовать дополнительного UI, например, отдельного экрана или модального окна, где пользователь сможет ввести `issuer URL` своего OIDC-сервера. Этот момент нужно будет проработать на этапе дизайна.
4. Функционал протестирован на совместимость с популярными OIDC-серверами (например, Keycloak).

## Story 2.7: Реализация SSO-провайдеров для расширения охвата (Уровень 3)

**Как** пользователь,
**я хочу** иметь возможность войти в систему через **GitLab** или **Facebook**,
**чтобы** использовать наиболее удобный для меня сервис.

**Критерии приемки:**

1. К списку SSO-провайдеров, если они поддерживаются сервером, добавлены кнопки **«Sign in with GitLab»** и **«Sign in with Facebook»**.
2. Реализован полный флоу аутентификации для провайдера **GitLab**.
3. Реализован полный флоу аутентификации для провайдера **Facebook**.
4. **Важное бизнес-решение**: команда подтвердила, что добавление Facebook не противоречит позиционированию SkiffyMessenger как privacy-first продукта.

## Story 2.8: Реализация интерактивной регистрации с поддержкой CAPTCHA

**Как** новый пользователь,
**Я хочу** пройти многоэтапный процесс регистрации на homeserver, включая решение CAPTCHA, не покидая приложение,
**Чтобы** создать аккаунт максимально быстро и без лишних переключений между экранами.

**Критерии приемки:**

1. **Архитектура State Machine в Rust:**
    - Вся логика регистрации, включая последовательность шагов (UIA), инкапсулирована в Rust-ядре (`rust/register`) в виде state-машины.
    - Flutter-клиент является «тонким» и только отображает состояния, которые ему присылает Rust-ядро. Он не содержит логики, связанной с протоколом Matrix.
2. **Запуск процесса регистрации:**
    - Пользователь нажимает «Зарегистрироваться». UI вызывает единый метод в Rust-слое, например `registration.start()`.
    - Rust-слой делает GET-запрос на `/v3/register`, получает доступные `flows` и возвращает во Flutter первое состояние для отображения (например, `RegistrationStep::InitialForm`).
3. **Обработка шага с CAPTCHA (компромисс для MVP):**
    - Если Rust-ядро определяет, что следующий шаг — `m.login.recaptcha`, оно возвращает во Flutter состояние `RegistrationStep::RecaptchaRequired { site_key: "..." }`.
    - Flutter отображает нативный экран с полями для ввода (логин, пароль) и, в рамках этого же экрана, рендерит **изолированный `WebView`** для отображения виджета Google reCAPTCHA.
    - Этот `WebView` должен быть сконфигурирован с максимальными ограничениями:
        - Запрещена любая навигация.
        - Выполнение JavaScript ограничено только скриптами, необходимыми для работы reCAPTCHA.
        - Отсутствует прямой обмен данными (cookies, local storage) с остальной частью приложения.
    - После успешного решения CAPTCHA, клиентский скрипт `WebView` должен передать токен `g-recaptcha-response` обратно во Flutter.
    - Flutter передает этот токен, вместе с другими данными формы (логин/пароль), в Rust-ядро через метод `registration.submit_step(data: ...)`
4. **Поддержка других шагов UIA:**
    - Процесс повторяется для других возможных шагов, которые может запросить сервер (например, `m.login.email.identity`): Rust-ядро возвращает `RegistrationStep::EmailRequired`, Flutter показывает поле для ввода email.
5. **Завершение и обработка ошибок:**
    - После успешного прохождения всех шагов сервер возвращает `200 OK`. Rust-ядро сообщает Flutter о состоянии `RegistrationStep::Success { user_id, device_id, access_token }`.
    - Flutter автоматически выполняет вход: сохраняет токен в защищенное хранилище (согласно `Story 1.3`) и перенаправляет пользователя на главный экран (согласно `Story 2.3`).
    - Любые ошибки от сервера (например, `M_USER_IN_USE`, `M_INVALID_USERNAME`) обрабатываются в Rust-слое и передаются во Flutter в виде понятных сообщений для пользователя.

**Замечания к реализации:**

- **Изоляция `WebView`:** Это ключевой аспект для безопасности. Необходимо уделить особое внимание настройке `WebView` во Flutter, чтобы минимизировать потенциальные риски. Этот компромисс допустим для MVP, но в будущем стоит рассмотреть альтернативные нативные решения для CAPTCHA, если они появятся.
- **Перехват токена:** Механизм передачи `g-recaptcha-response` из `WebView` во Flutter требует тщательной проработки. Возможно, придется использовать `JavaScriptChannel` или аналогичные инструменты, но с жестким контролем передаваемых данных.

## Story 2.9: Автоматическое переключение между Регистрацией и Входом при SSO

**Как** пользователь,  
**Я хочу**, чтобы при использовании SSO-провайдера (например, Google) приложение само определяло, нужно ли создать новый аккаунт или войти в существующий,  
**Чтобы** не задумываться, нажимать мне кнопку «Войти» или «Зарегистрироваться».

**Критерии приемки:**

1. Пользователь инициирует действие (например, «Продолжить с Google») с экрана, где есть и вход, и регистрация.
2. Приложение выполняет полный цикл аутентификации у SSO-провайдера и получает токен.
3. Приложение сначала пытается **войти** с этим токеном (согласно `Story 2.4`).PRD.md
4. Если вход успешен — пользователь попадает в приложение.
5. Если homeserver отвечает ошибкой, указывающей, что пользователь с таким SSO-идентификатором не найден, приложение **автоматически** переключается на флоу **регистрации** (согласно `Story 2.8`), используя тот же SSO-токен.
6. Если во время флоу регистрации сервер требует от пользователя дополнительных данных (например, выбрать имя пользователя), приложение должно отобразить соответствующий экран.

## Story 2.10: Проверка доступности имени пользователя

**Как** разработчик `matrix-rust-sdk`,  
**Я хочу** иметь в SDK метод для асинхронной проверки доступности имени пользователя на homeserver,  
**Чтобы** UI-клиент (SkiffyMessenger) мог предоставлять пользователю обратную связь в реальном времени во время регистрации.

**Критерии приемки:**

1. В SDK реализована функция (например, `client.check_username_availability(username)`), которая отправляет `GET` запрос на эндпоинт `/v3/register/available`.
2. Метод корректно обрабатывает успешный ответ (`200 OK` с `{"available": true}`).
3. Метод корректно обрабатывает ошибки: `M_USER_IN_USE` (имя занято), `M_INVALID_USERNAME` (недопустимые символы), а также стандартные сетевые ошибки и rate-лимиты.
4. _Важное замечание для UI-команды:_ Спецификация Matrix предупреждает, что успешная проверка **не резервирует** имя пользователя. Существует теоретический шанс, что кто-то займет его между проверкой и фактической регистрацией.

---

_This is a shard of the complete SkiffyMessenger PRD. For the full document, see: [../prd.md](../prd.md)_
