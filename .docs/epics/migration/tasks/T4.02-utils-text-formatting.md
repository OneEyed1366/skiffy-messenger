# T4.02: Text Formatting Utilities

## Metadata

| Field        | Value                 |
| ------------ | --------------------- |
| **ID**       | T4.02                 |
| **Layer**    | L4 - Formatting Utils |
| **Status**   | pending               |
| **Priority** | high                  |
| **Estimate** | 4h                    |
| **Parallel** | true                  |
| **Assignee** | -                     |
| **Created**  | 2026-01-04            |
| **Updated**  | 2026-01-04            |

## Dependencies

| Task ID | Name         |
| ------- | ------------ |
| T2.03   | utils-string |

## Blocks

| Task ID | Name                    |
| ------- | ----------------------- |
| T10b.xx | Post/message components |
| T10c.xx | Chat input components   |

## Description

Migrate text formatting utilities for chat messages from Mattermost. These utilities handle:

- `formatMentions` - @username highlighting with regex-based detection
- `formatLinks` - URL detection and autolink conversion
- `formatEmojis` - Emoji shortcode parsing (`:emoji_name:`)
- `escapeHtml` / `unescapeHtml` - HTML entity encoding/decoding
- `truncateText` - Text truncation with ellipsis support

## Source Files

- `vendor/desktop/webapp/channels/src/utils/text_formatting.tsx` (lines 433-444, 517-553, 666-696)
- `vendor/desktop/webapp/channels/src/utils/emoticons.tsx` (lines 28-104)

### Original Implementation Analysis

#### escapeHtml / unescapeHtml (text_formatting.tsx:433-444, 674-696)

```typescript
const htmlEntities = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#039;",
};

export function escapeHtml(text: string): string {
  return text.replace(
    /[&<>"']/g,
    (match: string) => htmlEntities[match as keyof typeof htmlEntities],
  );
}

export function convertEntityToCharacter(text: string): string {
  return text
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&#39;/g, "'")
    .replace(/&quot;/g, '"')
    .replace(/&amp;/g, "&");
}
```

#### autolinkAtMentions (text_formatting.tsx:517-553)

```typescript
export function autolinkAtMentions(text: string, tokens: Tokens): string {
  function replaceAtMentionWithToken(fullMatch: string, username: string) {
    // Handles @channel, @all, @here special mentions
    // Handles @username mentions with trailing punctuation support
  }
  // Uses Constants.SPECIAL_MENTIONS_REGEX and Constants.MENTIONS_REGEX
}
```

#### Emoji Pattern (emoticons.tsx:28)

```typescript
export const EMOJI_PATTERN = /(:([a-zA-Z0-9_+-]+):)/g;
```

## Target File

`apps/v2/src/utils/text-formatting/text-formatting.ts`

## Implementation

```typescript
// apps/v2/src/utils/text-formatting/text-formatting.ts

//#region Types

type IHtmlEntity = "&" | "<" | ">" | '"' | "'";

type IMentionMatch = {
  username: string;
  index: number;
  length: number;
};

type ILinkMatch = {
  url: string;
  index: number;
  length: number;
};

type IEmojiMatch = {
  shortcode: string;
  index: number;
  length: number;
};

type ITruncateOptions = {
  maxLength: number;
  ellipsis?: string;
  preserveWords?: boolean;
};

//#endregion Types

//#region Constants

const HTML_ENTITIES: Record<IHtmlEntity, string> = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#039;",
};

const HTML_ENTITY_DECODE: Record<string, string> = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&#039;": "'",
  "&#39;": "'",
  "&apos;": "'",
};

/**
 * Matches @username mentions.
 * Supports: letters, numbers, dots, hyphens, underscores.
 * Does not match email patterns (user@domain.com).
 */
const MENTION_REGEX = /(?:^|[^@\w])@([a-zA-Z][a-zA-Z0-9._-]*)/g;

/**
 * Matches special mentions: @all, @channel, @here
 */
const SPECIAL_MENTION_REGEX = /(?:^|[^\w])@(all|channel|here)(?=[^\w]|$)/gi;

/**
 * Matches emoji shortcodes like :smile: or :+1:
 */
const EMOJI_SHORTCODE_REGEX = /:([a-zA-Z0-9_+-]+):/g;

/**
 * Matches URLs with common protocols.
 * Simplified pattern for basic URL detection.
 */
const URL_REGEX =
  /(?:https?:\/\/|www\.)[^\s<>[\]()'"]+(?:\([^\s<>[\]()'"]*\)|[^\s<>[\]()'".,;:!?])/gi;

/**
 * Default ellipsis character for truncation.
 */
const DEFAULT_ELLIPSIS = "...";

//#endregion Constants

//#region HTML Escape/Unescape

/**
 * Escapes HTML special characters to prevent XSS attacks.
 * Converts: & < > " ' to their HTML entity equivalents.
 *
 * @param text - Raw text to escape
 * @returns HTML-safe escaped string
 *
 * @example
 * escapeHtml('<script>alert("xss")</script>');
 * // => '&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;'
 */
export function escapeHtml(text: string): string {
  if (!text) {
    return "";
  }
  return text.replace(/[&<>"']/g, (char) => HTML_ENTITIES[char as IHtmlEntity]);
}

/**
 * Unescapes HTML entities back to their original characters.
 * Converts: &amp; &lt; &gt; &quot; &#039; to & < > " '
 *
 * @param text - HTML-escaped text to unescape
 * @returns Original unescaped string
 *
 * @example
 * unescapeHtml('&lt;div&gt;Hello &amp; World&lt;/div&gt;');
 * // => '<div>Hello & World</div>'
 */
export function unescapeHtml(text: string): string {
  if (!text) {
    return "";
  }
  return text.replace(
    /&(?:amp|lt|gt|quot|#039|#39|apos);/g,
    (entity) => HTML_ENTITY_DECODE[entity] ?? entity,
  );
}

//#endregion HTML Escape/Unescape

//#region Mention Formatting

/**
 * Detects and extracts @username mentions from text.
 * Excludes email addresses (user@domain.com patterns).
 *
 * @param text - Text to search for mentions
 * @returns Array of mention matches with position info
 *
 * @example
 * extractMentions('Hello @john and @jane.doe!');
 * // => [
 * //   { username: 'john', index: 6, length: 5 },
 * //   { username: 'jane.doe', index: 17, length: 9 }
 * // ]
 */
export function extractMentions(text: string): IMentionMatch[] {
  if (!text) {
    return [];
  }

  const mentions: IMentionMatch[] = [];
  let match: RegExpExecArray | null;

  // Reset regex state
  MENTION_REGEX.lastIndex = 0;
  SPECIAL_MENTION_REGEX.lastIndex = 0;

  // Extract special mentions first (@all, @channel, @here)
  while ((match = SPECIAL_MENTION_REGEX.exec(text)) !== null) {
    const fullMatch = match[0];
    const username = match[1];
    const prefixLength = fullMatch.length - username.length - 1; // -1 for @
    mentions.push({
      username: username.toLowerCase(),
      index: match.index + prefixLength,
      length: username.length + 1, // +1 for @
    });
  }

  // Extract regular @username mentions
  while ((match = MENTION_REGEX.exec(text)) !== null) {
    const fullMatch = match[0];
    const username = match[1];
    const prefixLength = fullMatch.length - username.length - 1; // -1 for @
    mentions.push({
      username,
      index: match.index + prefixLength,
      length: username.length + 1, // +1 for @
    });
  }

  return mentions;
}

/**
 * Wraps @mentions in text with highlight spans.
 *
 * @param text - Text containing mentions to format
 * @param highlightClass - CSS class for highlight span (default: 'mention-highlight')
 * @returns Text with mentions wrapped in spans
 *
 * @example
 * formatMentions('Hello @john!');
 * // => 'Hello <span class="mention-highlight">@john</span>!'
 */
export function formatMentions(
  text: string,
  highlightClass = "mention-highlight",
): string {
  if (!text) {
    return "";
  }

  const mentions = extractMentions(text);
  if (mentions.length === 0) {
    return text;
  }

  // Sort by index descending to replace from end (preserves indices)
  const sortedMentions = [...mentions].sort((a, b) => b.index - a.index);

  let result = text;
  for (const mention of sortedMentions) {
    const mentionText = result.slice(
      mention.index,
      mention.index + mention.length,
    );
    const wrapped = `<span class="${highlightClass}">${escapeHtml(mentionText)}</span>`;
    result =
      result.slice(0, mention.index) +
      wrapped +
      result.slice(mention.index + mention.length);
  }

  return result;
}

/**
 * Checks if a mention is a special broadcast mention.
 *
 * @param mention - Mention username (without @)
 * @returns True if it's @all, @channel, or @here
 */
export function isSpecialMention(mention: string): boolean {
  const normalized = mention.toLowerCase();
  return (
    normalized === "all" || normalized === "channel" || normalized === "here"
  );
}

//#endregion Mention Formatting

//#region Link Formatting

/**
 * Detects and extracts URLs from text.
 *
 * @param text - Text to search for URLs
 * @returns Array of link matches with position info
 *
 * @example
 * extractLinks('Visit https://example.com or www.test.org');
 * // => [
 * //   { url: 'https://example.com', index: 6, length: 19 },
 * //   { url: 'www.test.org', index: 29, length: 12 }
 * // ]
 */
export function extractLinks(text: string): ILinkMatch[] {
  if (!text) {
    return [];
  }

  const links: ILinkMatch[] = [];
  let match: RegExpExecArray | null;

  // Reset regex state
  URL_REGEX.lastIndex = 0;

  while ((match = URL_REGEX.exec(text)) !== null) {
    links.push({
      url: match[0],
      index: match.index,
      length: match[0].length,
    });
  }

  return links;
}

/**
 * Converts URLs in text to clickable anchor tags.
 *
 * @param text - Text containing URLs to format
 * @param options - Link options (target, rel attributes)
 * @returns Text with URLs converted to anchor tags
 *
 * @example
 * formatLinks('Visit https://example.com');
 * // => 'Visit <a href="https://example.com" target="_blank" rel="noopener noreferrer">https://example.com</a>'
 */
export function formatLinks(
  text: string,
  options: { target?: string; rel?: string } = {},
): string {
  if (!text) {
    return "";
  }

  const { target = "_blank", rel = "noopener noreferrer" } = options;
  const links = extractLinks(text);

  if (links.length === 0) {
    return text;
  }

  // Sort by index descending to replace from end (preserves indices)
  const sortedLinks = [...links].sort((a, b) => b.index - a.index);

  let result = text;
  for (const link of sortedLinks) {
    const url = link.url;
    const href = url.startsWith("www.") ? `https://${url}` : url;
    const anchor = `<a href="${escapeHtml(href)}" target="${target}" rel="${rel}">${escapeHtml(url)}</a>`;
    result =
      result.slice(0, link.index) +
      anchor +
      result.slice(link.index + link.length);
  }

  return result;
}

//#endregion Link Formatting

//#region Emoji Formatting

/**
 * Detects and extracts emoji shortcodes from text.
 *
 * @param text - Text to search for emoji shortcodes
 * @returns Array of emoji matches with position info
 *
 * @example
 * extractEmojis('Hello :wave: and :smile:');
 * // => [
 * //   { shortcode: 'wave', index: 6, length: 6 },
 * //   { shortcode: 'smile', index: 17, length: 7 }
 * // ]
 */
export function extractEmojis(text: string): IEmojiMatch[] {
  if (!text) {
    return [];
  }

  const emojis: IEmojiMatch[] = [];
  let match: RegExpExecArray | null;

  // Reset regex state
  EMOJI_SHORTCODE_REGEX.lastIndex = 0;

  while ((match = EMOJI_SHORTCODE_REGEX.exec(text)) !== null) {
    emojis.push({
      shortcode: match[1],
      index: match.index,
      length: match[0].length,
    });
  }

  return emojis;
}

/**
 * Wraps emoji shortcodes with data attributes for emoji rendering.
 *
 * @param text - Text containing emoji shortcodes
 * @returns Text with emoji shortcodes wrapped in spans
 *
 * @example
 * formatEmojis('Hello :wave:!');
 * // => 'Hello <span data-emoticon="wave">:wave:</span>!'
 */
export function formatEmojis(text: string): string {
  if (!text) {
    return "";
  }

  // Reset regex state
  EMOJI_SHORTCODE_REGEX.lastIndex = 0;

  return text.replace(EMOJI_SHORTCODE_REGEX, (fullMatch, shortcode: string) => {
    return `<span data-emoticon="${escapeHtml(shortcode.toLowerCase())}">${escapeHtml(fullMatch)}</span>`;
  });
}

/**
 * Checks if a string is a valid emoji shortcode format.
 *
 * @param text - Text to validate
 * @returns True if it matches :shortcode: pattern
 */
export function isEmojiShortcode(text: string): boolean {
  if (!text) {
    return false;
  }
  return /^:[a-zA-Z0-9_+-]+:$/.test(text);
}

//#endregion Emoji Formatting

//#region Text Truncation

/**
 * Truncates text to specified length with ellipsis.
 *
 * @param text - Text to truncate
 * @param options - Truncation options
 * @returns Truncated text with ellipsis if needed
 *
 * @example
 * truncateText('Hello World!', { maxLength: 8 });
 * // => 'Hello...'
 *
 * truncateText('Hello World!', { maxLength: 8, preserveWords: true });
 * // => 'Hello...'
 *
 * truncateText('Hello World!', { maxLength: 10, ellipsis: '...' });
 * // => 'Hello W...'
 */
export function truncateText(text: string, options: ITruncateOptions): string {
  if (!text) {
    return "";
  }

  const {
    maxLength,
    ellipsis = DEFAULT_ELLIPSIS,
    preserveWords = false,
  } = options;

  if (text.length <= maxLength) {
    return text;
  }

  const truncateAt = maxLength - ellipsis.length;

  if (truncateAt <= 0) {
    return ellipsis.slice(0, maxLength);
  }

  let truncated = text.slice(0, truncateAt);

  if (preserveWords) {
    // Find last space to preserve word boundary
    const lastSpace = truncated.lastIndexOf(" ");
    if (lastSpace > 0) {
      truncated = truncated.slice(0, lastSpace);
    }
  }

  // Trim trailing whitespace and punctuation
  truncated = truncated.replace(/[\s.,;:!?]+$/, "");

  return truncated + ellipsis;
}

/**
 * Truncates text in the middle, keeping start and end visible.
 *
 * @param text - Text to truncate
 * @param maxLength - Maximum total length including ellipsis
 * @param ellipsis - Ellipsis string (default: '...')
 * @returns Text with middle truncated
 *
 * @example
 * truncateMiddle('very-long-filename.txt', 15);
 * // => 'very-...me.txt'
 */
export function truncateMiddle(
  text: string,
  maxLength: number,
  ellipsis = DEFAULT_ELLIPSIS,
): string {
  if (!text) {
    return "";
  }

  if (text.length <= maxLength) {
    return text;
  }

  const availableLength = maxLength - ellipsis.length;
  if (availableLength <= 0) {
    return ellipsis.slice(0, maxLength);
  }

  const startLength = Math.ceil(availableLength / 2);
  const endLength = Math.floor(availableLength / 2);

  return text.slice(0, startLength) + ellipsis + text.slice(-endLength);
}

//#endregion Text Truncation
```

## Index Export

```typescript
// apps/v2/src/utils/text-formatting/index.ts

export {
  // HTML escape/unescape
  escapeHtml,
  unescapeHtml,
  // Mentions
  extractMentions,
  formatMentions,
  isSpecialMention,
  // Links
  extractLinks,
  formatLinks,
  // Emojis
  extractEmojis,
  formatEmojis,
  isEmojiShortcode,
  // Truncation
  truncateText,
  truncateMiddle,
} from "./text-formatting";
```

```typescript
// apps/v2/src/utils/index.ts (add to existing)

export * from "./text-formatting";
```

## Acceptance Criteria

- [ ] `escapeHtml` converts `& < > " '` to HTML entities
- [ ] `unescapeHtml` decodes `&amp; &lt; &gt; &quot; &#039;` back to characters
- [ ] `extractMentions` detects @username patterns, excludes emails
- [ ] `formatMentions` wraps mentions in `<span>` with configurable class
- [ ] `isSpecialMention` identifies @all, @channel, @here
- [ ] `extractLinks` detects http/https/www URLs
- [ ] `formatLinks` converts URLs to anchor tags with proper attributes
- [ ] `extractEmojis` detects :shortcode: patterns
- [ ] `formatEmojis` wraps shortcodes in spans with data-emoticon attribute
- [ ] `truncateText` handles maxLength, ellipsis, preserveWords options
- [ ] `truncateMiddle` keeps start and end visible
- [ ] All functions handle empty/null input gracefully
- [ ] TypeScript strict mode passes
- [ ] No `any` types
- [ ] Exported from `utils/index.ts`

## Testing

```typescript
// apps/v2/src/utils/text-formatting/text-formatting.spec.ts

import {
  escapeHtml,
  unescapeHtml,
  extractMentions,
  formatMentions,
  isSpecialMention,
  extractLinks,
  formatLinks,
  extractEmojis,
  formatEmojis,
  isEmojiShortcode,
  truncateText,
  truncateMiddle,
} from "./text-formatting";

//#region escapeHtml

describe("escapeHtml", () => {
  it("escapes ampersand", () => {
    expect(escapeHtml("Tom & Jerry")).toBe("Tom &amp; Jerry");
  });

  it("escapes angle brackets", () => {
    expect(escapeHtml("<div>")).toBe("&lt;div&gt;");
  });

  it("escapes quotes", () => {
    expect(escapeHtml("\"hello\" 'world'")).toBe(
      "&quot;hello&quot; &#039;world&#039;",
    );
  });

  it("escapes all special characters together", () => {
    expect(escapeHtml('<script>alert("xss")</script>')).toBe(
      "&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;",
    );
  });

  it("returns empty string for empty input", () => {
    expect(escapeHtml("")).toBe("");
  });

  it("preserves text without special characters", () => {
    expect(escapeHtml("Hello World 123")).toBe("Hello World 123");
  });
});

//#endregion escapeHtml

//#region unescapeHtml

describe("unescapeHtml", () => {
  it("unescapes ampersand", () => {
    expect(unescapeHtml("Tom &amp; Jerry")).toBe("Tom & Jerry");
  });

  it("unescapes angle brackets", () => {
    expect(unescapeHtml("&lt;div&gt;")).toBe("<div>");
  });

  it("unescapes double quotes", () => {
    expect(unescapeHtml("&quot;hello&quot;")).toBe('"hello"');
  });

  it("unescapes single quotes (all variants)", () => {
    expect(unescapeHtml("&#039;a&#039;")).toBe("'a'");
    expect(unescapeHtml("&#39;b&#39;")).toBe("'b'");
    expect(unescapeHtml("&apos;c&apos;")).toBe("'c'");
  });

  it("returns empty string for empty input", () => {
    expect(unescapeHtml("")).toBe("");
  });

  it("is inverse of escapeHtml", () => {
    const original = '<div class="test">Hello & World</div>';
    expect(unescapeHtml(escapeHtml(original))).toBe(original);
  });
});

//#endregion unescapeHtml

//#region extractMentions

describe("extractMentions", () => {
  it("extracts single mention", () => {
    const result = extractMentions("Hello @john");
    expect(result).toHaveLength(1);
    expect(result[0].username).toBe("john");
  });

  it("extracts multiple mentions", () => {
    const result = extractMentions("@alice and @bob are here");
    expect(result).toHaveLength(2);
    expect(result[0].username).toBe("alice");
    expect(result[1].username).toBe("bob");
  });

  it("extracts mentions with dots and hyphens", () => {
    const result = extractMentions("@john.doe and @jane-smith");
    expect(result).toHaveLength(2);
    expect(result[0].username).toBe("john.doe");
    expect(result[1].username).toBe("jane-smith");
  });

  it("extracts special mentions", () => {
    const result = extractMentions(
      "@all please note @channel is important @here",
    );
    const usernames = result.map((m) => m.username);
    expect(usernames).toContain("all");
    expect(usernames).toContain("channel");
    expect(usernames).toContain("here");
  });

  it("does not match email addresses", () => {
    const result = extractMentions("Contact user@example.com");
    expect(result).toHaveLength(0);
  });

  it("returns empty array for empty input", () => {
    expect(extractMentions("")).toEqual([]);
  });

  it("returns empty array for text without mentions", () => {
    expect(extractMentions("Hello World")).toEqual([]);
  });
});

//#endregion extractMentions

//#region formatMentions

describe("formatMentions", () => {
  it("wraps mention in span with default class", () => {
    const result = formatMentions("Hello @john!");
    expect(result).toContain('<span class="mention-highlight">@john</span>');
  });

  it("uses custom highlight class", () => {
    const result = formatMentions("Hello @john", "custom-class");
    expect(result).toContain('<span class="custom-class">@john</span>');
  });

  it("formats multiple mentions", () => {
    const result = formatMentions("@alice and @bob");
    expect(result).toContain('<span class="mention-highlight">@alice</span>');
    expect(result).toContain('<span class="mention-highlight">@bob</span>');
  });

  it("returns original text if no mentions", () => {
    expect(formatMentions("Hello World")).toBe("Hello World");
  });

  it("returns empty string for empty input", () => {
    expect(formatMentions("")).toBe("");
  });
});

//#endregion formatMentions

//#region isSpecialMention

describe("isSpecialMention", () => {
  it("returns true for all", () => {
    expect(isSpecialMention("all")).toBe(true);
    expect(isSpecialMention("ALL")).toBe(true);
  });

  it("returns true for channel", () => {
    expect(isSpecialMention("channel")).toBe(true);
    expect(isSpecialMention("CHANNEL")).toBe(true);
  });

  it("returns true for here", () => {
    expect(isSpecialMention("here")).toBe(true);
    expect(isSpecialMention("HERE")).toBe(true);
  });

  it("returns false for regular usernames", () => {
    expect(isSpecialMention("john")).toBe(false);
    expect(isSpecialMention("alice")).toBe(false);
  });
});

//#endregion isSpecialMention

//#region extractLinks

describe("extractLinks", () => {
  it("extracts https URLs", () => {
    const result = extractLinks("Visit https://example.com");
    expect(result).toHaveLength(1);
    expect(result[0].url).toBe("https://example.com");
  });

  it("extracts http URLs", () => {
    const result = extractLinks("Go to http://test.org/page");
    expect(result).toHaveLength(1);
    expect(result[0].url).toBe("http://test.org/page");
  });

  it("extracts www URLs", () => {
    const result = extractLinks("See www.example.com");
    expect(result).toHaveLength(1);
    expect(result[0].url).toBe("www.example.com");
  });

  it("extracts multiple URLs", () => {
    const result = extractLinks("Visit https://a.com and https://b.com");
    expect(result).toHaveLength(2);
  });

  it("extracts URLs with paths and query params", () => {
    const result = extractLinks("Link: https://example.com/path?q=test");
    expect(result[0].url).toBe("https://example.com/path?q=test");
  });

  it("returns empty array for text without URLs", () => {
    expect(extractLinks("Hello World")).toEqual([]);
  });

  it("returns empty array for empty input", () => {
    expect(extractLinks("")).toEqual([]);
  });
});

//#endregion extractLinks

//#region formatLinks

describe("formatLinks", () => {
  it("converts URL to anchor tag", () => {
    const result = formatLinks("Visit https://example.com");
    expect(result).toContain('<a href="https://example.com"');
    expect(result).toContain('target="_blank"');
    expect(result).toContain('rel="noopener noreferrer"');
  });

  it("adds https to www URLs", () => {
    const result = formatLinks("See www.example.com");
    expect(result).toContain('href="https://www.example.com"');
  });

  it("uses custom target and rel", () => {
    const result = formatLinks("https://example.com", {
      target: "_self",
      rel: "nofollow",
    });
    expect(result).toContain('target="_self"');
    expect(result).toContain('rel="nofollow"');
  });

  it("returns original text if no URLs", () => {
    expect(formatLinks("Hello World")).toBe("Hello World");
  });

  it("returns empty string for empty input", () => {
    expect(formatLinks("")).toBe("");
  });
});

//#endregion formatLinks

//#region extractEmojis

describe("extractEmojis", () => {
  it("extracts single emoji shortcode", () => {
    const result = extractEmojis("Hello :wave:");
    expect(result).toHaveLength(1);
    expect(result[0].shortcode).toBe("wave");
  });

  it("extracts multiple emoji shortcodes", () => {
    const result = extractEmojis(":smile: and :thumbsup:");
    expect(result).toHaveLength(2);
    expect(result[0].shortcode).toBe("smile");
    expect(result[1].shortcode).toBe("thumbsup");
  });

  it("extracts emoji with underscores", () => {
    const result = extractEmojis(":thumbs_up:");
    expect(result[0].shortcode).toBe("thumbs_up");
  });

  it("extracts emoji with plus", () => {
    const result = extractEmojis(":+1:");
    expect(result[0].shortcode).toBe("+1");
  });

  it("returns empty array for text without emojis", () => {
    expect(extractEmojis("Hello World")).toEqual([]);
  });

  it("returns empty array for empty input", () => {
    expect(extractEmojis("")).toEqual([]);
  });
});

//#endregion extractEmojis

//#region formatEmojis

describe("formatEmojis", () => {
  it("wraps emoji shortcode in span", () => {
    const result = formatEmojis("Hello :wave:!");
    expect(result).toBe('Hello <span data-emoticon="wave">:wave:</span>!');
  });

  it("formats multiple emojis", () => {
    const result = formatEmojis(":a: :b:");
    expect(result).toContain('data-emoticon="a"');
    expect(result).toContain('data-emoticon="b"');
  });

  it("lowercases shortcode in data attribute", () => {
    const result = formatEmojis(":WAVE:");
    expect(result).toContain('data-emoticon="wave"');
  });

  it("returns original text if no emojis", () => {
    expect(formatEmojis("Hello World")).toBe("Hello World");
  });

  it("returns empty string for empty input", () => {
    expect(formatEmojis("")).toBe("");
  });
});

//#endregion formatEmojis

//#region isEmojiShortcode

describe("isEmojiShortcode", () => {
  it("returns true for valid shortcodes", () => {
    expect(isEmojiShortcode(":smile:")).toBe(true);
    expect(isEmojiShortcode(":+1:")).toBe(true);
    expect(isEmojiShortcode(":thumbs_up:")).toBe(true);
  });

  it("returns false for invalid patterns", () => {
    expect(isEmojiShortcode("smile")).toBe(false);
    expect(isEmojiShortcode(":smile")).toBe(false);
    expect(isEmojiShortcode("smile:")).toBe(false);
    expect(isEmojiShortcode("::")).toBe(false);
  });

  it("returns false for empty input", () => {
    expect(isEmojiShortcode("")).toBe(false);
  });
});

//#endregion isEmojiShortcode

//#region truncateText

describe("truncateText", () => {
  it("truncates text exceeding maxLength", () => {
    const result = truncateText("Hello World!", { maxLength: 8 });
    expect(result).toBe("Hello...");
    expect(result.length).toBe(8);
  });

  it("returns original text if within maxLength", () => {
    const result = truncateText("Hello", { maxLength: 10 });
    expect(result).toBe("Hello");
  });

  it("uses custom ellipsis", () => {
    const result = truncateText("Hello World!", {
      maxLength: 9,
      ellipsis: "…",
    });
    expect(result).toBe("Hello Wo…");
  });

  it("preserves word boundaries when preserveWords is true", () => {
    const result = truncateText("Hello World Test", {
      maxLength: 12,
      preserveWords: true,
    });
    expect(result).toBe("Hello...");
  });

  it("trims trailing punctuation", () => {
    const result = truncateText("Hello, World!", { maxLength: 9 });
    expect(result).toBe("Hello...");
  });

  it("returns empty string for empty input", () => {
    expect(truncateText("", { maxLength: 10 })).toBe("");
  });

  it("handles maxLength smaller than ellipsis", () => {
    const result = truncateText("Hello", { maxLength: 2 });
    expect(result).toBe("..");
  });
});

//#endregion truncateText

//#region truncateMiddle

describe("truncateMiddle", () => {
  it("truncates in the middle", () => {
    const result = truncateMiddle("very-long-filename.txt", 15);
    expect(result.length).toBe(15);
    expect(result).toContain("...");
    expect(result.startsWith("very-")).toBe(true);
    expect(result.endsWith(".txt")).toBe(true);
  });

  it("returns original text if within maxLength", () => {
    const result = truncateMiddle("short.txt", 20);
    expect(result).toBe("short.txt");
  });

  it("uses custom ellipsis", () => {
    const result = truncateMiddle("very-long-name.txt", 12, "…");
    expect(result).toContain("…");
    expect(result.length).toBe(12);
  });

  it("returns empty string for empty input", () => {
    expect(truncateMiddle("", 10)).toBe("");
  });

  it("handles maxLength smaller than ellipsis", () => {
    expect(truncateMiddle("Hello", 2)).toBe("..");
  });
});

//#endregion truncateMiddle
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- text-formatting.spec
```
