# T2.07: Math Utilities

## Metadata

| Field        | Value      |
| ------------ | ---------- |
| **ID**       | T2.07      |
| **Layer**    | L2 - Utils |
| **Status**   | pending    |
| **Priority** | low        |
| **Estimate** | 0.5h       |
| **Parallel** | true       |
| **Assignee** | -          |
| **Created**  | 2026-01-04 |
| **Updated**  | 2026-01-04 |

## Dependencies

None

## Blocks

| Task ID | Name                                       |
| ------- | ------------------------------------------ |
| T10c.\* | Components using index cycling             |
| T11.\*  | Hooks using modulo for circular navigation |

## Description

Migrate math utility functions from Mattermost. The primary function is `mod` â€” a proper Euclidean modulo that handles negative numbers correctly (unlike JavaScript's native `%` operator which returns negative remainders for negative dividends).

## Source Files

- `vendor/desktop/webapp/channels/src/utils/utils.tsx` (lines 1267-1269, 1479-1485, 1580-1598)

## Target File

`apps/v2/src/utils/math.ts`

## Implementation

```typescript
// apps/v2/src/utils/math.ts

/**
 * Math utility functions
 * Migrated from: vendor/desktop/webapp/channels/src/utils/utils.tsx
 */

//#region Modulo

/**
 * Euclidean modulo that handles negative numbers correctly.
 *
 * JavaScript's native % operator returns negative remainders for negative dividends:
 *   -1 % 5 = -1 (native JS)
 *   mod(-1, 5) = 4 (Euclidean)
 *
 * Useful for circular array indexing (e.g., cycling through a list).
 *
 * @param a - Dividend
 * @param b - Divisor (must be non-zero)
 * @returns Non-negative remainder in range [0, b)
 *
 * @example
 * mod(7, 5)   // 2
 * mod(-1, 5)  // 4
 * mod(-7, 5)  // 3
 * mod(5, 5)   // 0
 */
export function mod(a: number, b: number): number {
  return ((a % b) + b) % b;
}

//#endregion

//#region Number Formatting

/**
 * Formats a number with up to N decimal places, trimming trailing zeros.
 *
 * @param num - Number to format
 * @param places - Maximum decimal places (clamped to >= 0)
 * @returns Formatted string with minimal necessary decimal places
 *
 * @example
 * numberToFixedDynamic(3.12345, 4) // "3.1235"
 * numberToFixedDynamic(3.01000, 4) // "3.01"
 * numberToFixedDynamic(3.01000, 1) // "3"
 * numberToFixedDynamic(3.00000, 4) // "3"
 */
export function numberToFixedDynamic(num: number, places: number): string {
  const str = num.toFixed(Math.max(places, 0));

  if (!str.includes(".")) {
    return str;
  }

  let indexToExclude = -1;
  let i = str.length - 1;

  while (str[i] === "0") {
    indexToExclude = i;
    i -= 1;
  }

  if (str[i] === ".") {
    indexToExclude -= 1;
  }

  if (indexToExclude === -1) {
    return str;
  }

  return str.slice(0, indexToExclude);
}

//#endregion

//#region Parsing

/**
 * Safely parses a string to an integer, returning 0 for invalid input.
 *
 * @param s - String to parse
 * @returns Parsed integer or 0 if undefined/invalid
 *
 * @example
 * stringToNumber("42")       // 42
 * stringToNumber("3.14")     // 3
 * stringToNumber(undefined)  // 0
 * stringToNumber("")         // 0
 */
export function stringToNumber(s: string | undefined): number {
  if (!s) {
    return 0;
  }

  return parseInt(s, 10);
}

//#endregion
```

## Index Export

```typescript
// apps/v2/src/utils/index.ts

export { mod, numberToFixedDynamic, stringToNumber } from "./math";
```

## Acceptance Criteria

- [ ] `mod` function handles negative numbers correctly
- [ ] `numberToFixedDynamic` trims trailing zeros
- [ ] `stringToNumber` returns 0 for falsy input
- [ ] All functions have JSDoc with `@example`
- [ ] Uses `#region` comments for organization
- [ ] Exported from `utils/index.ts`
- [ ] No `any` types
- [ ] TypeScript strict mode passes

## Testing

```typescript
// apps/v2/src/utils/math.spec.ts

import { mod, numberToFixedDynamic, stringToNumber } from "./math";

describe("mod", () => {
  it("returns positive result for positive dividend", () => {
    expect(mod(7, 5)).toBe(2);
    expect(mod(10, 3)).toBe(1);
  });

  it("returns positive result for negative dividend", () => {
    expect(mod(-1, 5)).toBe(4);
    expect(mod(-7, 5)).toBe(3);
    expect(mod(-3, 3)).toBe(0);
  });

  it("handles zero dividend", () => {
    expect(mod(0, 5)).toBe(0);
  });

  it("handles dividend equal to divisor", () => {
    expect(mod(5, 5)).toBe(0);
  });
});

describe("numberToFixedDynamic", () => {
  it("formats with specified decimal places", () => {
    expect(numberToFixedDynamic(3.12345, 4)).toBe("3.1235");
  });

  it("trims trailing zeros", () => {
    expect(numberToFixedDynamic(3.01, 4)).toBe("3.01");
    expect(numberToFixedDynamic(3.1, 4)).toBe("3.1");
  });

  it("removes decimal point when all decimals are zero", () => {
    expect(numberToFixedDynamic(3.0, 4)).toBe("3");
    expect(numberToFixedDynamic(3.001, 1)).toBe("3");
  });

  it("handles integers", () => {
    expect(numberToFixedDynamic(42, 2)).toBe("42");
  });

  it("handles zero places", () => {
    expect(numberToFixedDynamic(3.7, 0)).toBe("4");
  });

  it("clamps negative places to zero", () => {
    expect(numberToFixedDynamic(3.7, -2)).toBe("4");
  });
});

describe("stringToNumber", () => {
  it("parses valid numeric strings", () => {
    expect(stringToNumber("42")).toBe(42);
    expect(stringToNumber("0")).toBe(0);
    expect(stringToNumber("-10")).toBe(-10);
  });

  it("parses floats as integers", () => {
    expect(stringToNumber("3.14")).toBe(3);
    expect(stringToNumber("3.99")).toBe(3);
  });

  it("returns 0 for undefined", () => {
    expect(stringToNumber(undefined)).toBe(0);
  });

  it("returns 0 for empty string", () => {
    expect(stringToNumber("")).toBe(0);
  });
});
```

Run tests:

```bash
pnpm --filter @retrievly/app test:unit -- math
```
