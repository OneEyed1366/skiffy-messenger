# T2.04: Color Utilities

## Metadata

| Field        | Value           |
| ------------ | --------------- |
| **ID**       | T2.04           |
| **Layer**    | L2 - Pure Utils |
| **Status**   | pending         |
| **Priority** | high            |
| **Estimate** | 0.5h            |
| **Parallel** | true            |
| **Assignee** | -               |
| **Created**  | 2026-01-04      |
| **Updated**  | 2026-01-04      |

## Dependencies

None

## Blocks

| Task ID | Name         |
| ------- | ------------ |
| T3.\*   | Theme system |

## Description

Migrate color manipulation utilities from Mattermost. These functions handle hex-to-RGB conversion, opacity changes, and color blending for theme support.

## Source Files

- `vendor/desktop/webapp/channels/src/utils/utils.tsx` (toRgbValues)
- `vendor/desktop/webapp/channels/src/packages/mattermost-redux/src/utils/theme_utils.ts` (changeOpacity, blendColors, getComponents, getContrastingSimpleColor)

## Target File

`apps/v2/src/utils/color.ts`

## Implementation

```typescript
// apps/v2/src/utils/color.ts

/**
 * Color manipulation utilities
 * Migrated from:
 * - vendor/desktop/webapp/channels/src/utils/utils.tsx
 * - vendor/desktop/webapp/channels/src/packages/mattermost-redux/src/utils/theme_utils.ts
 */

//#region Types

export type IColorComponents = {
  red: number;
  green: number;
  blue: number;
  alpha: number;
};

//#endregion

//#region Constants

const RGB_PATTERN = /^rgba?\((\d+),(\d+),(\d+)(?:,([\d.]+))?\)$/;

//#endregion

//#region Component Extraction

/**
 * Extracts RGBA components from a color string (hex or rgb/rgba)
 *
 * @param inColor - Color string in hex (#fff, #ffffff) or rgb/rgba format
 * @returns Object with red, green, blue (0-255) and alpha (0-1) values
 *
 * @example
 * getComponents('#ff0000') // { red: 255, green: 0, blue: 0, alpha: 1 }
 * getComponents('rgba(255,0,0,0.5)') // { red: 255, green: 0, blue: 0, alpha: 0.5 }
 */
export function getComponents(inColor: string): IColorComponents {
  let color = inColor;

  // RGB color
  const match = RGB_PATTERN.exec(color);
  if (match) {
    return {
      red: parseInt(match[1], 10),
      green: parseInt(match[2], 10),
      blue: parseInt(match[3], 10),
      alpha: match[4] ? parseFloat(match[4]) : 1,
    };
  }

  // Hex color
  if (color[0] === "#") {
    color = color.slice(1);
  }

  // Expand shorthand hex (#fff -> #ffffff)
  if (color.length === 3) {
    const tempColor = color;
    color = "";
    color += tempColor[0] + tempColor[0];
    color += tempColor[1] + tempColor[1];
    color += tempColor[2] + tempColor[2];
  }

  return {
    red: parseInt(color.substring(0, 2), 16),
    green: parseInt(color.substring(2, 4), 16),
    blue: parseInt(color.substring(4, 6), 16),
    alpha: 1,
  };
}

//#endregion

//#region Hex to RGB

/**
 * Converts a hex color string to comma-separated RGB values
 *
 * @param hexStr - Hex color string (e.g., '#ffffff')
 * @returns RGB values as string (e.g., '255, 255, 255')
 *
 * @example
 * toRgbValues('#ff5500') // '255, 85, 0'
 */
export function toRgbValues(hexStr: string): string {
  const r = parseInt(hexStr.substr(1, 2), 16);
  const g = parseInt(hexStr.substr(3, 2), 16);
  const b = parseInt(hexStr.substr(5, 2), 16);
  return `${r}, ${g}, ${b}`;
}

//#endregion

//#region Opacity

/**
 * Changes the opacity of a color
 *
 * @param oldColor - Original color (hex or rgb/rgba)
 * @param opacity - Opacity multiplier (0-1)
 * @returns Color in rgba format with adjusted opacity
 *
 * @example
 * changeOpacity('#ff0000', 0.5) // 'rgba(255,0,0,0.5)'
 * changeOpacity('rgba(255,0,0,0.8)', 0.5) // 'rgba(255,0,0,0.4)'
 */
export function changeOpacity(oldColor: string, opacity: number): string {
  const { red, green, blue, alpha } = getComponents(oldColor);
  return `rgba(${red},${green},${blue},${alpha * opacity})`;
}

//#endregion

//#region Color Blending

/**
 * Blends a single color component between background and foreground
 */
function blendComponent(
  background: number,
  foreground: number,
  opacity: number,
): number {
  return (1 - opacity) * background + opacity * foreground;
}

/**
 * Blends two colors together based on opacity
 *
 * @param background - Background color (hex or rgb/rgba)
 * @param foreground - Foreground color (hex or rgb/rgba)
 * @param opacity - Blend opacity (0 = all background, 1 = all foreground)
 * @param hex - If true, returns hex format; otherwise rgba
 * @returns Blended color in specified format
 *
 * @example
 * blendColors('#ffffff', '#000000', 0.5) // 'rgba(127,127,127,1)'
 * blendColors('#ffffff', '#000000', 0.5, true) // '#7f7f7f'
 */
export function blendColors(
  background: string,
  foreground: string,
  opacity: number,
  hex = false,
): string {
  const backgroundComponents = getComponents(background);
  const foregroundComponents = getComponents(foreground);

  const red = Math.floor(
    blendComponent(backgroundComponents.red, foregroundComponents.red, opacity),
  );
  const green = Math.floor(
    blendComponent(
      backgroundComponents.green,
      foregroundComponents.green,
      opacity,
    ),
  );
  const blue = Math.floor(
    blendComponent(
      backgroundComponents.blue,
      foregroundComponents.blue,
      opacity,
    ),
  );
  const alpha = blendComponent(
    backgroundComponents.alpha,
    foregroundComponents.alpha,
    opacity,
  );

  if (hex) {
    let r = red.toString(16);
    let g = green.toString(16);
    let b = blue.toString(16);

    if (r.length === 1) {
      r = "0" + r;
    }
    if (g.length === 1) {
      g = "0" + g;
    }
    if (b.length === 1) {
      b = "0" + b;
    }

    return `#${r + g + b}`;
  }

  return `rgba(${red},${green},${blue},${alpha})`;
}

//#endregion

//#region Contrast

/**
 * Returns a contrasting color (black or white) based on luminance
 *
 * Uses WCAG 2.1 relative luminance formula to determine
 * whether black or white provides better contrast.
 *
 * @param colorHexCode - Hex color code (with or without #)
 * @returns '#000000' or '#FFFFFF' for optimal contrast
 *
 * @example
 * getContrastingSimpleColor('#ffffff') // '#000000'
 * getContrastingSimpleColor('#000000') // '#FFFFFF'
 * getContrastingSimpleColor('ff5500') // '#000000'
 */
export function getContrastingSimpleColor(colorHexCode: string): string {
  const color = colorHexCode.startsWith("#")
    ? colorHexCode.slice(1)
    : colorHexCode;

  if (color.length !== 6) {
    return "";
  }

  // Split red, green and blue components
  const red = parseInt(color.substring(0, 2), 16);
  const green = parseInt(color.substring(2, 4), 16);
  const blue = parseInt(color.substring(4, 6), 16);

  // Calculate relative luminance - https://www.w3.org/TR/WCAG21/#dfn-relative-luminance
  const srgb = [red / 255, green / 255, blue / 255];
  const [redLuminance, greenLuminance, blueLuminance] = srgb.map((i) => {
    if (i <= 0.04045) {
      return i / 12.92;
    }
    return Math.pow((i + 0.055) / 1.055, 2.4);
  });

  // Calculate luminance by adding perceived luminance of each channel
  const colorLuminance =
    0.2126 * redLuminance + 0.7152 * greenLuminance + 0.0722 * blueLuminance;

  // Return black or white based on color's luminance
  return colorLuminance > 0.179 ? "#000000" : "#FFFFFF";
}

//#endregion
```

## Index Export

```typescript
// apps/v2/src/utils/index.ts

export {
  getComponents,
  toRgbValues,
  changeOpacity,
  blendColors,
  getContrastingSimpleColor,
} from "./color";

export type { IColorComponents } from "./color";
```

## Acceptance Criteria

- [ ] All functions have JSDoc with examples
- [ ] Type `IColorComponents` prefixed with `I`
- [ ] Uses `#region` comments for organization
- [ ] Exported from `utils/index.ts`
- [ ] No `any` types
- [ ] TypeScript strict mode passes
- [ ] Pure functions with no side effects

## Testing

```typescript
// apps/v2/src/utils/color.spec.ts

import {
  getComponents,
  toRgbValues,
  changeOpacity,
  blendColors,
  getContrastingSimpleColor,
} from "./color";

describe("color utilities", () => {
  //#region getComponents

  describe("getComponents", () => {
    it("parses 6-digit hex color", () => {
      const result = getComponents("#ff5500");
      expect(result).toEqual({ red: 255, green: 85, blue: 0, alpha: 1 });
    });

    it("parses 3-digit shorthand hex color", () => {
      const result = getComponents("#f50");
      expect(result).toEqual({ red: 255, green: 85, blue: 0, alpha: 1 });
    });

    it("parses hex without hash", () => {
      const result = getComponents("ff5500");
      expect(result).toEqual({ red: 255, green: 85, blue: 0, alpha: 1 });
    });

    it("parses rgb color", () => {
      const result = getComponents("rgb(255,85,0)");
      expect(result).toEqual({ red: 255, green: 85, blue: 0, alpha: 1 });
    });

    it("parses rgba color", () => {
      const result = getComponents("rgba(255,85,0,0.5)");
      expect(result).toEqual({ red: 255, green: 85, blue: 0, alpha: 0.5 });
    });
  });

  //#endregion

  //#region toRgbValues

  describe("toRgbValues", () => {
    it("converts hex to RGB string", () => {
      expect(toRgbValues("#ffffff")).toBe("255, 255, 255");
      expect(toRgbValues("#000000")).toBe("0, 0, 0");
      expect(toRgbValues("#ff5500")).toBe("255, 85, 0");
    });
  });

  //#endregion

  //#region changeOpacity

  describe("changeOpacity", () => {
    it("applies opacity to hex color", () => {
      expect(changeOpacity("#ff0000", 0.5)).toBe("rgba(255,0,0,0.5)");
    });

    it("multiplies existing alpha", () => {
      expect(changeOpacity("rgba(255,0,0,0.8)", 0.5)).toBe("rgba(255,0,0,0.4)");
    });

    it("handles full opacity", () => {
      expect(changeOpacity("#ff0000", 1)).toBe("rgba(255,0,0,1)");
    });

    it("handles zero opacity", () => {
      expect(changeOpacity("#ff0000", 0)).toBe("rgba(255,0,0,0)");
    });
  });

  //#endregion

  //#region blendColors

  describe("blendColors", () => {
    it("blends colors at 50% opacity", () => {
      const result = blendColors("#ffffff", "#000000", 0.5);
      expect(result).toBe("rgba(127,127,127,1)");
    });

    it("returns background at 0% opacity", () => {
      const result = blendColors("#ffffff", "#000000", 0);
      expect(result).toBe("rgba(255,255,255,1)");
    });

    it("returns foreground at 100% opacity", () => {
      const result = blendColors("#ffffff", "#000000", 1);
      expect(result).toBe("rgba(0,0,0,1)");
    });

    it("returns hex format when specified", () => {
      const result = blendColors("#ffffff", "#000000", 0.5, true);
      expect(result).toBe("#7f7f7f");
    });
  });

  //#endregion

  //#region getContrastingSimpleColor

  describe("getContrastingSimpleColor", () => {
    it("returns black for light colors", () => {
      expect(getContrastingSimpleColor("#ffffff")).toBe("#000000");
      expect(getContrastingSimpleColor("#ffff00")).toBe("#000000");
    });

    it("returns white for dark colors", () => {
      expect(getContrastingSimpleColor("#000000")).toBe("#FFFFFF");
      expect(getContrastingSimpleColor("#000080")).toBe("#FFFFFF");
    });

    it("handles colors without hash", () => {
      expect(getContrastingSimpleColor("ffffff")).toBe("#000000");
    });

    it("returns empty string for invalid input", () => {
      expect(getContrastingSimpleColor("#fff")).toBe("");
      expect(getContrastingSimpleColor("invalid")).toBe("");
    });
  });

  //#endregion
});
```

Run tests:

```bash
pnpm --filter @retrievly/app test:unit -- color
```
