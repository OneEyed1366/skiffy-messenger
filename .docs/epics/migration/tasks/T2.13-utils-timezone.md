# T2.13: Timezone Utilities

## Metadata

| Field        | Value           |
| ------------ | --------------- |
| **ID**       | T2.13           |
| **Layer**    | L2 - Pure Utils |
| **Status**   | pending         |
| **Priority** | medium          |
| **Estimate** | 1h              |
| **Parallel** | true            |
| **Assignee** | -               |
| **Created**  | 2026-01-07      |
| **Updated**  | 2026-01-07      |

## Dependencies

None

## Blocks

| Task ID | Name                         |
| ------- | ---------------------------- |
| T10c.\* | Timezone selector components |
| T8.\*   | Hooks using timezone data    |

## Description

Timezone utility functions migrated from Mattermost. Uses the native `Intl` API for React Native compatibility (no moment-timezone or external libraries).

## Source Files

- `vendor/desktop/webapp/channels/src/utils/timezone.ts`

## Target File

`apps/v2/src/utils/timezone.ts`

## Implementation

```typescript
// apps/v2/src/utils/timezone.ts

/**
 * Timezone utility functions
 * Migrated from: vendor/desktop/webapp/channels/src/utils/timezone.ts
 *
 * Uses native Intl API for React Native compatibility.
 */

//#region Device Timezone

/**
 * Gets the device's current timezone using the Intl API.
 *
 * @returns IANA timezone identifier (e.g., "America/New_York")
 *
 * @example
 * getBrowserTimezone() // "America/New_York" (depends on device settings)
 */
export function getBrowserTimezone(): string {
  return Intl.DateTimeFormat().resolvedOptions().timeZone;
}

//#endregion

//#region Timezone Validation

/**
 * Validates if a string is a valid IANA timezone identifier.
 *
 * @param tz - Timezone string to validate
 * @returns true if the timezone is valid
 *
 * @example
 * isValidTimezone("America/New_York") // true
 * isValidTimezone("Invalid/Timezone") // false
 * isValidTimezone("UTC")              // true
 * isValidTimezone("")                 // false
 */
export function isValidTimezone(tz: string): boolean {
  if (!tz) {
    return false;
  }

  try {
    // Intl.DateTimeFormat throws for invalid timezones
    Intl.DateTimeFormat(undefined, { timeZone: tz });
    return true;
  } catch {
    return false;
  }
}

//#endregion

//#region Timezone Information

/**
 * Gets the UTC offset in minutes for a timezone at the current time.
 * Positive values are ahead of UTC, negative values are behind.
 *
 * @param tz - IANA timezone identifier
 * @param date - Date to calculate offset for (defaults to now)
 * @returns UTC offset in minutes, or null if timezone is invalid
 *
 * @example
 * getUtcOffsetForTimezone("America/New_York") // -300 (EST) or -240 (EDT)
 * getUtcOffsetForTimezone("Europe/London")    // 0 (GMT) or 60 (BST)
 * getUtcOffsetForTimezone("Asia/Tokyo")       // 540 (JST)
 * getUtcOffsetForTimezone("Invalid/TZ")       // null
 */
export function getUtcOffsetForTimezone(
  tz: string,
  date: Date = new Date(),
): number | null {
  if (!isValidTimezone(tz)) {
    return null;
  }

  // Get the date string in the target timezone
  const formatter = new Intl.DateTimeFormat("en-US", {
    timeZone: tz,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
  });

  const parts = formatter.formatToParts(date);
  const getPart = (type: Intl.DateTimeFormatPartTypes): string =>
    parts.find((p) => p.type === type)?.value ?? "0";

  // Construct date in target timezone
  const tzYear = parseInt(getPart("year"), 10);
  const tzMonth = parseInt(getPart("month"), 10) - 1;
  const tzDay = parseInt(getPart("day"), 10);
  const tzHour = parseInt(getPart("hour"), 10);
  const tzMinute = parseInt(getPart("minute"), 10);
  const tzSecond = parseInt(getPart("second"), 10);

  // Create UTC date from timezone parts
  const tzDate = Date.UTC(tzYear, tzMonth, tzDay, tzHour, tzMinute, tzSecond);

  // Calculate offset in minutes
  const offsetMs = tzDate - date.getTime();
  return Math.round(offsetMs / 60000);
}

/**
 * Extracts the region (continent/area) from an IANA timezone identifier.
 *
 * @param tz - IANA timezone identifier
 * @returns Region part of the timezone, or empty string for UTC/special zones
 *
 * @example
 * getTimezoneRegion("America/New_York")     // "America"
 * getTimezoneRegion("Europe/London")        // "Europe"
 * getTimezoneRegion("Asia/Tokyo")           // "Asia"
 * getTimezoneRegion("Pacific/Auckland")     // "Pacific"
 * getTimezoneRegion("UTC")                  // ""
 * getTimezoneRegion("Etc/GMT+5")            // "Etc"
 */
export function getTimezoneRegion(tz: string): string {
  if (!tz || !tz.includes("/")) {
    return "";
  }

  return tz.split("/")[0];
}

//#endregion
```

## Index Export

```typescript
// apps/v2/src/utils/index.ts (append to existing exports)

export {
  getBrowserTimezone,
  isValidTimezone,
  getUtcOffsetForTimezone,
  getTimezoneRegion,
} from "./timezone";
```

## Acceptance Criteria

- [ ] `getBrowserTimezone` returns device IANA timezone
- [ ] `isValidTimezone` validates IANA timezone strings
- [ ] `getUtcOffsetForTimezone` returns correct UTC offset in minutes
- [ ] `getUtcOffsetForTimezone` returns null for invalid timezones
- [ ] `getTimezoneRegion` extracts region from timezone string
- [ ] All functions use native Intl API (no external dependencies)
- [ ] Uses `#region` comments for organization
- [ ] Exported from `utils/index.ts`
- [ ] TypeScript strict mode passes

## Testing

```typescript
// apps/v2/src/utils/timezone.spec.ts

import {
  getBrowserTimezone,
  isValidTimezone,
  getUtcOffsetForTimezone,
  getTimezoneRegion,
} from "./timezone";

describe("getBrowserTimezone", () => {
  it("returns a valid timezone string", () => {
    const tz = getBrowserTimezone();
    expect(typeof tz).toBe("string");
    expect(tz.length).toBeGreaterThan(0);
    // Should be a valid timezone
    expect(isValidTimezone(tz)).toBe(true);
  });
});

describe("isValidTimezone", () => {
  it("returns true for valid timezones", () => {
    expect(isValidTimezone("America/New_York")).toBe(true);
    expect(isValidTimezone("Europe/London")).toBe(true);
    expect(isValidTimezone("Asia/Tokyo")).toBe(true);
    expect(isValidTimezone("Pacific/Auckland")).toBe(true);
    expect(isValidTimezone("UTC")).toBe(true);
  });

  it("returns false for invalid timezones", () => {
    expect(isValidTimezone("Invalid/Timezone")).toBe(false);
    expect(isValidTimezone("Not_A_Timezone")).toBe(false);
    expect(isValidTimezone("America/FakeCity")).toBe(false);
  });

  it("returns false for empty/null values", () => {
    expect(isValidTimezone("")).toBe(false);
    expect(isValidTimezone(null as unknown as string)).toBe(false);
    expect(isValidTimezone(undefined as unknown as string)).toBe(false);
  });
});

describe("getUtcOffsetForTimezone", () => {
  it("returns correct offset for UTC", () => {
    const offset = getUtcOffsetForTimezone("UTC");
    expect(offset).toBe(0);
  });

  it("returns correct offset for fixed-offset timezones", () => {
    // Asia/Tokyo is always UTC+9 (540 minutes)
    const offset = getUtcOffsetForTimezone("Asia/Tokyo");
    expect(offset).toBe(540);
  });

  it("returns null for invalid timezone", () => {
    expect(getUtcOffsetForTimezone("Invalid/TZ")).toBeNull();
    expect(getUtcOffsetForTimezone("")).toBeNull();
  });

  it("accepts custom date parameter", () => {
    // Test with a specific date to ensure consistent results
    const winterDate = new Date("2026-01-15T12:00:00Z");
    const offset = getUtcOffsetForTimezone("America/New_York", winterDate);
    // EST is UTC-5 (-300 minutes)
    expect(offset).toBe(-300);
  });

  it("handles DST transitions correctly", () => {
    // Summer date (DST active in America/New_York)
    const summerDate = new Date("2026-07-15T12:00:00Z");
    const summerOffset = getUtcOffsetForTimezone(
      "America/New_York",
      summerDate,
    );
    // EDT is UTC-4 (-240 minutes)
    expect(summerOffset).toBe(-240);

    // Winter date (standard time)
    const winterDate = new Date("2026-01-15T12:00:00Z");
    const winterOffset = getUtcOffsetForTimezone(
      "America/New_York",
      winterDate,
    );
    // EST is UTC-5 (-300 minutes)
    expect(winterOffset).toBe(-300);
  });
});

describe("getTimezoneRegion", () => {
  it("extracts region from standard timezones", () => {
    expect(getTimezoneRegion("America/New_York")).toBe("America");
    expect(getTimezoneRegion("Europe/London")).toBe("Europe");
    expect(getTimezoneRegion("Asia/Tokyo")).toBe("Asia");
    expect(getTimezoneRegion("Pacific/Auckland")).toBe("Pacific");
    expect(getTimezoneRegion("Australia/Sydney")).toBe("Australia");
  });

  it("handles Etc timezones", () => {
    expect(getTimezoneRegion("Etc/GMT+5")).toBe("Etc");
    expect(getTimezoneRegion("Etc/UTC")).toBe("Etc");
  });

  it("returns empty string for simple timezones", () => {
    expect(getTimezoneRegion("UTC")).toBe("");
    expect(getTimezoneRegion("GMT")).toBe("");
  });

  it("returns empty string for empty/null input", () => {
    expect(getTimezoneRegion("")).toBe("");
    expect(getTimezoneRegion(null as unknown as string)).toBe("");
  });

  it("handles multi-part timezones", () => {
    expect(getTimezoneRegion("America/Indiana/Indianapolis")).toBe("America");
    expect(getTimezoneRegion("America/Argentina/Buenos_Aires")).toBe("America");
  });
});
```

Run tests:

```bash
pnpm --filter @retrievly/app test:unit -- timezone.spec
```
