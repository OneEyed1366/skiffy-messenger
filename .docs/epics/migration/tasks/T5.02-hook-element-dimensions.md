# T5.02: Element Dimensions Hook

## Metadata

| Field        | Value             |
| ------------ | ----------------- |
| **ID**       | T5.02             |
| **Layer**    | L5 - Custom Hooks |
| **Status**   | pending           |
| **Priority** | medium            |
| **Estimate** | 2h                |
| **Parallel** | true              |
| **Assignee** | -                 |
| **Created**  | 2026-01-04        |
| **Updated**  | 2026-01-04        |

## Dependencies

| Task ID | Name          |
| ------- | ------------- |
| T0.15   | types-utility |

## Blocks

| Task ID | Name                                  |
| ------- | ------------------------------------- |
| T10b.\* | Components needing dimension tracking |

## Description

Migrate `useFollowElementDimensions` hook from Mattermost. The original uses `ResizeObserver` with element ID lookup via `document.getElementById()`. In React Native, replace with `onLayout` event pattern using refs, as DOM APIs are unavailable.

## Source Files

- `vendor/desktop/webapp/platform/components/src/common/hooks/useFollowElementDimensions.ts` (lines 1-28)

### Source Analysis

The original implementation:

```typescript
// Original uses ResizeObserver via document.getElementById
export const useFollowElementDimensions = (
  elementId: string,
): DOMRectReadOnly => {
  const [dimensions, setDimensions] = useState(new DOMRect());
  useEffect(() => {
    const element = document.getElementById(elementId);
    if (!element) return undefined;
    const observer = new ResizeObserver((entries) => {
      if (entries.length > 0) {
        setDimensions(entries[0].contentRect);
      }
    });
    observer.observe(element);
    return () => observer.unobserve(element);
  }, [elementId]);
  return dimensions;
};
```

Key differences for React Native:

| Web (Original)              | React Native (Target)                              |
| --------------------------- | -------------------------------------------------- |
| `document.getElementById()` | Ref passed to component                            |
| `ResizeObserver`            | `onLayout` event                                   |
| `DOMRectReadOnly`           | `{ width, height, x, y }` from `LayoutChangeEvent` |
| Observes external element   | Component measures itself                          |

## Migration Target

- **Target File**: `apps/v2/src/hooks/useElementDimensions/useElementDimensions.ts`
- **Index Export**: `apps/v2/src/hooks/useElementDimensions/index.ts`

## Implementation

```typescript
// apps/v2/src/hooks/useElementDimensions/useElementDimensions.ts

/**
 * Hook to track element dimensions using onLayout.
 * Migrated from: vendor/desktop/webapp/platform/components/src/common/hooks/useFollowElementDimensions.ts
 *
 * Uses React Native's onLayout instead of ResizeObserver for cross-platform support.
 */

import { useCallback, useState } from "react";
import type { LayoutChangeEvent } from "react-native";

//#region Types

export type IDimensions = {
  width: number;
  height: number;
  x: number;
  y: number;
};

export type IUseElementDimensionsResult = {
  dimensions: IDimensions;
  onLayout: (event: LayoutChangeEvent) => void;
};

//#endregion Types

//#region Constants

const INITIAL_DIMENSIONS: IDimensions = {
  width: 0,
  height: 0,
  x: 0,
  y: 0,
};

//#endregion Constants

//#region Hook

/**
 * Hook to track an element's dimensions using React Native's onLayout event.
 *
 * @returns Object containing current dimensions and onLayout handler
 *
 * @example
 * function MyComponent() {
 *   const { dimensions, onLayout } = useElementDimensions();
 *
 *   return (
 *     <View onLayout={onLayout}>
 *       <Text>Width: {dimensions.width}</Text>
 *       <Text>Height: {dimensions.height}</Text>
 *     </View>
 *   );
 * }
 *
 * @example
 * // Conditionally render based on dimensions
 * function ResponsiveComponent() {
 *   const { dimensions, onLayout } = useElementDimensions();
 *   const isWide = dimensions.width > 600;
 *
 *   return (
 *     <View onLayout={onLayout} style={isWide ? styles.wide : styles.narrow}>
 *       {isWide ? <WideLayout /> : <NarrowLayout />}
 *     </View>
 *   );
 * }
 */
export function useElementDimensions(): IUseElementDimensionsResult {
  const [dimensions, setDimensions] = useState<IDimensions>(INITIAL_DIMENSIONS);

  const onLayout = useCallback((event: LayoutChangeEvent) => {
    const { width, height, x, y } = event.nativeEvent.layout;

    setDimensions((prev) => {
      // Avoid unnecessary re-renders if dimensions haven't changed
      if (
        prev.width === width &&
        prev.height === height &&
        prev.x === x &&
        prev.y === y
      ) {
        return prev;
      }

      return { width, height, x, y };
    });
  }, []);

  return { dimensions, onLayout };
}

//#endregion Hook
```

## Index Export

```typescript
// apps/v2/src/hooks/useElementDimensions/index.ts

export { useElementDimensions } from "./useElementDimensions";
export type {
  IDimensions,
  IUseElementDimensionsResult,
} from "./useElementDimensions";
```

## Platform Notes

| Platform     | Implementation               |
| ------------ | ---------------------------- |
| Web          | ResizeObserver via elementId |
| React Native | `onLayout` prop callback     |

The RN version returns `onLayout` handler instead of accepting elementId, bc RN has no DOM querying.

## Acceptance Criteria

- [ ] Uses React Native's `onLayout` event (no ResizeObserver/DOM APIs)
- [ ] Returns `{ dimensions, onLayout }` tuple for easy component integration
- [ ] Dimensions include `width`, `height`, `x`, `y`
- [ ] Avoids unnecessary re-renders when dimensions haven't changed
- [ ] All types use `I` prefix naming convention
- [ ] Exported from `hooks/useElementDimensions/index.ts`
- [ ] TypeScript strict mode passes
- [ ] No `any` types
- [ ] Works on iOS, Android, and Tauri desktop

## Testing

```typescript
// apps/v2/src/hooks/useElementDimensions/useElementDimensions.spec.tsx

import { renderHook, act } from "@testing-library/react-native";
import type { LayoutChangeEvent } from "react-native";

import { useElementDimensions } from "./useElementDimensions";

//#region Helpers

function createLayoutEvent(
  width: number,
  height: number,
  x = 0,
  y = 0,
): LayoutChangeEvent {
  return {
    nativeEvent: {
      layout: { width, height, x, y },
    },
  } as LayoutChangeEvent;
}

//#endregion Helpers

//#region Tests

describe("useElementDimensions", () => {
  it("returns initial dimensions of zero", () => {
    const { result } = renderHook(() => useElementDimensions());

    expect(result.current.dimensions).toEqual({
      width: 0,
      height: 0,
      x: 0,
      y: 0,
    });
  });

  it("returns onLayout callback", () => {
    const { result } = renderHook(() => useElementDimensions());

    expect(typeof result.current.onLayout).toBe("function");
  });

  it("updates dimensions when onLayout is called", () => {
    const { result } = renderHook(() => useElementDimensions());

    act(() => {
      result.current.onLayout(createLayoutEvent(200, 100, 10, 20));
    });

    expect(result.current.dimensions).toEqual({
      width: 200,
      height: 100,
      x: 10,
      y: 20,
    });
  });

  it("updates dimensions on subsequent layout changes", () => {
    const { result } = renderHook(() => useElementDimensions());

    act(() => {
      result.current.onLayout(createLayoutEvent(100, 50));
    });

    expect(result.current.dimensions.width).toBe(100);
    expect(result.current.dimensions.height).toBe(50);

    act(() => {
      result.current.onLayout(createLayoutEvent(300, 150));
    });

    expect(result.current.dimensions.width).toBe(300);
    expect(result.current.dimensions.height).toBe(150);
  });

  it("maintains stable onLayout reference across renders", () => {
    const { result, rerender } = renderHook(() => useElementDimensions());

    const firstOnLayout = result.current.onLayout;

    rerender({});

    expect(result.current.onLayout).toBe(firstOnLayout);
  });

  it("does not trigger re-render when dimensions are unchanged", () => {
    const { result } = renderHook(() => useElementDimensions());

    act(() => {
      result.current.onLayout(createLayoutEvent(100, 50, 0, 0));
    });

    const dimensionsRef = result.current.dimensions;

    act(() => {
      // Call with same dimensions
      result.current.onLayout(createLayoutEvent(100, 50, 0, 0));
    });

    // Should be the same object reference (no re-render)
    expect(result.current.dimensions).toBe(dimensionsRef);
  });

  it("triggers re-render when only x changes", () => {
    const { result } = renderHook(() => useElementDimensions());

    act(() => {
      result.current.onLayout(createLayoutEvent(100, 50, 0, 0));
    });

    const dimensionsRef = result.current.dimensions;

    act(() => {
      result.current.onLayout(createLayoutEvent(100, 50, 10, 0));
    });

    expect(result.current.dimensions).not.toBe(dimensionsRef);
    expect(result.current.dimensions.x).toBe(10);
  });

  it("triggers re-render when only y changes", () => {
    const { result } = renderHook(() => useElementDimensions());

    act(() => {
      result.current.onLayout(createLayoutEvent(100, 50, 0, 0));
    });

    const dimensionsRef = result.current.dimensions;

    act(() => {
      result.current.onLayout(createLayoutEvent(100, 50, 0, 20));
    });

    expect(result.current.dimensions).not.toBe(dimensionsRef);
    expect(result.current.dimensions.y).toBe(20);
  });
});

//#endregion Tests
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- useElementDimensions
```

## Usage Examples

### Basic Usage

```typescript
import { View, Text } from "react-native";
import { useElementDimensions } from "@/hooks/useElementDimensions";

function DimensionDisplay() {
  const { dimensions, onLayout } = useElementDimensions();

  return (
    <View onLayout={onLayout} style={styles.container}>
      <Text>Width: {dimensions.width}px</Text>
      <Text>Height: {dimensions.height}px</Text>
    </View>
  );
}
```

### Responsive Layout

```typescript
import { View } from "react-native";
import { useElementDimensions } from "@/hooks/useElementDimensions";

function ResponsiveGrid() {
  const { dimensions, onLayout } = useElementDimensions();
  const columns = dimensions.width > 600 ? 3 : dimensions.width > 400 ? 2 : 1;

  return (
    <View onLayout={onLayout} style={styles.grid}>
      {items.map((item) => (
        <GridItem key={item.id} columns={columns} />
      ))}
    </View>
  );
}
```

### Conditional Rendering

```typescript
import { View } from "react-native";
import { useElementDimensions } from "@/hooks/useElementDimensions";

function AdaptiveComponent() {
  const { dimensions, onLayout } = useElementDimensions();

  // Don't render content until we have dimensions
  const hasLayout = dimensions.width > 0;

  return (
    <View onLayout={onLayout} style={styles.container}>
      {hasLayout && (
        <ContentBasedOnSize width={dimensions.width} />
      )}
    </View>
  );
}
```

## Notes

- Unlike the web version which uses `elementId` to find elements via DOM, this React Native version uses the `onLayout` prop pattern
- The `onLayout` callback is memoized with `useCallback` to prevent unnecessary re-renders
- Dimension comparison prevents state updates when values haven't changed
- Initial dimensions are `{ width: 0, height: 0, x: 0, y: 0 }` until first layout event fires
- For components that need dimensions before first render, consider using `Dimensions.get('window')` as initial values
