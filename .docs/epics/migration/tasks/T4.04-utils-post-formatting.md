# T4.04: Post Formatting Utilities

## Metadata

| Field        | Value                 |
| ------------ | --------------------- |
| **ID**       | T4.04                 |
| **Layer**    | L4 - Formatting Utils |
| **Status**   | pending               |
| **Priority** | high                  |
| **Estimate** | 3h                    |
| **Parallel** | true                  |
| **Assignee** | -                     |
| **Created**  | 2026-01-04            |
| **Updated**  | 2026-01-04            |

## Dependencies

| Task ID | Name            |
| ------- | --------------- |
| T4.02   | Text Formatting |
| T4.03   | Markdown Utils  |
| T4.07   | File Size Utils |
| T0.03   | Post types      |
| T0.05   | File types      |

## Blocks

| Task ID | Name                       |
| ------- | -------------------------- |
| T10b.\* | Post components            |
| T10c.\* | Message display components |
| T8.\*   | Post-related hooks         |

## Description

Migrate post-specific formatting utilities from Mattermost. These utilities handle post type detection, message preview generation, attachment formatting, and system message identification.

## Source Files

- `vendor/desktop/webapp/channels/src/utils/post_utils.ts` (lines 54-80, 639-657)
- `vendor/desktop/webapp/channels/src/utils/utils.tsx` (lines 1105-1127)
- `vendor/desktop/webapp/channels/src/packages/mattermost-redux/src/constants/posts.ts`

### Source Analysis

Key functions identified:

1. **isSystemMessage** (line 54-56): Checks if post type starts with `system_` prefix
2. **fromAutoResponder** (line 58-60): Checks if post is auto-responder type
3. **isFromWebhook** (line 62-64): Checks props.from_webhook
4. **isFromBot** (line 66-68): Checks props.from_bot
5. **isComment** (line 74-79): Checks if post has root_id (is a reply)
6. **isEdited** (line 81-83): Checks if edit_at > 0
7. **areConsecutivePostsBySameUser** (line 639-657): Checks if posts can be grouped
8. **fileSizeToString** (utils.tsx 1105-1127): Formats bytes to human-readable

Constants used:

- `SYSTEM_MESSAGE_PREFIX = 'system_'`
- `POST_COLLAPSE_TIMEOUT = 1000 * 60 * 5` (5 minutes)
- Post types enum for system messages

## Target File

`apps/v2/src/utils/post-formatting/post-formatting.ts`

## Implementation

```typescript
// apps/v2/src/utils/post-formatting/post-formatting.ts

/**
 * Post-specific formatting utilities
 * Migrated from: vendor/desktop/webapp/channels/src/utils/post_utils.ts
 */

import type { IPost, IPostType } from "@/types";

//#region Constants

/** Prefix for all system message types */
export const SYSTEM_MESSAGE_PREFIX = "system_";

/** Auto-responder post type */
export const AUTO_RESPONDER_TYPE = "system_auto_responder";

/** Time window for collapsing consecutive posts (5 minutes) */
export const POST_COLLAPSE_TIMEOUT_MS = 1000 * 60 * 5;

/** Post types that represent system messages */
export const SYSTEM_POST_TYPES = {
  CHANNEL_DELETED: "system_channel_deleted",
  CHANNEL_UNARCHIVED: "system_channel_restored",
  DISPLAYNAME_CHANGE: "system_displayname_change",
  CONVERT_CHANNEL: "system_convert_channel",
  EPHEMERAL: "system_ephemeral",
  EPHEMERAL_ADD_TO_CHANNEL: "system_ephemeral_add_to_channel",
  HEADER_CHANGE: "system_header_change",
  PURPOSE_CHANGE: "system_purpose_change",
  JOIN_LEAVE: "system_join_leave",
  JOIN_CHANNEL: "system_join_channel",
  GUEST_JOIN_CHANNEL: "system_guest_join_channel",
  LEAVE_CHANNEL: "system_leave_channel",
  JOIN_LEAVE_CHANNEL: "system_join_leave_channel",
  ADD_REMOVE: "system_add_remove",
  ADD_TO_CHANNEL: "system_add_to_channel",
  ADD_GUEST_TO_CHANNEL: "system_add_guest_to_chan",
  REMOVE_FROM_CHANNEL: "system_remove_from_channel",
  JOIN_TEAM: "system_join_team",
  LEAVE_TEAM: "system_leave_team",
  ADD_TO_TEAM: "system_add_to_team",
  REMOVE_FROM_TEAM: "system_remove_from_team",
  COMBINED_USER_ACTIVITY: "system_combined_user_activity",
  WRANGLER: "system_wrangler",
  GM_CONVERTED_TO_CHANNEL: "system_gm_to_channel",
} as const;

/** Non-system special post types */
export const SPECIAL_POST_TYPES = {
  ME: "me",
  REMINDER: "reminder",
  BURN_ON_READ: "burn_on_read",
  ADD_BOT_TEAMS_CHANNELS: "add_bot_teams_channels",
} as const;

//#endregion

//#region Post Type Detection

/**
 * Check if a post is a system message
 * System messages have types that start with 'system_'
 *
 * @param post - The post to check
 * @returns True if the post is a system message
 *
 * @example
 * isSystemMessage({ type: 'system_join_channel' }) // true
 * isSystemMessage({ type: '' }) // false
 */
export function isSystemMessage(post: Pick<IPost, "type">): boolean {
  return Boolean(
    post.type && post.type.lastIndexOf(SYSTEM_MESSAGE_PREFIX) === 0,
  );
}

/**
 * Check if a post is from an auto-responder
 *
 * @param post - The post to check
 * @returns True if the post is an auto-responder message
 */
export function isAutoResponderMessage(post: Pick<IPost, "type">): boolean {
  return post.type === AUTO_RESPONDER_TYPE;
}

/**
 * Check if a post is from a webhook
 *
 * @param post - The post to check
 * @returns True if the post originated from a webhook
 */
export function isFromWebhook(post: Pick<IPost, "props">): boolean {
  return post.props?.from_webhook === "true";
}

/**
 * Check if a post is from a bot
 *
 * @param post - The post to check
 * @returns True if the post originated from a bot
 */
export function isFromBot(post: Pick<IPost, "props">): boolean {
  return post.props?.from_bot === "true";
}

/**
 * Check if a post is a reply/comment (has a root_id)
 *
 * @param post - The post to check
 * @returns True if the post is a reply to another post
 *
 * @example
 * isComment({ root_id: 'abc123' }) // true
 * isComment({ root_id: '' }) // false
 */
export function isComment(post: Pick<IPost, "root_id">): boolean {
  return Boolean(post.root_id && post.root_id !== "");
}

/**
 * Check if a post has been edited
 *
 * @param post - The post to check
 * @returns True if the post was edited after creation
 */
export function isEdited(post: Pick<IPost, "edit_at">): boolean {
  return post.edit_at > 0;
}

/**
 * Check if a post is a "me" command message
 *
 * @param post - The post to check
 * @returns True if the post is a /me command
 */
export function isMeMessage(post: Pick<IPost, "type">): boolean {
  return post.type === SPECIAL_POST_TYPES.ME;
}

/**
 * Check if a post is a burn-on-read message
 *
 * @param post - The post to check
 * @returns True if the post is a burn-on-read message
 */
export function isBurnOnReadMessage(post: Pick<IPost, "type">): boolean {
  return post.type === SPECIAL_POST_TYPES.BURN_ON_READ;
}

/**
 * Get the post type category for display purposes
 *
 * @param post - The post to categorize
 * @returns The category of the post type
 */
export function getPostTypeCategory(
  post: Pick<IPost, "type" | "props">,
): "system" | "webhook" | "bot" | "user" {
  if (isSystemMessage(post)) {
    return "system";
  }
  if (isFromWebhook(post as Pick<IPost, "props">)) {
    return "webhook";
  }
  if (isFromBot(post as Pick<IPost, "props">)) {
    return "bot";
  }
  return "user";
}

//#endregion

//#region Post Preview

/** Default maximum length for post previews */
const DEFAULT_PREVIEW_LENGTH = 100;

/**
 * Generate a truncated preview of a post message
 * Useful for notifications and message lists
 *
 * @param message - The full post message
 * @param maxLength - Maximum length of the preview (default: 100)
 * @returns Truncated message with ellipsis if needed
 *
 * @example
 * getPostPreview('Hello world', 5) // 'Hello...'
 * getPostPreview('Hi', 100) // 'Hi'
 */
export function getPostPreview(
  message: string,
  maxLength: number = DEFAULT_PREVIEW_LENGTH,
): string {
  if (!message) {
    return "";
  }

  // Remove newlines and extra whitespace
  const cleanMessage = message.replace(/\s+/g, " ").trim();

  if (cleanMessage.length <= maxLength) {
    return cleanMessage;
  }

  // Try to break at a word boundary
  const truncated = cleanMessage.slice(0, maxLength);
  const lastSpace = truncated.lastIndexOf(" ");

  if (lastSpace > maxLength * 0.7) {
    return truncated.slice(0, lastSpace) + "...";
  }

  return truncated + "...";
}

// NOTE: stripMarkdown is imported from @/utils/markdown (T4.03)
// which uses the `marked` lexer for accurate markdown parsing.
// Re-export for convenience in post-related code:
export { stripMarkdown as stripMarkdownForPreview } from "@/utils/markdown";

//#endregion

//#region Consecutive Posts

/**
 * Options for checking consecutive posts
 */
export type IConsecutivePostOptions = {
  /** Time window for collapsing posts in milliseconds */
  collapseTimeout?: number;
};

/**
 * Check if two posts are consecutive and can be visually grouped
 * Posts are grouped if:
 * - Same user
 * - Within 5 minute window
 * - Not from webhook
 * - Not system messages
 * - Same AI-generated status
 * - Not burn-on-read
 *
 * @param post - The current post
 * @param previousPost - The previous post to compare against
 * @param options - Configuration options
 * @returns True if posts can be grouped together
 */
export function areConsecutivePostsBySameUser(
  post: Pick<IPost, "user_id" | "create_at" | "props" | "type">,
  previousPost: Pick<IPost, "user_id" | "create_at" | "props" | "type">,
  options: IConsecutivePostOptions = {},
): boolean {
  const { collapseTimeout = POST_COLLAPSE_TIMEOUT_MS } = options;

  if (!post || !previousPost) {
    return false;
  }

  const sameUser = post.user_id === previousPost.user_id;
  const withinTimeWindow =
    post.create_at - previousPost.create_at <= collapseTimeout;
  const notFromWebhook =
    !isFromWebhook(post as Pick<IPost, "props">) &&
    !isFromWebhook(previousPost as Pick<IPost, "props">);
  const notSystemMessage =
    !isSystemMessage(post as Pick<IPost, "type">) &&
    !isSystemMessage(previousPost as Pick<IPost, "type">);
  const sameAiGeneratedStatus =
    post.props?.ai_generated_by === previousPost.props?.ai_generated_by;
  const notBurnOnRead =
    !isBurnOnReadMessage(post as Pick<IPost, "type">) &&
    !isBurnOnReadMessage(previousPost as Pick<IPost, "type">);

  return (
    sameUser &&
    withinTimeWindow &&
    notFromWebhook &&
    notSystemMessage &&
    sameAiGeneratedStatus &&
    notBurnOnRead
  );
}

//#endregion

//#region Attachment Size Formatting

// NOTE: formatFileSize is imported from @/utils/file-size (T4.07)
// which is the canonical location for file size formatting.
// Re-export for convenience in post-related code:
export { formatFileSize as formatAttachmentSize } from "@/utils/file-size";

//#endregion

//#region AI-Generated Metadata

/**
 * Check if a post has valid AI-generated metadata
 *
 * @param post - The post to check
 * @returns True if the post has valid AI-generated metadata
 */
export function hasAiGeneratedMetadata(post: Pick<IPost, "props">): boolean {
  return (
    Boolean(
      post.props?.ai_generated_by && post.props?.ai_generated_by_username,
    ) &&
    typeof post.props.ai_generated_by === "string" &&
    typeof post.props.ai_generated_by_username === "string"
  );
}

//#endregion
```

## Index Export

```typescript
// apps/v2/src/utils/post-formatting/index.ts

export {
  // Constants
  SYSTEM_MESSAGE_PREFIX,
  AUTO_RESPONDER_TYPE,
  POST_COLLAPSE_TIMEOUT_MS,
  SYSTEM_POST_TYPES,
  SPECIAL_POST_TYPES,
  // Post type detection
  isSystemMessage,
  isAutoResponderMessage,
  isFromWebhook,
  isFromBot,
  isComment,
  isEdited,
  isMeMessage,
  isBurnOnReadMessage,
  getPostTypeCategory,
  // Post preview
  getPostPreview,
  stripMarkdownForPreview, // Re-exported from @/utils/markdown
  // Consecutive posts
  areConsecutivePostsBySameUser,
  // Attachment formatting (re-exported from @/utils/file-size)
  formatAttachmentSize,
  // AI metadata
  hasAiGeneratedMetadata,
} from "./post-formatting";

export type { IConsecutivePostOptions } from "./post-formatting";
```

## Acceptance Criteria

- [ ] All functions exported and typed
- [ ] Types prefixed with `I`
- [ ] No Redux dependencies (pure functions)
- [ ] Pure functions only (no side effects)
- [ ] Unit tests pass
- [ ] JSDoc comments included
- [ ] Constants use `as const` for type safety

## Testing

````typescript
// apps/v2/src/utils/post-formatting/post-formatting.spec.ts

import {
  isSystemMessage,
  isAutoResponderMessage,
  isFromWebhook,
  isFromBot,
  isComment,
  isEdited,
  isMeMessage,
  isBurnOnReadMessage,
  getPostTypeCategory,
  getPostPreview,
  stripMarkdownForPreview,
  areConsecutivePostsBySameUser,
  formatAttachmentSize,
  hasAiGeneratedMetadata,
  SYSTEM_MESSAGE_PREFIX,
  POST_COLLAPSE_TIMEOUT_MS,
} from "./post-formatting";

//#region Post Type Detection

describe("isSystemMessage", () => {
  it("returns true for system message types", () => {
    expect(isSystemMessage({ type: "system_join_channel" })).toBe(true);
    expect(isSystemMessage({ type: "system_leave_channel" })).toBe(true);
    expect(isSystemMessage({ type: "system_header_change" })).toBe(true);
  });

  it("returns false for non-system message types", () => {
    expect(isSystemMessage({ type: "" })).toBe(false);
    expect(isSystemMessage({ type: "me" })).toBe(false);
    expect(isSystemMessage({ type: "burn_on_read" })).toBe(false);
  });
});

describe("isAutoResponderMessage", () => {
  it("returns true for auto-responder type", () => {
    expect(isAutoResponderMessage({ type: "system_auto_responder" })).toBe(
      true,
    );
  });

  it("returns false for other types", () => {
    expect(isAutoResponderMessage({ type: "" })).toBe(false);
    expect(isAutoResponderMessage({ type: "system_join_channel" })).toBe(false);
  });
});

describe("isFromWebhook", () => {
  it("returns true when from_webhook is 'true'", () => {
    expect(isFromWebhook({ props: { from_webhook: "true" } })).toBe(true);
  });

  it("returns false when from_webhook is not 'true'", () => {
    expect(isFromWebhook({ props: { from_webhook: "false" } })).toBe(false);
    expect(isFromWebhook({ props: {} })).toBe(false);
    expect(isFromWebhook({ props: undefined })).toBe(false);
  });
});

describe("isFromBot", () => {
  it("returns true when from_bot is 'true'", () => {
    expect(isFromBot({ props: { from_bot: "true" } })).toBe(true);
  });

  it("returns false when from_bot is not 'true'", () => {
    expect(isFromBot({ props: { from_bot: "false" } })).toBe(false);
    expect(isFromBot({ props: {} })).toBe(false);
  });
});

describe("isComment", () => {
  it("returns true when root_id is set", () => {
    expect(isComment({ root_id: "abc123" })).toBe(true);
  });

  it("returns false when root_id is empty or missing", () => {
    expect(isComment({ root_id: "" })).toBe(false);
    expect(isComment({ root_id: undefined as unknown as string })).toBe(false);
  });
});

describe("isEdited", () => {
  it("returns true when edit_at is greater than 0", () => {
    expect(isEdited({ edit_at: 1234567890 })).toBe(true);
  });

  it("returns false when edit_at is 0 or negative", () => {
    expect(isEdited({ edit_at: 0 })).toBe(false);
    expect(isEdited({ edit_at: -1 })).toBe(false);
  });
});

describe("isMeMessage", () => {
  it("returns true for 'me' type", () => {
    expect(isMeMessage({ type: "me" })).toBe(true);
  });

  it("returns false for other types", () => {
    expect(isMeMessage({ type: "" })).toBe(false);
    expect(isMeMessage({ type: "system_join_channel" })).toBe(false);
  });
});

describe("isBurnOnReadMessage", () => {
  it("returns true for burn_on_read type", () => {
    expect(isBurnOnReadMessage({ type: "burn_on_read" })).toBe(true);
  });

  it("returns false for other types", () => {
    expect(isBurnOnReadMessage({ type: "" })).toBe(false);
    expect(isBurnOnReadMessage({ type: "me" })).toBe(false);
  });
});

describe("getPostTypeCategory", () => {
  it("returns 'system' for system messages", () => {
    expect(
      getPostTypeCategory({ type: "system_join_channel", props: {} }),
    ).toBe("system");
  });

  it("returns 'webhook' for webhook messages", () => {
    expect(
      getPostTypeCategory({ type: "", props: { from_webhook: "true" } }),
    ).toBe("webhook");
  });

  it("returns 'bot' for bot messages", () => {
    expect(getPostTypeCategory({ type: "", props: { from_bot: "true" } })).toBe(
      "bot",
    );
  });

  it("returns 'user' for regular messages", () => {
    expect(getPostTypeCategory({ type: "", props: {} })).toBe("user");
  });
});

//#endregion

//#region Post Preview

describe("getPostPreview", () => {
  it("returns empty string for empty message", () => {
    expect(getPostPreview("")).toBe("");
    expect(getPostPreview(null as unknown as string)).toBe("");
  });

  it("returns full message if under max length", () => {
    expect(getPostPreview("Hello world", 100)).toBe("Hello world");
  });

  it("truncates long messages with ellipsis", () => {
    const longMessage =
      "This is a very long message that exceeds the maximum length";
    const preview = getPostPreview(longMessage, 20);
    expect(preview.length).toBeLessThanOrEqual(23); // 20 + '...'
    expect(preview.endsWith("...")).toBe(true);
  });

  it("tries to break at word boundaries", () => {
    const message = "Hello wonderful world";
    const preview = getPostPreview(message, 15);
    expect(preview).toBe("Hello wonderful...");
  });

  it("collapses whitespace", () => {
    const message = "Hello\n\nworld   with   spaces";
    const preview = getPostPreview(message, 100);
    expect(preview).toBe("Hello world with spaces");
  });
});

describe("stripMarkdownForPreview", () => {
  it("returns empty string for empty message", () => {
    expect(stripMarkdownForPreview("")).toBe("");
  });

  it("removes bold formatting", () => {
    expect(stripMarkdownForPreview("**bold** text")).toBe("bold text");
  });

  it("removes italic formatting", () => {
    expect(stripMarkdownForPreview("*italic* text")).toBe("italic text");
    expect(stripMarkdownForPreview("_italic_ text")).toBe("italic text");
  });

  it("removes code blocks", () => {
    expect(stripMarkdownForPreview("```\ncode\n```")).toBe("[code]");
  });

  it("removes inline code", () => {
    expect(stripMarkdownForPreview("some `code` here")).toBe(
      "some [code] here",
    );
  });

  it("removes links but keeps text", () => {
    expect(stripMarkdownForPreview("[link text](http://example.com)")).toBe(
      "link text",
    );
  });

  it("replaces images with placeholder", () => {
    expect(stripMarkdownForPreview("![alt](http://example.com/img.png)")).toBe(
      "[image]",
    );
  });
});

//#endregion

//#region Consecutive Posts

describe("areConsecutivePostsBySameUser", () => {
  const basePost = {
    user_id: "user1",
    create_at: 1000000,
    props: {},
    type: "" as const,
  };

  it("returns true for same user within time window", () => {
    const post = { ...basePost, create_at: 1000000 + 60000 }; // 1 minute later
    expect(areConsecutivePostsBySameUser(post, basePost)).toBe(true);
  });

  it("returns false for different users", () => {
    const post = { ...basePost, user_id: "user2" };
    expect(areConsecutivePostsBySameUser(post, basePost)).toBe(false);
  });

  it("returns false outside time window", () => {
    const post = {
      ...basePost,
      create_at: 1000000 + POST_COLLAPSE_TIMEOUT_MS + 1,
    };
    expect(areConsecutivePostsBySameUser(post, basePost)).toBe(false);
  });

  it("returns false for webhook posts", () => {
    const post = { ...basePost, props: { from_webhook: "true" } };
    expect(areConsecutivePostsBySameUser(post, basePost)).toBe(false);
  });

  it("returns false for system messages", () => {
    const post = { ...basePost, type: "system_join_channel" as const };
    expect(areConsecutivePostsBySameUser(post, basePost)).toBe(false);
  });

  it("returns false for burn-on-read messages", () => {
    const post = { ...basePost, type: "burn_on_read" as const };
    expect(areConsecutivePostsBySameUser(post, basePost)).toBe(false);
  });

  it("returns false for different AI-generated status", () => {
    const post = { ...basePost, props: { ai_generated_by: "bot1" } };
    expect(areConsecutivePostsBySameUser(post, basePost)).toBe(false);
  });

  it("returns false for null posts", () => {
    expect(
      areConsecutivePostsBySameUser(
        null as unknown as typeof basePost,
        basePost,
      ),
    ).toBe(false);
    expect(
      areConsecutivePostsBySameUser(
        basePost,
        null as unknown as typeof basePost,
      ),
    ).toBe(false);
  });
});

//#endregion

//#region Attachment Size Formatting

describe("formatAttachmentSize", () => {
  it("formats bytes", () => {
    expect(formatAttachmentSize(500)).toBe("500B");
    expect(formatAttachmentSize(0)).toBe("0B");
  });

  it("formats kilobytes", () => {
    expect(formatAttachmentSize(1024)).toBe("1KB");
    expect(formatAttachmentSize(1536)).toBe("2KB");
  });

  it("formats megabytes", () => {
    expect(formatAttachmentSize(1048576)).toBe("1MB");
    expect(formatAttachmentSize(5242880)).toBe("5MB");
  });

  it("formats gigabytes", () => {
    expect(formatAttachmentSize(1073741824)).toBe("1GB");
  });

  it("formats terabytes", () => {
    expect(formatAttachmentSize(1099511627776)).toBe("1TB");
  });

  it("shows decimal for small values", () => {
    expect(formatAttachmentSize(1572864)).toBe("1.5MB"); // 1.5 MB
    expect(formatAttachmentSize(1610612736)).toBe("1.5GB"); // 1.5 GB
  });
});

//#endregion

//#region AI Metadata

describe("hasAiGeneratedMetadata", () => {
  it("returns true for valid AI metadata", () => {
    expect(
      hasAiGeneratedMetadata({
        props: {
          ai_generated_by: "bot-id",
          ai_generated_by_username: "AI Bot",
        },
      }),
    ).toBe(true);
  });

  it("returns false for missing metadata", () => {
    expect(hasAiGeneratedMetadata({ props: {} })).toBe(false);
    expect(hasAiGeneratedMetadata({ props: { ai_generated_by: "bot" } })).toBe(
      false,
    );
    expect(
      hasAiGeneratedMetadata({ props: { ai_generated_by_username: "Bot" } }),
    ).toBe(false);
  });

  it("returns false for non-string metadata", () => {
    expect(
      hasAiGeneratedMetadata({
        props: {
          ai_generated_by: 123,
          ai_generated_by_username: "Bot",
        },
      }),
    ).toBe(false);
  });
});

//#endregion
````

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- post-formatting
```

## Consolidation Notes

### Removed Duplications

The following functions are **NOT defined** in this file. They are imported from their canonical locations and re-exported for convenience:

| Function                  | Canonical Location          | Reason                                          |
| ------------------------- | --------------------------- | ----------------------------------------------- |
| `stripMarkdownForPreview` | `@/utils/markdown` (T4.03)  | Uses `marked` lexer for accurate parsing        |
| `formatAttachmentSize`    | `@/utils/file-size` (T4.07) | Single source of truth for file size formatting |

```typescript
// DO NOT redefine - import from canonical locations:
export { stripMarkdown as stripMarkdownForPreview } from "@/utils/markdown";
export { formatFileSize as formatAttachmentSize } from "@/utils/file-size";
```

This avoids:

- Duplicate implementations with different behaviors
- Inconsistent formatting across the codebase
- Maintenance burden of keeping multiple implementations in sync
