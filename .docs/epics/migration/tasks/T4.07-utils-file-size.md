# T4.07: File Size Formatting Utilities

## Metadata

| Field        | Value                 |
| ------------ | --------------------- |
| **ID**       | T4.07                 |
| **Layer**    | L4 - Formatting Utils |
| **Status**   | pending               |
| **Priority** | medium                |
| **Estimate** | 1h                    |
| **Parallel** | true                  |
| **Assignee** | -                     |
| **Created**  | 2026-01-04            |
| **Updated**  | 2026-01-04            |

## Dependencies

None

## Blocks

| Task ID | Name                    |
| ------- | ----------------------- |
| T10b.\* | Attachment components   |
| T10.\*  | File upload/download UI |

## Description

Migrate file size formatting utilities from Mattermost. The original `fileSizeToString` converts bytes to human-readable strings (KB, MB, GB, TB). This migration adds locale-aware number formatting and a reverse `parseFileSize` function for completeness.

## Source Files

- `vendor/desktop/webapp/channels/src/utils/utils.tsx` (lines 1104-1127)
- `vendor/desktop/webapp/channels/src/utils/file_utils.tsx` (lines 11-17) - FileSizes constants

### Original Implementation

```typescript
// utils.tsx - fileSizeToString
export function fileSizeToString(bytes: number) {
  // it's unlikely that we'll have files bigger than this
  if (bytes > 1024 ** 4) {
    // check if file is smaller than 10 to display fractions
    if (bytes < 1024 ** 4 * 10) {
      return Math.round((bytes / 1024 ** 4) * 10) / 10 + "TB";
    }
    return Math.round(bytes / 1024 ** 4) + "TB";
  } else if (bytes > 1024 ** 3) {
    if (bytes < 1024 ** 3 * 10) {
      return Math.round((bytes / 1024 ** 3) * 10) / 10 + "GB";
    }
    return Math.round(bytes / 1024 ** 3) + "GB";
  } else if (bytes > 1024 ** 2) {
    if (bytes < 1024 ** 2 * 10) {
      return Math.round((bytes / 1024 ** 2) * 10) / 10 + "MB";
    }
    return Math.round(bytes / 1024 ** 2) + "MB";
  } else if (bytes > 1024) {
    return Math.round(bytes / 1024) + "KB";
  }
  return bytes + "B";
}

// file_utils.tsx - FileSizes constants
export const FileSizes = {
  Bit: 1,
  Byte: 1 * 8,
  Kilobyte: 1 * 8 * 1024,
  Megabyte: 1 * 8 * 1024 * 1024,
  Gigabyte: 1 * 8 * 1024 * 1024 * 1024,
};
```

## Target File

`apps/v2/src/utils/file-size/file-size.ts`

## Implementation

```typescript
// apps/v2/src/utils/file-size/file-size.ts

//#region Types

type IFileSizeUnit = "B" | "KB" | "MB" | "GB" | "TB";

type IFormatFileSizeOptions = {
  /** Locale for number formatting (default: 'en-US') */
  locale?: string;
  /** Maximum fraction digits for values < 10 (default: 1) */
  maximumFractionDigits?: number;
};

//#endregion Types

//#region Constants

const FILE_SIZE_UNITS: readonly IFileSizeUnit[] = [
  "B",
  "KB",
  "MB",
  "GB",
  "TB",
] as const;

const BYTES_PER_UNIT: Record<IFileSizeUnit, number> = {
  B: 1,
  KB: 1024,
  MB: 1024 ** 2,
  GB: 1024 ** 3,
  TB: 1024 ** 4,
} as const;

//#endregion Constants

//#region formatFileSize

/**
 * Converts a file size in bytes into a human-readable string.
 * Uses binary units (1 KB = 1024 bytes).
 *
 * @param bytes - The file size in bytes
 * @param options - Formatting options
 * @returns A formatted string like "1.5 MB" or "256 KB"
 *
 * @example
 * formatFileSize(1536); // "1.5 KB"
 * formatFileSize(1048576); // "1 MB"
 * formatFileSize(1572864); // "1.5 MB"
 * formatFileSize(10485760); // "10 MB"
 * formatFileSize(1536, { locale: 'de-DE' }); // "1,5 KB"
 */
export function formatFileSize(
  bytes: number,
  options: IFormatFileSizeOptions = {},
): string {
  const { locale = "en-US", maximumFractionDigits = 1 } = options;

  if (bytes < 0) {
    return formatFileSize(0, options);
  }

  // Find appropriate unit (iterate from largest to smallest)
  for (let i = FILE_SIZE_UNITS.length - 1; i >= 0; i--) {
    const unit = FILE_SIZE_UNITS[i];
    const unitBytes = BYTES_PER_UNIT[unit];

    if (bytes >= unitBytes || unit === "B") {
      const value = bytes / unitBytes;

      // Use fraction digits only for values < 10, otherwise round to integer
      const formattedValue =
        value < 10 && unit !== "B"
          ? value.toLocaleString(locale, {
              minimumFractionDigits: 0,
              maximumFractionDigits,
            })
          : Math.round(value).toLocaleString(locale);

      return `${formattedValue} ${unit}`;
    }
  }

  // Fallback (should never reach here)
  return `${bytes} B`;
}

//#endregion formatFileSize

//#region parseFileSize

/**
 * Parses a human-readable file size string back to bytes.
 * Handles various formats and is case-insensitive.
 *
 * @param sizeString - A string like "1.5 MB", "256KB", "1,5 GB" (European format)
 * @returns The size in bytes, or null if parsing fails
 *
 * @example
 * parseFileSize("1.5 MB"); // 1572864
 * parseFileSize("256 KB"); // 262144
 * parseFileSize("1,5 GB"); // 1610612736 (European decimal separator)
 * parseFileSize("invalid"); // null
 */
export function parseFileSize(sizeString: string): number | null {
  if (!sizeString || typeof sizeString !== "string") {
    return null;
  }

  // Normalize: trim, uppercase, handle European decimal separator
  const normalized = sizeString.trim().toUpperCase().replace(",", ".");

  // Match number (with optional decimal) followed by optional space and unit
  const match = normalized.match(/^([\d.]+)\s*(B|KB|MB|GB|TB)?$/);

  if (!match) {
    return null;
  }

  const value = parseFloat(match[1]);
  const unit = (match[2] || "B") as IFileSizeUnit;

  if (isNaN(value) || value < 0) {
    return null;
  }

  const multiplier = BYTES_PER_UNIT[unit];

  if (multiplier === undefined) {
    return null;
  }

  return Math.round(value * multiplier);
}

//#endregion parseFileSize

//#region Exports

export { BYTES_PER_UNIT, FILE_SIZE_UNITS };
export type { IFileSizeUnit, IFormatFileSizeOptions };

//#endregion Exports
```

## Index Export

```typescript
// apps/v2/src/utils/file-size/index.ts
export {
  formatFileSize,
  parseFileSize,
  BYTES_PER_UNIT,
  FILE_SIZE_UNITS,
} from "./file-size";
export type { IFileSizeUnit, IFormatFileSizeOptions } from "./file-size";
```

```typescript
// apps/v2/src/utils/index.ts (add to existing exports)
export {
  formatFileSize,
  parseFileSize,
  BYTES_PER_UNIT,
  FILE_SIZE_UNITS,
} from "./file-size";
export type { IFileSizeUnit, IFormatFileSizeOptions } from "./file-size";
```

## Acceptance Criteria

- [ ] `formatFileSize(bytes)` returns human-readable string with space before unit
- [ ] Supports B, KB, MB, GB, TB units (binary: 1024-based)
- [ ] Values < 10 show one decimal place, â‰¥ 10 show integers
- [ ] Locale-aware number formatting via options
- [ ] `parseFileSize(string)` returns bytes or null
- [ ] Handles European decimal separator (comma)
- [ ] Case-insensitive unit parsing
- [ ] Exported from `utils/index.ts`
- [ ] TypeScript strict mode passes
- [ ] No `any` types

## Testing

```typescript
// apps/v2/src/utils/file-size/file-size.spec.ts

import {
  formatFileSize,
  parseFileSize,
  BYTES_PER_UNIT,
  FILE_SIZE_UNITS,
} from "./file-size";

describe("formatFileSize", () => {
  describe("unit selection", () => {
    it("formats bytes correctly", () => {
      expect(formatFileSize(0)).toBe("0 B");
      expect(formatFileSize(512)).toBe("512 B");
      expect(formatFileSize(1023)).toBe("1,023 B");
    });

    it("formats kilobytes correctly", () => {
      expect(formatFileSize(1024)).toBe("1 KB");
      expect(formatFileSize(1536)).toBe("1.5 KB");
      expect(formatFileSize(10240)).toBe("10 KB");
    });

    it("formats megabytes correctly", () => {
      expect(formatFileSize(1048576)).toBe("1 MB");
      expect(formatFileSize(1572864)).toBe("1.5 MB");
      expect(formatFileSize(10485760)).toBe("10 MB");
    });

    it("formats gigabytes correctly", () => {
      expect(formatFileSize(1073741824)).toBe("1 GB");
      expect(formatFileSize(1610612736)).toBe("1.5 GB");
      expect(formatFileSize(10737418240)).toBe("10 GB");
    });

    it("formats terabytes correctly", () => {
      expect(formatFileSize(1099511627776)).toBe("1 TB");
      expect(formatFileSize(1649267441664)).toBe("1.5 TB");
    });
  });

  describe("decimal handling", () => {
    it("shows decimals for values less than 10", () => {
      expect(formatFileSize(1536)).toBe("1.5 KB");
      expect(formatFileSize(9216)).toBe("9 KB");
    });

    it("rounds to integers for values 10 or greater", () => {
      expect(formatFileSize(10240)).toBe("10 KB");
      expect(formatFileSize(102400)).toBe("100 KB");
    });
  });

  describe("locale formatting", () => {
    it("uses specified locale for number formatting", () => {
      expect(formatFileSize(1536, { locale: "de-DE" })).toBe("1,5 KB");
    });

    it("formats large byte values with locale separators", () => {
      expect(formatFileSize(1023, { locale: "en-US" })).toBe("1,023 B");
    });
  });

  describe("edge cases", () => {
    it("handles negative values as zero", () => {
      expect(formatFileSize(-100)).toBe("0 B");
    });

    it("handles zero", () => {
      expect(formatFileSize(0)).toBe("0 B");
    });
  });
});

describe("parseFileSize", () => {
  describe("valid inputs", () => {
    it("parses bytes", () => {
      expect(parseFileSize("512 B")).toBe(512);
      expect(parseFileSize("512B")).toBe(512);
      expect(parseFileSize("512")).toBe(512);
    });

    it("parses kilobytes", () => {
      expect(parseFileSize("1 KB")).toBe(1024);
      expect(parseFileSize("1.5 KB")).toBe(1536);
      expect(parseFileSize("1.5KB")).toBe(1536);
    });

    it("parses megabytes", () => {
      expect(parseFileSize("1 MB")).toBe(1048576);
      expect(parseFileSize("1.5 MB")).toBe(1572864);
    });

    it("parses gigabytes", () => {
      expect(parseFileSize("1 GB")).toBe(1073741824);
      expect(parseFileSize("1.5 GB")).toBe(1610612736);
    });

    it("parses terabytes", () => {
      expect(parseFileSize("1 TB")).toBe(1099511627776);
    });
  });

  describe("case insensitivity", () => {
    it("handles lowercase units", () => {
      expect(parseFileSize("1 kb")).toBe(1024);
      expect(parseFileSize("1 mb")).toBe(1048576);
    });

    it("handles mixed case units", () => {
      expect(parseFileSize("1 Kb")).toBe(1024);
      expect(parseFileSize("1 mB")).toBe(1048576);
    });
  });

  describe("european decimal separator", () => {
    it("handles comma as decimal separator", () => {
      expect(parseFileSize("1,5 KB")).toBe(1536);
      expect(parseFileSize("1,5 MB")).toBe(1572864);
    });
  });

  describe("invalid inputs", () => {
    it("returns null for empty string", () => {
      expect(parseFileSize("")).toBeNull();
    });

    it("returns null for invalid format", () => {
      expect(parseFileSize("invalid")).toBeNull();
      expect(parseFileSize("MB 1")).toBeNull();
    });

    it("returns null for negative values", () => {
      expect(parseFileSize("-1 KB")).toBeNull();
    });

    it("returns null for non-string input", () => {
      expect(parseFileSize(null as unknown as string)).toBeNull();
      expect(parseFileSize(undefined as unknown as string)).toBeNull();
    });
  });
});

describe("constants", () => {
  it("exports correct unit multipliers", () => {
    expect(BYTES_PER_UNIT.B).toBe(1);
    expect(BYTES_PER_UNIT.KB).toBe(1024);
    expect(BYTES_PER_UNIT.MB).toBe(1048576);
    expect(BYTES_PER_UNIT.GB).toBe(1073741824);
    expect(BYTES_PER_UNIT.TB).toBe(1099511627776);
  });

  it("exports unit array in order", () => {
    expect(FILE_SIZE_UNITS).toEqual(["B", "KB", "MB", "GB", "TB"]);
  });
});

describe("roundtrip", () => {
  it("parseFileSize inverts formatFileSize for exact values", () => {
    const testValues = [0, 1024, 1048576, 1073741824, 1099511627776];

    for (const bytes of testValues) {
      const formatted = formatFileSize(bytes);
      const parsed = parseFileSize(formatted);
      expect(parsed).toBe(bytes);
    }
  });
});
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- file-size.spec
```
