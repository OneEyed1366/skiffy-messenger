# T5.09: Local Storage Hook

## Metadata

| Field        | Value      |
| ------------ | ---------- |
| **ID**       | T5.09      |
| **Layer**    | L5 - Hooks |
| **Status**   | pending    |
| **Priority** | high       |
| **Estimate** | 3h         |
| **Parallel** | true       |
| **Assignee** | -          |
| **Created**  | 2026-01-04 |
| **Updated**  | 2026-01-04 |

## Dependencies

| Task ID | Name          |
| ------- | ------------- |
| T0.15   | types-utility |

## Blocks

| Task ID | Name                             |
| ------- | -------------------------------- |
| T6.\*   | Components requiring persistence |
| T10b.\* | Components with user preferences |

## Description

Migrate localStorage persistence pattern from Mattermost to React Native. The original uses synchronous `localStorage` API directly. Replace with `@react-native-async-storage/async-storage` for cross-platform support (RN + Tauri) with proper SSR safety and async handling.

## Source Files

- `vendor/desktop/webapp/channels/src/stores/local_storage_store.ts`
- `vendor/desktop/webapp/channels/src/stores/browser_store.tsx`

### Source Analysis

The original implementation uses:

- **Synchronous localStorage**: Direct `localStorage.getItem/setItem/removeItem` calls
- **Path-scoped keys**: Keys prefixed with base path for multi-tenant support
- **JSON serialization**: Manual `JSON.stringify/parse` for object storage
- **No SSR handling**: Assumes browser environment

Key patterns migrated:
| Original Pattern | Purpose |
|------------------|---------|
| `localStorage.getItem(key)` | Read string value |
| `localStorage.setItem(key, value)` | Write string value |
| `localStorage.removeItem(key)` | Delete key |
| Path-scoped keys | Multi-tenant isolation |
| Manual JSON.parse/stringify | Object serialization |

## Migration Target

- **Target File**: `apps/v2/src/hooks/useLocalStorage/useLocalStorage.ts`
- **Index Export**: `apps/v2/src/hooks/useLocalStorage/index.ts`

## Implementation

```typescript
// apps/v2/src/hooks/useLocalStorage/useLocalStorage.ts

/**
 * Local storage hook with SSR safety and async support
 * Migrated from: vendor/desktop/webapp/channels/src/stores/local_storage_store.ts
 *
 * Uses @react-native-async-storage/async-storage for cross-platform persistence
 */

import { useCallback, useEffect, useState, useSyncExternalStore } from "react";
import AsyncStorage from "@react-native-async-storage/async-storage";

//#region Types

type ISerializable = string | number | boolean | null | object | unknown[];

type IUseLocalStorageOptions<T> = {
  /**
   * Default value when key doesn't exist
   */
  defaultValue?: T;
  /**
   * Custom serializer (default: JSON.stringify)
   */
  serialize?: (value: T) => string;
  /**
   * Custom deserializer (default: JSON.parse)
   */
  deserialize?: (value: string) => T;
};

type IUseLocalStorageReturn<T> = {
  /**
   * Current value (null during initial load, defaultValue after)
   */
  value: T | null;
  /**
   * Update the stored value
   */
  setValue: (value: T | ((prev: T | null) => T)) => Promise<void>;
  /**
   * Remove the key from storage
   */
  removeValue: () => Promise<void>;
  /**
   * Whether the initial load is complete
   */
  isLoading: boolean;
  /**
   * Error from last operation (null if none)
   */
  error: Error | null;
  /**
   * Force refresh from storage
   */
  refresh: () => Promise<void>;
};

type IStorageEvent = {
  key: string;
  value: string | null;
};

//#endregion Types

//#region Storage Event Emitter

/**
 * Simple event emitter for cross-hook synchronization
 * When one hook updates a value, others with same key get notified
 */
const listeners = new Map<string, Set<(value: string | null) => void>>();

function subscribe(key: string, callback: (value: string | null) => void) {
  if (!listeners.has(key)) {
    listeners.set(key, new Set());
  }
  listeners.get(key)!.add(callback);

  return () => {
    const keyListeners = listeners.get(key);
    if (keyListeners) {
      keyListeners.delete(callback);
      if (keyListeners.size === 0) {
        listeners.delete(key);
      }
    }
  };
}

function emit(key: string, value: string | null) {
  const keyListeners = listeners.get(key);
  if (keyListeners) {
    keyListeners.forEach((callback) => callback(value));
  }
}

//#endregion Storage Event Emitter

//#region SSR Safety

/**
 * Check if we're in a browser/RN environment where storage is available
 */
function canUseStorage(): boolean {
  return typeof window !== "undefined" || typeof global !== "undefined";
}

/**
 * Server snapshot for SSR - always returns null
 */
function getServerSnapshot<T>(): T | null {
  return null;
}

//#endregion SSR Safety

//#region Serialization

const defaultSerialize = <T>(value: T): string => {
  if (typeof value === "string") {
    return value;
  }
  return JSON.stringify(value);
};

const defaultDeserialize = <T>(value: string, defaultValue?: T): T => {
  // If default is string type, return raw value
  if (typeof defaultValue === "string") {
    return value as T;
  }

  try {
    return JSON.parse(value) as T;
  } catch {
    // If JSON parse fails and we have a string, return it as-is
    return value as T;
  }
};

//#endregion Serialization

//#region Main Hook

/**
 * React hook for persisting state to AsyncStorage with SSR safety.
 *
 * Features:
 * - Async-first API (all mutations return Promises)
 * - SSR safe (returns null/defaultValue on server)
 * - Cross-hook synchronization (updates propagate to other hooks with same key)
 * - Type-safe with generics
 * - Custom serialization support
 *
 * @param key - Storage key
 * @param options - Configuration options
 * @returns Object with value, setValue, removeValue, isLoading, error, refresh
 *
 * @example
 * // String value
 * const { value, setValue } = useLocalStorage<string>('@theme', {
 *   defaultValue: 'light'
 * });
 *
 * @example
 * // Object value
 * const { value, setValue, isLoading } = useLocalStorage<IUserPrefs>('@prefs', {
 *   defaultValue: { notifications: true, sound: true }
 * });
 *
 * // Update
 * await setValue({ notifications: false, sound: true });
 *
 * @example
 * // Functional update
 * await setValue((prev) => ({ ...prev, notifications: !prev?.notifications }));
 */
export function useLocalStorage<T extends ISerializable>(
  key: string,
  options: IUseLocalStorageOptions<T> = {},
): IUseLocalStorageReturn<T> {
  const {
    defaultValue,
    serialize = defaultSerialize,
    deserialize = (v: string) => defaultDeserialize(v, defaultValue),
  } = options;

  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const [cachedValue, setCachedValue] = useState<T | null>(
    defaultValue ?? null,
  );

  //#region Load from storage

  const loadValue = useCallback(async () => {
    if (!canUseStorage()) {
      setIsLoading(false);
      return;
    }

    try {
      setError(null);
      const stored = await AsyncStorage.getItem(key);

      if (stored !== null) {
        const parsed = deserialize(stored);
        setCachedValue(parsed);
      } else if (defaultValue !== undefined) {
        setCachedValue(defaultValue);
      }
    } catch (e) {
      const err = e instanceof Error ? e : new Error(String(e));
      setError(err);
      console.error(`[useLocalStorage] Error loading key "${key}":`, err);
    } finally {
      setIsLoading(false);
    }
  }, [key, defaultValue, deserialize]);

  //#endregion Load from storage

  //#region Initial load

  useEffect(() => {
    loadValue();
  }, [loadValue]);

  //#endregion Initial load

  //#region Cross-hook sync

  useEffect(() => {
    const unsubscribe = subscribe(key, (newValue) => {
      if (newValue === null) {
        setCachedValue(defaultValue ?? null);
      } else {
        try {
          setCachedValue(deserialize(newValue));
        } catch (e) {
          console.error(`[useLocalStorage] Deserialize error for "${key}":`, e);
        }
      }
    });

    return unsubscribe;
  }, [key, defaultValue, deserialize]);

  //#endregion Cross-hook sync

  //#region setValue

  const setValue = useCallback(
    async (valueOrUpdater: T | ((prev: T | null) => T)): Promise<void> => {
      if (!canUseStorage()) {
        return;
      }

      try {
        setError(null);

        const newValue =
          typeof valueOrUpdater === "function"
            ? (valueOrUpdater as (prev: T | null) => T)(cachedValue)
            : valueOrUpdater;

        const serialized = serialize(newValue);
        await AsyncStorage.setItem(key, serialized);

        setCachedValue(newValue);
        emit(key, serialized);
      } catch (e) {
        const err = e instanceof Error ? e : new Error(String(e));
        setError(err);
        console.error(`[useLocalStorage] Error setting key "${key}":`, err);
        throw err;
      }
    },
    [key, cachedValue, serialize],
  );

  //#endregion setValue

  //#region removeValue

  const removeValue = useCallback(async (): Promise<void> => {
    if (!canUseStorage()) {
      return;
    }

    try {
      setError(null);
      await AsyncStorage.removeItem(key);
      setCachedValue(defaultValue ?? null);
      emit(key, null);
    } catch (e) {
      const err = e instanceof Error ? e : new Error(String(e));
      setError(err);
      console.error(`[useLocalStorage] Error removing key "${key}":`, err);
      throw err;
    }
  }, [key, defaultValue]);

  //#endregion removeValue

  //#region refresh

  const refresh = useCallback(async (): Promise<void> => {
    setIsLoading(true);
    await loadValue();
  }, [loadValue]);

  //#endregion refresh

  return {
    value: cachedValue,
    setValue,
    removeValue,
    isLoading,
    error,
    refresh,
  };
}

//#endregion Main Hook

//#region Utility Functions

/**
 * Get a value from storage directly (non-reactive).
 * Useful for one-off reads outside of components.
 *
 * @param key - Storage key
 * @returns Promise resolving to the stored string or null
 *
 * @example
 * const token = await getStorageItem('@auth_token');
 */
export async function getStorageItem(key: string): Promise<string | null> {
  if (!canUseStorage()) {
    return null;
  }
  return AsyncStorage.getItem(key);
}

/**
 * Set a value in storage directly (non-reactive).
 * Useful for one-off writes outside of components.
 *
 * @param key - Storage key
 * @param value - Value to store
 *
 * @example
 * await setStorageItem('@auth_token', 'abc123');
 */
export async function setStorageItem(
  key: string,
  value: string,
): Promise<void> {
  if (!canUseStorage()) {
    return;
  }
  await AsyncStorage.setItem(key, value);
  emit(key, value);
}

/**
 * Remove a value from storage directly (non-reactive).
 *
 * @param key - Storage key
 *
 * @example
 * await removeStorageItem('@auth_token');
 */
export async function removeStorageItem(key: string): Promise<void> {
  if (!canUseStorage()) {
    return;
  }
  await AsyncStorage.removeItem(key);
  emit(key, null);
}

/**
 * Get multiple values from storage.
 *
 * @param keys - Array of storage keys
 * @returns Promise resolving to a Map of key-value pairs
 *
 * @example
 * const values = await getMultipleStorageItems(['@theme', '@locale']);
 * console.log(values.get('@theme')); // 'dark'
 */
export async function getMultipleStorageItems(
  keys: string[],
): Promise<Map<string, string | null>> {
  if (!canUseStorage()) {
    return new Map(keys.map((k) => [k, null]));
  }

  const pairs = await AsyncStorage.multiGet(keys);
  return new Map(pairs);
}

/**
 * Set multiple values in storage.
 *
 * @param entries - Array of [key, value] tuples
 *
 * @example
 * await setMultipleStorageItems([
 *   ['@theme', 'dark'],
 *   ['@locale', 'en-US']
 * ]);
 */
export async function setMultipleStorageItems(
  entries: Array<[string, string]>,
): Promise<void> {
  if (!canUseStorage()) {
    return;
  }

  await AsyncStorage.multiSet(entries);

  // Emit for each key
  entries.forEach(([key, value]) => emit(key, value));
}

/**
 * Remove multiple values from storage.
 *
 * @param keys - Array of storage keys to remove
 *
 * @example
 * await removeMultipleStorageItems(['@temp_data', '@cache']);
 */
export async function removeMultipleStorageItems(
  keys: string[],
): Promise<void> {
  if (!canUseStorage()) {
    return;
  }

  await AsyncStorage.multiRemove(keys);

  // Emit null for each key
  keys.forEach((key) => emit(key, null));
}

/**
 * Clear all storage (use with caution).
 *
 * @example
 * await clearStorage();
 */
export async function clearStorage(): Promise<void> {
  if (!canUseStorage()) {
    return;
  }

  const keys = await AsyncStorage.getAllKeys();
  await AsyncStorage.multiRemove(keys);

  // Emit null for all cleared keys
  keys.forEach((key) => emit(key, null));
}

/**
 * Get all storage keys.
 *
 * @returns Promise resolving to array of all keys
 *
 * @example
 * const keys = await getAllStorageKeys();
 */
export async function getAllStorageKeys(): Promise<string[]> {
  if (!canUseStorage()) {
    return [];
  }

  const keys = await AsyncStorage.getAllKeys();
  return [...keys];
}

//#endregion Utility Functions

//#region Storage Key Helpers

/**
 * Create a scoped storage key with prefix.
 * Useful for namespacing keys by feature or user.
 *
 * @param prefix - Key prefix (e.g., '@user', '@settings')
 * @param key - Base key name
 * @returns Scoped key string
 *
 * @example
 * const key = createStorageKey('@user', 'preferences');
 * // Returns: '@user:preferences'
 */
export function createStorageKey(prefix: string, key: string): string {
  return `${prefix}:${key}`;
}

/**
 * Create a user-scoped storage key.
 *
 * @param userId - User identifier
 * @param key - Base key name
 * @returns User-scoped key string
 *
 * @example
 * const key = createUserStorageKey('user123', 'theme');
 * // Returns: '@user:user123:theme'
 */
export function createUserStorageKey(userId: string, key: string): string {
  return `@user:${userId}:${key}`;
}

//#endregion Storage Key Helpers
```

## Index Export

```typescript
// apps/v2/src/hooks/useLocalStorage/index.ts

export {
  // Main hook
  useLocalStorage,
  // Direct storage functions
  getStorageItem,
  setStorageItem,
  removeStorageItem,
  getMultipleStorageItems,
  setMultipleStorageItems,
  removeMultipleStorageItems,
  clearStorage,
  getAllStorageKeys,
  // Key helpers
  createStorageKey,
  createUserStorageKey,
} from "./useLocalStorage";
```

## Acceptance Criteria

- [ ] Uses `@react-native-async-storage/async-storage` for persistence
- [ ] All mutations are async (return `Promise`)
- [ ] SSR safe (returns null/defaultValue when storage unavailable)
- [ ] Cross-hook synchronization (updates propagate to other hooks with same key)
- [ ] Supports generic types with proper inference
- [ ] Includes `isLoading` state for initial load
- [ ] Includes `error` state for operation failures
- [ ] Supports functional updates `setValue((prev) => newValue)`
- [ ] Supports custom serialization/deserialization
- [ ] Utility functions for direct storage access
- [ ] Key helper functions for scoped keys
- [ ] All types use `I` prefix naming convention
- [ ] Exported from `hooks/useLocalStorage/index.ts`
- [ ] TypeScript strict mode passes
- [ ] No `any` types

## Testing

```typescript
// apps/v2/src/hooks/useLocalStorage/useLocalStorage.spec.tsx

import { renderHook, act, waitFor } from "@testing-library/react-native";
import AsyncStorage from "@react-native-async-storage/async-storage";

import {
  useLocalStorage,
  getStorageItem,
  setStorageItem,
  removeStorageItem,
  getMultipleStorageItems,
  setMultipleStorageItems,
  removeMultipleStorageItems,
  clearStorage,
  getAllStorageKeys,
  createStorageKey,
  createUserStorageKey,
} from "./useLocalStorage";

//#region Setup

beforeEach(async () => {
  await AsyncStorage.clear();
  jest.clearAllMocks();
});

//#endregion Setup

//#region useLocalStorage Hook Tests

describe("useLocalStorage", () => {
  describe("initial load", () => {
    it("returns defaultValue when key does not exist", async () => {
      const { result } = renderHook(() =>
        useLocalStorage<string>("@test_key", { defaultValue: "default" }),
      );

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      expect(result.current.value).toBe("default");
      expect(result.current.error).toBeNull();
    });

    it("returns stored value when key exists", async () => {
      await AsyncStorage.setItem("@test_key", JSON.stringify({ name: "test" }));

      const { result } = renderHook(() =>
        useLocalStorage<{ name: string }>("@test_key"),
      );

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      expect(result.current.value).toEqual({ name: "test" });
    });

    it("returns string value without JSON parsing", async () => {
      await AsyncStorage.setItem("@string_key", "plain string");

      const { result } = renderHook(() =>
        useLocalStorage<string>("@string_key", { defaultValue: "" }),
      );

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      expect(result.current.value).toBe("plain string");
    });

    it("sets isLoading to true initially", () => {
      const { result } = renderHook(() => useLocalStorage<string>("@test_key"));

      expect(result.current.isLoading).toBe(true);
    });
  });

  describe("setValue", () => {
    it("persists value to storage", async () => {
      const { result } = renderHook(() =>
        useLocalStorage<string>("@test_key", { defaultValue: "" }),
      );

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      await act(async () => {
        await result.current.setValue("new value");
      });

      expect(result.current.value).toBe("new value");

      const stored = await AsyncStorage.getItem("@test_key");
      expect(stored).toBe("new value");
    });

    it("persists object value as JSON", async () => {
      const { result } = renderHook(() =>
        useLocalStorage<{ count: number }>("@obj_key"),
      );

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      await act(async () => {
        await result.current.setValue({ count: 42 });
      });

      expect(result.current.value).toEqual({ count: 42 });

      const stored = await AsyncStorage.getItem("@obj_key");
      expect(stored).toBe(JSON.stringify({ count: 42 }));
    });

    it("supports functional updates", async () => {
      await AsyncStorage.setItem("@counter", JSON.stringify(5));

      const { result } = renderHook(() =>
        useLocalStorage<number>("@counter", { defaultValue: 0 }),
      );

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      await act(async () => {
        await result.current.setValue((prev) => (prev ?? 0) + 1);
      });

      expect(result.current.value).toBe(6);
    });
  });

  describe("removeValue", () => {
    it("removes key from storage", async () => {
      await AsyncStorage.setItem("@remove_key", "value");

      const { result } = renderHook(() =>
        useLocalStorage<string>("@remove_key", { defaultValue: "default" }),
      );

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      expect(result.current.value).toBe("value");

      await act(async () => {
        await result.current.removeValue();
      });

      expect(result.current.value).toBe("default");

      const stored = await AsyncStorage.getItem("@remove_key");
      expect(stored).toBeNull();
    });
  });

  describe("refresh", () => {
    it("reloads value from storage", async () => {
      await AsyncStorage.setItem("@refresh_key", JSON.stringify("initial"));

      const { result } = renderHook(() =>
        useLocalStorage<string>("@refresh_key"),
      );

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      expect(result.current.value).toBe("initial");

      // Simulate external update
      await AsyncStorage.setItem("@refresh_key", JSON.stringify("updated"));

      await act(async () => {
        await result.current.refresh();
      });

      expect(result.current.value).toBe("updated");
    });
  });

  describe("cross-hook synchronization", () => {
    it("syncs value across multiple hooks with same key", async () => {
      const { result: hook1 } = renderHook(() =>
        useLocalStorage<string>("@sync_key", { defaultValue: "" }),
      );
      const { result: hook2 } = renderHook(() =>
        useLocalStorage<string>("@sync_key", { defaultValue: "" }),
      );

      await waitFor(() => {
        expect(hook1.current.isLoading).toBe(false);
        expect(hook2.current.isLoading).toBe(false);
      });

      await act(async () => {
        await hook1.current.setValue("synced value");
      });

      expect(hook1.current.value).toBe("synced value");
      expect(hook2.current.value).toBe("synced value");
    });
  });

  describe("error handling", () => {
    it("sets error state on load failure", async () => {
      jest
        .spyOn(AsyncStorage, "getItem")
        .mockRejectedValueOnce(new Error("Load failed"));

      const { result } = renderHook(() =>
        useLocalStorage<string>("@error_key"),
      );

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      expect(result.current.error).toBeInstanceOf(Error);
      expect(result.current.error?.message).toBe("Load failed");
    });

    it("throws and sets error on setValue failure", async () => {
      jest
        .spyOn(AsyncStorage, "setItem")
        .mockRejectedValueOnce(new Error("Save failed"));

      const { result } = renderHook(() =>
        useLocalStorage<string>("@error_key", { defaultValue: "" }),
      );

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      await expect(
        act(async () => {
          await result.current.setValue("value");
        }),
      ).rejects.toThrow("Save failed");

      expect(result.current.error?.message).toBe("Save failed");
    });
  });

  describe("custom serialization", () => {
    it("uses custom serialize/deserialize functions", async () => {
      const serialize = (value: Date) => value.toISOString();
      const deserialize = (value: string) => new Date(value);

      const { result } = renderHook(() =>
        useLocalStorage<Date>("@date_key", {
          serialize,
          deserialize,
        }),
      );

      await waitFor(() => {
        expect(result.current.isLoading).toBe(false);
      });

      const testDate = new Date("2026-01-04T12:00:00Z");

      await act(async () => {
        await result.current.setValue(testDate);
      });

      expect(result.current.value?.toISOString()).toBe(testDate.toISOString());

      const stored = await AsyncStorage.getItem("@date_key");
      expect(stored).toBe(testDate.toISOString());
    });
  });
});

//#endregion useLocalStorage Hook Tests

//#region Utility Function Tests

describe("getStorageItem", () => {
  it("returns stored value", async () => {
    await AsyncStorage.setItem("@util_key", "stored");

    const value = await getStorageItem("@util_key");
    expect(value).toBe("stored");
  });

  it("returns null for missing key", async () => {
    const value = await getStorageItem("@missing_key");
    expect(value).toBeNull();
  });
});

describe("setStorageItem", () => {
  it("stores value", async () => {
    await setStorageItem("@util_set", "value");

    const stored = await AsyncStorage.getItem("@util_set");
    expect(stored).toBe("value");
  });
});

describe("removeStorageItem", () => {
  it("removes key", async () => {
    await AsyncStorage.setItem("@util_remove", "value");
    await removeStorageItem("@util_remove");

    const stored = await AsyncStorage.getItem("@util_remove");
    expect(stored).toBeNull();
  });
});

describe("getMultipleStorageItems", () => {
  it("returns map of key-value pairs", async () => {
    await AsyncStorage.setItem("@multi_1", "value1");
    await AsyncStorage.setItem("@multi_2", "value2");

    const result = await getMultipleStorageItems(["@multi_1", "@multi_2"]);

    expect(result.get("@multi_1")).toBe("value1");
    expect(result.get("@multi_2")).toBe("value2");
  });
});

describe("setMultipleStorageItems", () => {
  it("stores multiple key-value pairs", async () => {
    await setMultipleStorageItems([
      ["@batch_1", "value1"],
      ["@batch_2", "value2"],
    ]);

    expect(await AsyncStorage.getItem("@batch_1")).toBe("value1");
    expect(await AsyncStorage.getItem("@batch_2")).toBe("value2");
  });
});

describe("removeMultipleStorageItems", () => {
  it("removes multiple keys", async () => {
    await AsyncStorage.setItem("@rm_1", "value1");
    await AsyncStorage.setItem("@rm_2", "value2");

    await removeMultipleStorageItems(["@rm_1", "@rm_2"]);

    expect(await AsyncStorage.getItem("@rm_1")).toBeNull();
    expect(await AsyncStorage.getItem("@rm_2")).toBeNull();
  });
});

describe("clearStorage", () => {
  it("removes all keys", async () => {
    await AsyncStorage.setItem("@clear_1", "value1");
    await AsyncStorage.setItem("@clear_2", "value2");

    await clearStorage();

    const keys = await AsyncStorage.getAllKeys();
    expect(keys).toHaveLength(0);
  });
});

describe("getAllStorageKeys", () => {
  it("returns all keys", async () => {
    await AsyncStorage.setItem("@keys_1", "value1");
    await AsyncStorage.setItem("@keys_2", "value2");

    const keys = await getAllStorageKeys();

    expect(keys).toContain("@keys_1");
    expect(keys).toContain("@keys_2");
  });
});

//#endregion Utility Function Tests

//#region Key Helper Tests

describe("createStorageKey", () => {
  it("creates scoped key with prefix", () => {
    const key = createStorageKey("@settings", "theme");
    expect(key).toBe("@settings:theme");
  });
});

describe("createUserStorageKey", () => {
  it("creates user-scoped key", () => {
    const key = createUserStorageKey("user123", "preferences");
    expect(key).toBe("@user:user123:preferences");
  });
});

//#endregion Key Helper Tests
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- useLocalStorage
```
