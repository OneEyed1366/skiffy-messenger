# T8.02: WebSocket Event Streams

## Metadata

| Field        | Value               |
| ------------ | ------------------- |
| **ID**       | T8.02               |
| **Layer**    | L8 - WebSocket RxJS |
| **Status**   | pending             |
| **Priority** | high                |
| **Estimate** | 6h                  |
| **Parallel** | -                   |
| **Assignee** | -                   |
| **Created**  | 2026-01-04          |
| **Updated**  | 2026-01-05          |

## Dependencies

| Task ID | Name                    |
| ------- | ----------------------- |
| T8.01   | WebSocket Service       |
| T8.03   | debounceAfterN Operator |

## Blocks

| Task ID | Name                   |
| ------- | ---------------------- |
| T9.\*   | All state hooks        |
| L11.\*  | All feature components |

## Description

Define typed RxJS event streams derived from the main `websocketService.events$` observable. Each stream filters, transforms, and applies appropriate operators (debounce, buffer, throttle) for its event category.

This task covers all 90+ WebSocket event types from the vendor implementation, organized into logical streams.

## Source Files

- `vendor/desktop/webapp/channels/src/utils/constants.tsx` (lines 616-706)
- `vendor/desktop/webapp/channels/src/actions/websocket_actions.jsx` (lines 357-679)

### Source Analysis

| Category    | Events                                                                                  | Special Handling                                         |
| ----------- | --------------------------------------------------------------------------------------- | -------------------------------------------------------- |
| Posts       | posted, post_edited, post_deleted, post_unread, ephemeral_message                       | `debounceAfterN(5,100,200)` - vendor-matching batch      |
| Typing      | typing                                                                                  | `groupBy` + `switchMap` + `merge` - emit true then false |
| Channels    | channel_created, channel_deleted, channel_updated, channel_member_updated, direct_added | -                                                        |
| Users       | user_added, user_removed, user_updated, status_change                                   | `distinctUntilChanged` - dedupe identical updates        |
| Teams       | added_to_team, leave_team, update_team, delete_team                                     | -                                                        |
| Reactions   | reaction_added, reaction_removed, emoji_added                                           | `throttleTime(500)`                                      |
| Threads     | thread_updated, thread_follow_changed, thread_read_changed                              | -                                                        |
| Preferences | preference_changed, preferences_changed, preferences_deleted                            | -                                                        |
| System      | hello, config_changed, license_changed                                                  | -                                                        |

**Important fixes in this task:**

1. **`posts$`**: Changed from `bufferTime(100)` to `debounceAfterN(5, 100, 200)` to match vendor behavior. This eliminates 100ms latency on single posts.

2. **`typing$`**: Fixed critical bug where `debounceTime` prevented `isTyping: true` from ever being emitted. Now uses `switchMap` + `merge` pattern to emit both states.

3. **All streams**: Added `share()` operator to prevent duplicate processing pipelines when multiple components subscribe.

## Migration Target

- **Target Directory**: `apps/v2/src/services/websocket/streams/`

## File Structure

```
apps/v2/src/services/websocket/streams/
├── index.ts          # Re-exports all streams
├── posts$.ts
├── typing$.ts
├── channels$.ts
├── users$.ts
├── teams$.ts
├── reactions$.ts
├── threads$.ts
├── preferences$.ts
└── system$.ts
```

## Implementation

### streams/index.ts

```typescript
export { posts$, type IPostEventPayload } from "./posts$";
export { typing$, type ITypingEventPayload } from "./typing$";
export { channels$, type IChannelEventPayload } from "./channels$";
export { users$, type IUserEventPayload } from "./users$";
export { teams$, type ITeamEventPayload } from "./teams$";
export { reactions$, type IReactionEventPayload } from "./reactions$";
export { threads$, type IThreadEventPayload } from "./threads$";
export { preferences$, type IPreferenceEventPayload } from "./preferences$";
export { system$, type ISystemEventPayload } from "./system$";
```

### streams/posts$.ts

```typescript
import { filter, mergeMap, of, share } from "rxjs";
import { websocketService, IWebSocketEvent } from "../socket";
import { debounceAfterN } from "../operators";
import type { IPost } from "@/types";

//#region Types

const POST_EVENTS = [
  "posted",
  "post_edited",
  "post_deleted",
  "post_unread",
  "ephemeral_message",
  "post_acknowledgement_added",
  "post_acknowledgement_removed",
] as const;

type IPostEventType = (typeof POST_EVENTS)[number];

type IPostEventData = {
  post?: string; // JSON stringified
  channel_id?: string;
  team_id?: string;
};

export type IPostEventPayload = {
  type: IPostEventType;
  post: IPost | null;
  channelId: string;
  teamId: string;
};

//#endregion Types

//#region Helpers

function isPostEvent(
  msg: IWebSocketEvent,
): msg is IWebSocketEvent<IPostEventData> {
  return POST_EVENTS.includes(msg.event as IPostEventType);
}

function transformPost(
  msg: IWebSocketEvent<IPostEventData>,
): IPostEventPayload {
  let post: IPost | null = null;

  try {
    if (msg.data.post) {
      post = JSON.parse(msg.data.post) as IPost;
    }
  } catch {
    console.warn("[posts$] Failed to parse post:", msg.data.post);
  }

  return {
    type: msg.event as IPostEventType,
    post,
    channelId:
      msg.data.channel_id ||
      msg.broadcast?.channel_id ||
      post?.channel_id ||
      "",
    teamId: msg.data.team_id || msg.broadcast?.team_id || "",
  };
}

//#endregion Helpers

//#region Stream

/**
 * Post events with vendor-matching debounce behavior.
 *
 * Uses debounceAfterN operator (T8.03) which matches vendor debouncePostEvent:
 * - First 5 events: emitted IMMEDIATELY (no latency)
 * - Events 6+: batched and flushed after 100ms of silence
 * - Max queue: 200 events before overflow protection
 *
 * This prevents adding latency to single posts while still batching rapid bursts.
 *
 * @see vendor/desktop/webapp/channels/src/actions/websocket_actions.jsx:730-767
 */
export const posts$ = websocketService.events$.pipe(
  filter(isPostEvent),
  debounceAfterN(5, 100, 200), // First 5 immediate, then batch
  mergeMap((batch) => of(...batch.map(transformPost))),
  share(), // Share single pipeline across subscribers
);

//#endregion Stream
```

### streams/typing$.ts

```typescript
import {
  filter,
  groupBy,
  mergeMap,
  switchMap,
  merge,
  of,
  timer,
  map,
  share,
} from "rxjs";
import { websocketService, IWebSocketEvent } from "../socket";

//#region Constants

/** Typing indicator timeout in ms. Matches vendor TimeBetweenUserTypingUpdatesMilliseconds. */
const TYPING_TIMEOUT_MS = 5000;

//#endregion Constants

//#region Types

type ITypingEventData = {
  user_id: string;
  parent_id?: string;
};

export type ITypingEventPayload = {
  channelId: string;
  userId: string;
  parentId: string;
  isTyping: boolean;
};

//#endregion Types

//#region Stream

/**
 * Typing indicator events with configurable auto-expiry.
 *
 * **IMPORTANT:** This implementation fixes a critical bug in the original design.
 * The previous implementation using `debounceTime` ONLY emitted after silence,
 * meaning subscribers never received `isTyping: true`.
 *
 * Correct behavior (matching vendor):
 * - Emits `isTyping: true` IMMEDIATELY when typing event received
 * - Emits `isTyping: false` after `TimeBetweenUserTypingUpdatesMilliseconds` silence
 * - switchMap cancels pending stop timer if new typing event arrives
 *
 * Timeout is configurable via server config (default: 5000ms).
 *
 * @see vendor/desktop/webapp/channels/src/components/msg_typing/actions.ts:21-47
 */
export const typing$ = websocketService.events$.pipe(
  filter(
    (msg): msg is IWebSocketEvent<ITypingEventData> => msg.event === "typing",
  ),
  groupBy(
    (msg) =>
      `${msg.broadcast?.channel_id}:${msg.data.user_id}:${msg.data.parent_id || ""}`,
  ),
  mergeMap((group$) =>
    group$.pipe(
      switchMap((msg) => {
        const payload: ITypingEventPayload = {
          channelId: msg.broadcast?.channel_id || "",
          userId: msg.data.user_id,
          parentId: msg.data.parent_id || "",
          isTyping: true,
        };

        return merge(
          of(payload), // Emit TRUE immediately
          timer(TYPING_TIMEOUT_MS).pipe(
            map((): ITypingEventPayload => ({ ...payload, isTyping: false })),
          ),
        );
      }),
    ),
  ),
  share(), // Share single pipeline across subscribers
);

//#endregion Stream
```

### streams/channels$.ts

```typescript
import { filter, map, share } from "rxjs";
import { websocketService, IWebSocketEvent } from "../socket";
import type { IChannel, IChannelMember } from "@/types";

//#region Types

const CHANNEL_EVENTS = [
  "channel_created",
  "channel_deleted",
  "channel_updated",
  "channel_converted",
  "channel_member_updated",
  "channel_scheme_updated",
  "direct_added",
  "group_added",
  "channel_viewed",
  "multiple_channels_viewed",
] as const;

type IChannelEventType = (typeof CHANNEL_EVENTS)[number];

type IChannelEventData = {
  channel?: string;
  channel_id?: string;
  channel_member?: string;
};

export type IChannelEventPayload = {
  type: IChannelEventType;
  channel: IChannel | null;
  channelId: string;
  channelMember: IChannelMember | null;
};

//#endregion Types

//#region Stream

export const channels$ = websocketService.events$.pipe(
  filter((msg): msg is IWebSocketEvent<IChannelEventData> =>
    CHANNEL_EVENTS.includes(msg.event as IChannelEventType),
  ),
  map((msg): IChannelEventPayload => {
    let channel: IChannel | null = null;
    let channelMember: IChannelMember | null = null;

    try {
      if (msg.data.channel) {
        channel = JSON.parse(msg.data.channel) as IChannel;
      }
      if (msg.data.channel_member) {
        channelMember = JSON.parse(msg.data.channel_member) as IChannelMember;
      }
    } catch {
      console.warn("[channels$] Failed to parse channel data");
    }

    return {
      type: msg.event as IChannelEventType,
      channel,
      channelId:
        msg.data.channel_id || msg.broadcast?.channel_id || channel?.id || "",
      channelMember,
    };
  }),
  share(), // Share single pipeline across subscribers
);

//#endregion Stream
```

### streams/users$.ts

```typescript
import { filter, map, distinctUntilChanged, share } from "rxjs";
import { websocketService, IWebSocketEvent } from "../socket";
import type { IUserProfile, IUserStatus } from "@/types";

//#region Types

const USER_EVENTS = [
  "user_added",
  "user_removed",
  "user_updated",
  "user_role_updated",
  "status_change",
  "user_activation_status_change",
] as const;

type IUserEventType = (typeof USER_EVENTS)[number];

type IUserEventData = {
  user?: string;
  user_id?: string;
  status?: string;
};

export type IUserEventPayload = {
  type: IUserEventType;
  user: IUserProfile | null;
  userId: string;
  status: IUserStatus | null;
};

//#endregion Types

//#region Stream

export const users$ = websocketService.events$.pipe(
  filter((msg): msg is IWebSocketEvent<IUserEventData> =>
    USER_EVENTS.includes(msg.event as IUserEventType),
  ),
  map((msg): IUserEventPayload => {
    let user: IUserProfile | null = null;
    let status: IUserStatus | null = null;

    try {
      if (msg.data.user) {
        user = JSON.parse(msg.data.user) as IUserProfile;
      }
      if (msg.data.status) {
        status = msg.data.status as IUserStatus;
      }
    } catch {
      console.warn("[users$] Failed to parse user data");
    }

    return {
      type: msg.event as IUserEventType,
      user,
      userId: msg.data.user_id || msg.broadcast?.user_id || user?.id || "",
      status,
    };
  }),
  // Dedupe identical consecutive updates for same user
  distinctUntilChanged(
    (prev, curr) =>
      prev.userId === curr.userId &&
      prev.type === curr.type &&
      prev.status === curr.status &&
      JSON.stringify(prev.user) === JSON.stringify(curr.user),
  ),
  share(), // Share single pipeline across subscribers
);

//#endregion Stream
```

### streams/reactions$.ts

```typescript
import { filter, map, throttleTime, share } from "rxjs";
import { websocketService, IWebSocketEvent } from "../socket";
import type { IReaction } from "@/types";

//#region Types

const REACTION_EVENTS = [
  "reaction_added",
  "reaction_removed",
  "emoji_added",
] as const;

type IReactionEventType = (typeof REACTION_EVENTS)[number];

type IReactionEventData = {
  reaction?: string;
};

export type IReactionEventPayload = {
  type: IReactionEventType;
  reaction: IReaction | null;
  postId: string;
};

//#endregion Types

//#region Stream

/**
 * Reaction events with throttling to prevent UI spam.
 */
export const reactions$ = websocketService.events$.pipe(
  filter((msg): msg is IWebSocketEvent<IReactionEventData> =>
    REACTION_EVENTS.includes(msg.event as IReactionEventType),
  ),
  throttleTime(500, undefined, { leading: true, trailing: true }),
  map((msg): IReactionEventPayload => {
    let reaction: IReaction | null = null;

    try {
      if (msg.data.reaction) {
        reaction = JSON.parse(msg.data.reaction) as IReaction;
      }
    } catch {
      console.warn("[reactions$] Failed to parse reaction");
    }

    return {
      type: msg.event as IReactionEventType,
      reaction,
      postId: reaction?.postId || "",
    };
  }),
  share(), // Share single pipeline across subscribers
);

//#endregion Stream
```

### streams/threads$.ts

```typescript
import { filter, map, share } from "rxjs";
import { websocketService, IWebSocketEvent } from "../socket";
import type { IThread } from "@/types";

//#region Types

const THREAD_EVENTS = [
  "thread_updated",
  "thread_follow_changed",
  "thread_read_changed",
] as const;

type IThreadEventType = (typeof THREAD_EVENTS)[number];

type IThreadEventData = {
  thread?: string;
  thread_membership?: string;
  previous?: unknown;
};

export type IThreadEventPayload = {
  type: IThreadEventType;
  thread: IThread | null;
  threadId: string;
  isFollowing: boolean | null;
};

//#endregion Types

//#region Stream

export const threads$ = websocketService.events$.pipe(
  filter((msg): msg is IWebSocketEvent<IThreadEventData> =>
    THREAD_EVENTS.includes(msg.event as IThreadEventType),
  ),
  map((msg): IThreadEventPayload => {
    let thread: IThread | null = null;
    let isFollowing: boolean | null = null;

    try {
      if (msg.data.thread) {
        thread = JSON.parse(msg.data.thread) as IThread;
      }
      if (msg.data.thread_membership) {
        const membership = JSON.parse(msg.data.thread_membership);
        isFollowing = membership.following ?? null;
      }
    } catch {
      console.warn("[threads$] Failed to parse thread data");
    }

    return {
      type: msg.event as IThreadEventType,
      thread,
      threadId: thread?.id || "",
      isFollowing,
    };
  }),
  share(), // Share single pipeline across subscribers
);

//#endregion Stream
```

### streams/teams$.ts

```typescript
import { filter, map, share } from "rxjs";
import { websocketService, IWebSocketEvent } from "../socket";
import type { ITeam } from "@/types";

//#region Types

const TEAM_EVENTS = [
  "added_to_team",
  "leave_team",
  "update_team",
  "delete_team",
  "update_team_scheme",
] as const;

type ITeamEventType = (typeof TEAM_EVENTS)[number];

type ITeamEventData = {
  team?: string;
  team_id?: string;
  user_id?: string;
};

export type ITeamEventPayload = {
  type: ITeamEventType;
  team: ITeam | null;
  teamId: string;
  userId: string;
};

//#endregion Types

//#region Stream

export const teams$ = websocketService.events$.pipe(
  filter((msg): msg is IWebSocketEvent<ITeamEventData> =>
    TEAM_EVENTS.includes(msg.event as ITeamEventType),
  ),
  map((msg): ITeamEventPayload => {
    let team: ITeam | null = null;

    try {
      if (msg.data.team) {
        team = JSON.parse(msg.data.team) as ITeam;
      }
    } catch {
      console.warn("[teams$] Failed to parse team data");
    }

    return {
      type: msg.event as ITeamEventType,
      team,
      teamId: msg.data.team_id || msg.broadcast?.team_id || team?.id || "",
      userId: msg.data.user_id || msg.broadcast?.user_id || "",
    };
  }),
  share(), // Share single pipeline across subscribers
);

//#endregion Stream
```

### streams/preferences$.ts

```typescript
import { filter, map, share } from "rxjs";
import { websocketService, IWebSocketEvent } from "../socket";
import type { IPreference } from "@/types";

//#region Types

const PREFERENCE_EVENTS = [
  "preference_changed",
  "preferences_changed",
  "preferences_deleted",
] as const;

type IPreferenceEventType = (typeof PREFERENCE_EVENTS)[number];

type IPreferenceEventData = {
  preference?: string;
  preferences?: string;
};

export type IPreferenceEventPayload = {
  type: IPreferenceEventType;
  preferences: IPreference[];
};

//#endregion Types

//#region Stream

export const preferences$ = websocketService.events$.pipe(
  filter((msg): msg is IWebSocketEvent<IPreferenceEventData> =>
    PREFERENCE_EVENTS.includes(msg.event as IPreferenceEventType),
  ),
  map((msg): IPreferenceEventPayload => {
    let preferences: IPreference[] = [];

    try {
      if (msg.data.preference) {
        preferences = [JSON.parse(msg.data.preference) as IPreference];
      }
      if (msg.data.preferences) {
        preferences = JSON.parse(msg.data.preferences) as IPreference[];
      }
    } catch {
      console.warn("[preferences$] Failed to parse preference data");
    }

    return {
      type: msg.event as IPreferenceEventType,
      preferences,
    };
  }),
  share(), // Share single pipeline across subscribers
);

//#endregion Stream
```

### streams/system$.ts

```typescript
import { filter, map, share } from "rxjs";
import { websocketService, IWebSocketEvent } from "../socket";

//#region Types

const SYSTEM_EVENTS = [
  "hello",
  "config_changed",
  "license_changed",
  "plugin_enabled",
  "plugin_disabled",
  "plugin_statuses_changed",
] as const;

type ISystemEventType = (typeof SYSTEM_EVENTS)[number];

type ISystemEventData = {
  connection_id?: string;
  server_version?: string;
  [key: string]: unknown;
};

export type ISystemEventPayload = {
  type: ISystemEventType;
  connectionId: string;
  serverVersion: string;
  data: Record<string, unknown>;
};

//#endregion Types

//#region Stream

export const system$ = websocketService.events$.pipe(
  filter((msg): msg is IWebSocketEvent<ISystemEventData> =>
    SYSTEM_EVENTS.includes(msg.event as ISystemEventType),
  ),
  map(
    (msg): ISystemEventPayload => ({
      type: msg.event as ISystemEventType,
      connectionId: msg.data.connection_id || "",
      serverVersion: msg.data.server_version || "",
      data: msg.data,
    }),
  ),
  share(), // Share single pipeline across subscribers
);

//#endregion Stream
```

## Acceptance Criteria

- [ ] `posts$` uses `debounceAfterN(5, 100, 200)` for vendor-matching behavior
- [ ] `posts$` first 5 events emitted immediately (no latency)
- [ ] `posts$` events 6+ batched and flushed after 100ms silence
- [ ] `typing$` emits `isTyping: true` IMMEDIATELY on typing event
- [ ] `typing$` emits `isTyping: false` after 5000ms timeout (TYPING_TIMEOUT_MS constant)
- [ ] `channels$` emits all channel-related events with parsed data
- [ ] `users$` uses `distinctUntilChanged` to dedupe identical updates
- [ ] `users$` emits user updates and status changes
- [ ] `teams$` emits team membership changes
- [ ] `reactions$` throttles at 500ms to prevent UI spam
- [ ] `threads$` emits thread follow and read state changes
- [ ] `preferences$` emits preference updates
- [ ] `system$` emits connection and server events
- [ ] All streams end with `share()` for pipeline sharing
- [ ] All streams have proper TypeScript types
- [ ] All streams handle JSON parse errors gracefully
- [ ] No `any` types

## Testing

```typescript
// apps/v2/src/services/websocket/streams/posts$.spec.ts

import { TestScheduler } from "rxjs/testing";
import { posts$ } from "./posts$";

describe("posts$", () => {
  let scheduler: TestScheduler;

  beforeEach(() => {
    scheduler = new TestScheduler((actual, expected) => {
      expect(actual).toEqual(expected);
    });
  });

  it("batches posts within 100ms window", () => {
    scheduler.run(({ cold, expectObservable }) => {
      // Test batching behavior
      // ...
    });
  });

  it("parses post JSON correctly", () => {
    // Test JSON parsing
  });

  it("handles parse errors gracefully", () => {
    // Test error handling
  });
});
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- streams
```

## Notes

- Each stream is derived from `websocketService.events$` using `pipe()`
- Streams are lazy - no processing until subscribed
- JSON parsing is wrapped in try-catch to handle malformed data
- Broadcast metadata is used as fallback for IDs when not in data payload
- Type guards (`is` predicate functions) ensure type safety in filters
