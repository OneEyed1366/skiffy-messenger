# T5.01: useDidUpdate Hook

## Metadata

| Field        | Value           |
| ------------ | --------------- |
| **ID**       | T5.01           |
| **Layer**    | L5 - Pure Hooks |
| **Status**   | pending         |
| **Priority** | high            |
| **Estimate** | 0.5h            |
| **Parallel** | true            |
| **Assignee** | -               |
| **Created**  | 2026-01-04      |
| **Updated**  | 2026-01-04      |

## Dependencies

| Task ID | Name |
| ------- | ---- |
| -       | None |

## Blocks

| Task ID | Name                                        |
| ------- | ------------------------------------------- |
| T6.\*   | Base components that need update-only logic |
| T10c.\* | Components using update-only effects        |

## Description

Migrate the `useDidUpdate` hook from Mattermost. This hook behaves like `useEffect` but skips the initial render, only running on subsequent updates. This is the React hooks equivalent of `componentDidUpdate` from class components.

Common use cases:

- Restoring focus after a state change (not on initial mount)
- Triggering side effects only when props change after mount
- Avoiding initial API calls that should only happen on updates

## Source Files

- `vendor/desktop/webapp/channels/src/components/common/hooks/useDidUpdate.ts` (lines 1-21)

### Source Analysis

The original implementation:

```typescript
// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

import { useEffect, useRef } from "react";

const useDidUpdate: typeof useEffect = (effect, deps) => {
  const mounted = useRef(false);
  useEffect(() => {
    if (mounted.current) {
      return effect();
    }

    mounted.current = true;
  }, deps);
};

export default useDidUpdate;
```

Key observations:

- Uses `useRef` to track mount state across renders
- First render sets `mounted.current = true` without calling effect
- Subsequent renders call the effect and return cleanup function
- Type signature matches `useEffect` exactly (`typeof useEffect`)
- Supports cleanup functions (returns `effect()` result)
- Default export in source, will be named export in migration

### Usage Examples

From `vendor/desktop/webapp/channels/src/components/setting_item.tsx`:

```typescript
useDidUpdate(() => {
  // Restore focus to edit button when section closes
  // We don't want this on initial mount
  if (!active && areAllSectionsInactive) {
    minRef.current?.focus();
  }
}, [active]);
```

From `vendor/desktop/webapp/channels/src/components/advanced_text_editor/use_textbox_focus.tsx`:

```typescript
useDidUpdate(() => {
  // Only respond to channel changes after initial mount
  if (shouldFocusOnChange) {
    focusTextbox();
  }
}, [channelId]);
```

## Migration Target

- **Target File**: `apps/v2/src/hooks/useDidUpdate/useDidUpdate.ts`
- **Test File**: `apps/v2/src/hooks/useDidUpdate/useDidUpdate.spec.ts`
- **Index Export**: `apps/v2/src/hooks/useDidUpdate/index.ts`

## Implementation

```typescript
// apps/v2/src/hooks/useDidUpdate/useDidUpdate.ts

/**
 * useDidUpdate hook
 * Migrated from: vendor/desktop/webapp/channels/src/components/common/hooks/useDidUpdate.ts
 *
 * Like useEffect, but skips the initial render (componentDidUpdate behavior).
 * Useful when you need to run effects only when dependencies change after mount.
 */

import { useEffect, useRef } from "react";

//#region Types

type IEffectCallback = () => void | (() => void);

//#endregion Types

//#region Hook

/**
 * A hook that works like useEffect but skips the initial mount.
 * Only runs the effect callback when dependencies change after the first render.
 *
 * @param effect - Effect callback (can return cleanup function)
 * @param deps - Dependency array
 *
 * @example
 * // Restore focus only when `isOpen` changes (not on initial render)
 * useDidUpdate(() => {
 *   if (!isOpen) {
 *     buttonRef.current?.focus();
 *   }
 * }, [isOpen]);
 *
 * @example
 * // With cleanup function
 * useDidUpdate(() => {
 *   const subscription = api.subscribe(userId);
 *   return () => subscription.unsubscribe();
 * }, [userId]);
 */
export function useDidUpdate(
  effect: IEffectCallback,
  deps?: React.DependencyList,
): void {
  const isMounted = useRef(false);

  useEffect(() => {
    if (isMounted.current) {
      return effect();
    }

    isMounted.current = true;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);
}

//#endregion Hook
```

## Index Export

```typescript
// apps/v2/src/hooks/useDidUpdate/index.ts

export { useDidUpdate } from "./useDidUpdate";
```

## Hooks Index Update

Add to `apps/v2/src/hooks/index.ts`:

```typescript
export { useDidUpdate } from "./useDidUpdate";
```

## Acceptance Criteria

- [ ] Hook skips effect on initial mount
- [ ] Hook runs effect on subsequent updates when deps change
- [ ] Hook supports cleanup functions (returned from effect)
- [ ] Hook works with empty dependency array (never runs after mount)
- [ ] Hook works with undefined deps (runs on every update after mount)
- [ ] Hook works in React Native environment
- [ ] Uses `I` prefix for type definitions
- [ ] Named export (not default)
- [ ] TypeScript strict mode passes
- [ ] No `any` types
- [ ] No web-only APIs used
- [ ] Co-located tests pass

## Testing

```typescript
// apps/v2/src/hooks/useDidUpdate/useDidUpdate.spec.ts

import { renderHook } from "@testing-library/react-native";

import { useDidUpdate } from "./useDidUpdate";

//#region Mount Behavior Tests

describe("useDidUpdate", () => {
  describe("initial mount", () => {
    it("does not call effect on initial render", () => {
      const effect = jest.fn();

      renderHook(() => useDidUpdate(effect, []));

      expect(effect).not.toHaveBeenCalled();
    });

    it("does not call effect with undefined deps on initial render", () => {
      const effect = jest.fn();

      renderHook(() => useDidUpdate(effect, undefined));

      expect(effect).not.toHaveBeenCalled();
    });
  });

  describe("subsequent updates", () => {
    it("calls effect when deps change after mount", () => {
      const effect = jest.fn();

      const { rerender } = renderHook(
        ({ value }) => useDidUpdate(effect, [value]),
        { initialProps: { value: 1 } },
      );

      expect(effect).not.toHaveBeenCalled();

      rerender({ value: 2 });

      expect(effect).toHaveBeenCalledTimes(1);
    });

    it("calls effect multiple times on multiple updates", () => {
      const effect = jest.fn();

      const { rerender } = renderHook(
        ({ value }) => useDidUpdate(effect, [value]),
        { initialProps: { value: 1 } },
      );

      rerender({ value: 2 });
      rerender({ value: 3 });
      rerender({ value: 4 });

      expect(effect).toHaveBeenCalledTimes(3);
    });

    it("does not call effect when deps are the same", () => {
      const effect = jest.fn();

      const { rerender } = renderHook(
        ({ value }) => useDidUpdate(effect, [value]),
        { initialProps: { value: 1 } },
      );

      rerender({ value: 1 });
      rerender({ value: 1 });
      rerender({ value: 1 });

      expect(effect).not.toHaveBeenCalled();
    });
  });

  describe("cleanup function", () => {
    it("calls cleanup on subsequent updates", () => {
      const cleanup = jest.fn();
      const effect = jest.fn(() => cleanup);

      const { rerender } = renderHook(
        ({ value }) => useDidUpdate(effect, [value]),
        { initialProps: { value: 1 } },
      );

      // First update - effect runs, no cleanup yet
      rerender({ value: 2 });
      expect(cleanup).not.toHaveBeenCalled();

      // Second update - cleanup from previous effect runs
      rerender({ value: 3 });
      expect(cleanup).toHaveBeenCalledTimes(1);
    });

    it("calls cleanup on unmount after update", () => {
      const cleanup = jest.fn();
      const effect = jest.fn(() => cleanup);

      const { rerender, unmount } = renderHook(
        ({ value }) => useDidUpdate(effect, [value]),
        { initialProps: { value: 1 } },
      );

      // Trigger effect
      rerender({ value: 2 });

      // Unmount should call cleanup
      unmount();
      expect(cleanup).toHaveBeenCalledTimes(1);
    });

    it("does not call cleanup on unmount if effect never ran", () => {
      const cleanup = jest.fn();
      const effect = jest.fn(() => cleanup);

      const { unmount } = renderHook(() => useDidUpdate(effect, []));

      unmount();
      expect(cleanup).not.toHaveBeenCalled();
    });
  });

  describe("empty dependency array", () => {
    it("never runs effect with empty deps after mount", () => {
      const effect = jest.fn();

      const { rerender } = renderHook(() => useDidUpdate(effect, []));

      rerender({});
      rerender({});
      rerender({});

      expect(effect).not.toHaveBeenCalled();
    });
  });

  describe("multiple dependencies", () => {
    it("triggers on any dependency change", () => {
      const effect = jest.fn();

      const { rerender } = renderHook(
        ({ dep1, dep2 }) => useDidUpdate(effect, [dep1, dep2]),
        { initialProps: { dep1: 1, dep2: "a" } },
      );

      // Change first dep
      rerender({ dep1: 2, dep2: "a" });
      expect(effect).toHaveBeenCalledTimes(1);

      // Change second dep
      rerender({ dep1: 2, dep2: "b" });
      expect(effect).toHaveBeenCalledTimes(2);

      // Change both deps
      rerender({ dep1: 3, dep2: "c" });
      expect(effect).toHaveBeenCalledTimes(3);
    });
  });
});

//#endregion Mount Behavior Tests
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- useDidUpdate
```
