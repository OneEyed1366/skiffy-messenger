# T4.08: Number Formatting Utilities

## Metadata

| Field        | Value                 |
| ------------ | --------------------- |
| **ID**       | T4.08                 |
| **Layer**    | L4 - Formatting Utils |
| **Status**   | pending               |
| **Priority** | medium                |
| **Estimate** | 1h                    |
| **Parallel** | true                  |
| **Assignee** | -                     |
| **Created**  | 2026-01-04            |
| **Updated**  | 2026-01-04            |

## Dependencies

| Task ID | Name            |
| ------- | --------------- |
| T4.07   | File Size Utils |

## Blocks

| Task ID | Name                                |
| ------- | ----------------------------------- |
| T6.02   | component-badge (for count display) |
| T6.\*   | Components displaying metrics       |

## Description

Migrate and enhance number formatting utilities from Mattermost. The original codebase uses basic implementations like `inK()` for compact notation and `toUsagePercent()` for percentage calculations. Replace with `Intl.NumberFormat` for proper internationalization support.

## Source Files

- `vendor/desktop/webapp/channels/src/utils/limits.tsx` (lines 10-21)
- `vendor/desktop/webapp/channels/src/utils/utils.tsx` (lines 1105-1127, 1574-1598)

### Original Implementations

```typescript
// limits.tsx - Compact notation (basic)
export function inK(num: number): string {
  return `${Math.floor(num / 1000)}K`;
}

// limits.tsx - Percentage calculation
export function toUsagePercent(usage: number, limit: number): number {
  return Math.floor((usage / limit) * 100);
}

// utils.tsx - File size formatting
export function fileSizeToString(bytes: number) {
  if (bytes > 1024 ** 4) {
    if (bytes < 1024 ** 4 * 10) {
      return Math.round((bytes / 1024 ** 4) * 10) / 10 + "TB";
    }
    return Math.round(bytes / 1024 ** 4) + "TB";
  } else if (bytes > 1024 ** 3) {
    // ... similar pattern for GB, MB, KB
  }
  return bytes + "B";
}

// utils.tsx - Dynamic decimal places
export function numberToFixedDynamic(num: number, places: number): string {
  const str = num.toFixed(Math.max(places, 0));
  if (!str.includes(".")) {
    return str;
  }
  let indexToExclude = -1;
  let i = str.length - 1;
  while (str[i] === "0") {
    indexToExclude = i;
    i -= 1;
  }
  if (str[i] === ".") {
    indexToExclude -= 1;
  }
  if (indexToExclude === -1) {
    return str;
  }
  return str.slice(0, indexToExclude);
}
```

## Target File

`apps/v2/src/utils/number/number.ts`

## Implementation

```typescript
// apps/v2/src/utils/number/number.ts

type ILocale = string;

/**
 * Formats a number using compact notation (K, M, B, T).
 * Uses Intl.NumberFormat for proper internationalization.
 *
 * @param value - The number to format
 * @param locale - Optional locale (defaults to 'en')
 * @param maximumFractionDigits - Maximum fraction digits (defaults to 1)
 * @returns Formatted string (e.g., "1.2M", "456K")
 *
 * @example
 * formatCompact(1234567);      // => "1.2M"
 * formatCompact(1234);         // => "1.2K"
 * formatCompact(999);          // => "999"
 * formatCompact(1500000000);   // => "1.5B"
 */
export function formatCompact(
  value: number,
  locale: ILocale = "en",
  maximumFractionDigits = 1,
): string {
  return new Intl.NumberFormat(locale, {
    notation: "compact",
    compactDisplay: "short",
    maximumFractionDigits,
  }).format(value);
}

/**
 * Formats a decimal number as a percentage string.
 * Uses Intl.NumberFormat for proper internationalization.
 *
 * @param value - The decimal value (0.456 = 45.6%)
 * @param locale - Optional locale (defaults to 'en')
 * @param minimumFractionDigits - Minimum fraction digits (defaults to 0)
 * @param maximumFractionDigits - Maximum fraction digits (defaults to 1)
 * @returns Formatted percentage string (e.g., "45.6%")
 *
 * @example
 * formatPercentage(0.456);     // => "45.6%"
 * formatPercentage(0.5);       // => "50%"
 * formatPercentage(1);         // => "100%"
 * formatPercentage(0.123, 'de'); // => "12,3 %"
 */
export function formatPercentage(
  value: number,
  locale: ILocale = "en",
  minimumFractionDigits = 0,
  maximumFractionDigits = 1,
): string {
  return new Intl.NumberFormat(locale, {
    style: "percent",
    minimumFractionDigits,
    maximumFractionDigits,
  }).format(value);
}

/**
 * Formats a number as currency.
 * Uses Intl.NumberFormat for proper internationalization.
 *
 * @param amount - The amount to format
 * @param currency - ISO 4217 currency code (e.g., "USD", "EUR")
 * @param locale - Optional locale (defaults to 'en-US')
 * @returns Formatted currency string (e.g., "$1,234.56")
 *
 * @example
 * formatCurrency(1234.56, 'USD');           // => "$1,234.56"
 * formatCurrency(1234.56, 'EUR', 'de-DE');  // => "1.234,56 EUR"
 * formatCurrency(1234.56, 'JPY', 'ja-JP');  // => "JPY 1,235"
 */
export function formatCurrency(
  amount: number,
  currency: string,
  locale: ILocale = "en-US",
): string {
  return new Intl.NumberFormat(locale, {
    style: "currency",
    currency,
  }).format(amount);
}

const ORDINAL_RULES_EN: Record<string, string> = {
  one: "st",
  two: "nd",
  few: "rd",
  other: "th",
};

/**
 * Formats a number as an ordinal (1st, 2nd, 3rd, etc.).
 * Uses Intl.PluralRules for proper internationalization.
 *
 * @param value - The number to format
 * @param locale - Optional locale (defaults to 'en')
 * @returns Formatted ordinal string (e.g., "1st", "2nd", "3rd")
 *
 * @example
 * formatOrdinal(1);   // => "1st"
 * formatOrdinal(2);   // => "2nd"
 * formatOrdinal(3);   // => "3rd"
 * formatOrdinal(4);   // => "4th"
 * formatOrdinal(11);  // => "11th"
 * formatOrdinal(21);  // => "21st"
 */
export function formatOrdinal(value: number, locale: ILocale = "en"): string {
  const pluralRules = new Intl.PluralRules(locale, { type: "ordinal" });
  const rule = pluralRules.select(value);
  const suffix = ORDINAL_RULES_EN[rule] ?? "th";
  return `${value}${suffix}`;
}

/**
 * Formats a number with a specified number of decimal places,
 * removing trailing zeros.
 *
 * @param num - The number to format
 * @param places - Maximum decimal places
 * @returns Formatted number string
 *
 * @example
 * formatDynamic(3.12345, 4);  // => "3.1235"
 * formatDynamic(3.01000, 4);  // => "3.01"
 * formatDynamic(3.01000, 1);  // => "3"
 * formatDynamic(3.00000, 2);  // => "3"
 */
export function formatDynamic(num: number, places: number): string {
  const str = num.toFixed(Math.max(places, 0));

  if (!str.includes(".")) {
    return str;
  }

  // Remove trailing zeros and unnecessary decimal point
  return str.replace(/\.?0+$/, "");
}

// NOTE: formatFileSize is defined in @/utils/file-size (T4.07)
// which is the canonical location for file size formatting.
// Import from there if needed in number-related contexts:
//
// import { formatFileSize } from "@/utils/file-size";
//
// This file focuses on general number formatting (compact, percentage, currency, ordinal)
```

## Index Export

```typescript
// apps/v2/src/utils/number/index.ts

export {
  formatCompact,
  formatCurrency,
  formatDynamic,
  formatOrdinal,
  formatPercentage,
} from "./number";

// NOTE: formatFileSize is in @/utils/file-size (T4.07) - not duplicated here
```

```typescript
// apps/v2/src/utils/index.ts (add to existing exports)

// From T4.08 (number formatting)
export {
  formatCompact,
  formatCurrency,
  formatDynamic,
  formatOrdinal,
  formatPercentage,
} from "./number";

// From T4.07 (file size formatting) - separate module
export { formatFileSize, parseFileSize } from "./file-size";
```

## Acceptance Criteria

- [ ] Uses `Intl.NumberFormat` for compact, percentage, and currency formatting
- [ ] Uses `Intl.PluralRules` for ordinal formatting
- [ ] All functions support locale parameter for i18n
- [ ] `formatCompact(1234567)` returns "1.2M"
- [ ] `formatPercentage(0.456)` returns "45.6%"
- [ ] `formatCurrency(1234.56, 'USD')` returns "$1,234.56"
- [ ] `formatOrdinal(1)` returns "1st"
- [ ] Exported from `utils/index.ts`
- [ ] TypeScript strict mode passes
- [ ] No `any` types

## Testing

```typescript
// apps/v2/src/utils/number/number.spec.ts

import {
  formatCompact,
  formatCurrency,
  formatDynamic,
  formatOrdinal,
  formatPercentage,
} from "./number";

// NOTE: formatFileSize tests are in T4.07 (utils/file-size/file-size.spec.ts)

describe("formatCompact", () => {
  it("formats thousands as K", () => {
    expect(formatCompact(1234)).toBe("1.2K");
    expect(formatCompact(1000)).toBe("1K");
    expect(formatCompact(9999)).toBe("10K");
  });

  it("formats millions as M", () => {
    expect(formatCompact(1234567)).toBe("1.2M");
    expect(formatCompact(1000000)).toBe("1M");
  });

  it("formats billions as B", () => {
    expect(formatCompact(1500000000)).toBe("1.5B");
  });

  it("keeps small numbers unchanged", () => {
    expect(formatCompact(999)).toBe("999");
    expect(formatCompact(0)).toBe("0");
  });

  it("respects maximumFractionDigits", () => {
    expect(formatCompact(1234567, "en", 2)).toBe("1.23M");
    expect(formatCompact(1234567, "en", 0)).toBe("1M");
  });
});

describe("formatPercentage", () => {
  it("formats decimal as percentage", () => {
    expect(formatPercentage(0.456)).toBe("45.6%");
    expect(formatPercentage(0.5)).toBe("50%");
    expect(formatPercentage(1)).toBe("100%");
  });

  it("handles zero", () => {
    expect(formatPercentage(0)).toBe("0%");
  });

  it("handles values over 100%", () => {
    expect(formatPercentage(1.5)).toBe("150%");
  });

  it("respects fraction digits options", () => {
    expect(formatPercentage(0.4567, "en", 2, 2)).toBe("45.67%");
  });
});

describe("formatCurrency", () => {
  it("formats USD correctly", () => {
    expect(formatCurrency(1234.56, "USD")).toBe("$1,234.56");
    expect(formatCurrency(0, "USD")).toBe("$0.00");
  });

  it("formats EUR with German locale", () => {
    const result = formatCurrency(1234.56, "EUR", "de-DE");
    // German uses comma for decimal, period for thousands
    expect(result).toMatch(/1\.234,56/);
    expect(result).toContain("EUR");
  });

  it("handles negative amounts", () => {
    expect(formatCurrency(-1234.56, "USD")).toMatch(/-?\$1,234\.56/);
  });
});

describe("formatOrdinal", () => {
  it("formats 1st, 2nd, 3rd correctly", () => {
    expect(formatOrdinal(1)).toBe("1st");
    expect(formatOrdinal(2)).toBe("2nd");
    expect(formatOrdinal(3)).toBe("3rd");
  });

  it("formats 4th and beyond correctly", () => {
    expect(formatOrdinal(4)).toBe("4th");
    expect(formatOrdinal(10)).toBe("10th");
    expect(formatOrdinal(100)).toBe("100th");
  });

  it("handles teen numbers correctly", () => {
    expect(formatOrdinal(11)).toBe("11th");
    expect(formatOrdinal(12)).toBe("12th");
    expect(formatOrdinal(13)).toBe("13th");
  });

  it("handles 21st, 22nd, 23rd pattern", () => {
    expect(formatOrdinal(21)).toBe("21st");
    expect(formatOrdinal(22)).toBe("22nd");
    expect(formatOrdinal(23)).toBe("23rd");
  });
});

describe("formatDynamic", () => {
  it("removes trailing zeros", () => {
    expect(formatDynamic(3.01, 4)).toBe("3.01");
    expect(formatDynamic(3.1, 4)).toBe("3.1");
    expect(formatDynamic(3.0, 4)).toBe("3");
  });

  it("respects decimal places limit", () => {
    expect(formatDynamic(3.12345, 4)).toBe("3.1235");
    expect(formatDynamic(3.12345, 2)).toBe("3.12");
  });

  it("handles integers", () => {
    expect(formatDynamic(3, 4)).toBe("3");
    expect(formatDynamic(100, 2)).toBe("100");
  });
});

// NOTE: formatFileSize tests are located in:
// apps/v2/src/utils/file-size/file-size.spec.ts (T4.07)
// Do not duplicate tests here - import from @/utils/file-size if needed
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- number.spec
```
