# T8.01: WebSocket Service

## Metadata

| Field        | Value               |
| ------------ | ------------------- |
| **ID**       | T8.01               |
| **Layer**    | L8 - WebSocket RxJS |
| **Status**   | pending             |
| **Priority** | high                |
| **Estimate** | 4h                  |
| **Parallel** | -                   |
| **Assignee** | -                   |
| **Created**  | 2026-01-04          |
| **Updated**  | 2026-01-05          |

## Dependencies

| Task ID | Name               |
| ------- | ------------------ |
| T7.30   | useConnectionStore |

## Blocks

| Task ID | Name              |
| ------- | ----------------- |
| T8.02   | Event Stream Defs |
| T9.\*   | All state hooks   |

## Description

Create the core RxJS WebSocket service that manages the WebSocket connection with automatic reconnection using exponential backoff. This service provides a shared observable (`events$`) that all event streams in T8.02 will derive from.

The service integrates with `useWebSocketStore` (T7.08) to update connection state, but handles all WebSocket logic (connect, disconnect, reconnect, send) internally using RxJS.

## Source Files

- `vendor/desktop/webapp/platform/client/src/websocket.ts` (lines 1-692)
- `vendor/desktop/webapp/channels/src/actions/websocket_actions.jsx` (lines 140-230)

### Source Analysis

The vendor implementation features:

- **Reconnect backoff (n² formula)**: Constant delay until `maxWebSocketFails`, then `n²` growth
  ```javascript
  // vendor/desktop/webapp/platform/client/src/websocket.ts:244-249
  let retryTime = this.config.minWebSocketRetryTime; // 3000ms
  if (this.connectFailCount > this.config.maxWebSocketFails) {
    retryTime = retryTime * this.connectFailCount * this.connectFailCount; // n²
    if (retryTime > this.config.maxWebSocketRetryTime) {
      retryTime = this.config.maxWebSocketRetryTime; // 300000ms (5 min)
    }
  }
  retryTime += Math.random() * this.config.reconnectJitterRange; // 0-2000ms
  ```
- **Config defaults** (from `defaultWebSocketClientConfig`):
  - `maxWebSocketFails`: 7
  - `minWebSocketRetryTime`: 3000ms (3 seconds)
  - `maxWebSocketRetryTime`: 300000ms (5 minutes)
  - `reconnectJitterRange`: 2000ms
  - `clientPingInterval`: 30000ms (30 seconds)
- **Ping/pong heartbeat**: 30-second interval
- **Sequence tracking**: `serverSequence` for missed event detection
- **Connection ID change detection**: Triggers full state refresh

**Backoff comparison:**

| Retry | Vendor (constant, then n²)     | Previous (2^n)                |
| ----- | ------------------------------ | ----------------------------- |
| 1-7   | 3000ms + jitter                | 1s, 2s, 4s, 8s, 16s, 30s, 30s |
| 8     | 3000 × 64 = 192s → capped 300s | 30s                           |
| 9     | 3000 × 81 = 243s               | 30s                           |
| 10    | 3000 × 100 = 300s (capped)     | 30s                           |

## Migration Target

- **Target File**: `apps/v2/src/services/websocket/socket.ts`
- **Index Export**: `apps/v2/src/services/websocket/index.ts`

## Implementation

```typescript
// apps/v2/src/services/websocket/socket.ts

import { webSocket, WebSocketSubject } from "rxjs/webSocket";
import {
  Subject,
  Observable,
  timer,
  EMPTY,
  catchError,
  retry,
  share,
  tap,
  takeUntil,
} from "rxjs";
import { useConnectionStore } from "@/stores/connection";

//#region Types

export type IWebSocketConfig = {
  /** WebSocket server URL (without protocol) */
  url: string;
  /** Authentication token */
  token: string;
  /** Max reconnection attempts (default: 7) */
  reconnectAttempts?: number;
  /** Initial reconnection delay in ms (default: 1000) */
  reconnectDelay?: number;
  /** Max reconnection delay in ms (default: 30000) */
  reconnectDelayMax?: number;
  /** Jitter range in ms (default: 2000) */
  reconnectJitter?: number;
};

export type IWebSocketEvent<T = unknown> = {
  /** Event type name */
  event: string;
  /** Event payload */
  data: T;
  /** Sequence number for ordering */
  seq: number;
  /** Broadcast metadata */
  broadcast?: {
    channel_id?: string;
    team_id?: string;
    user_id?: string;
    omit_users?: Record<string, boolean>;
  };
};

//#endregion Types

//#region Constants

const DEFAULT_CONFIG: Required<Omit<IWebSocketConfig, "url" | "token">> = {
  reconnectAttempts: 7,
  reconnectDelay: 3000, // Vendor: minWebSocketRetryTime = 3000ms
  reconnectDelayMax: 300000, // Vendor: maxWebSocketRetryTime = 300000ms (5 min)
  reconnectJitter: 2000, // Vendor: reconnectJitterRange = 2000ms
};

//#endregion Constants

//#region WebSocket Service

class WebSocketService {
  private socket$: WebSocketSubject<IWebSocketEvent> | null = null;
  private destroy$ = new Subject<void>();
  private config: IWebSocketConfig & typeof DEFAULT_CONFIG = {
    url: "",
    token: "",
    ...DEFAULT_CONFIG,
  };

  /** Main event stream - shared across all subscribers */
  public events$: Observable<IWebSocketEvent> = EMPTY;

  /**
   * Connect to WebSocket server.
   * @param config Connection configuration
   * @returns Observable of WebSocket events
   */
  connect(config: IWebSocketConfig): Observable<IWebSocketEvent> {
    this.config = { ...DEFAULT_CONFIG, ...config };
    const store = useConnectionStore.getState();

    // Reset destroy subject for new connection
    this.destroy$ = new Subject<void>();

    store.setConnectionState("connecting");

    this.socket$ = webSocket<IWebSocketEvent>({
      url: `${this.config.url}?token=${this.config.token}`,
      openObserver: {
        next: () => {
          store.resetReconnect();
          console.log("[WS] Connected");
        },
      },
      closeObserver: {
        next: (event) => {
          store.setConnectionState("disconnected");
          console.log("[WS] Disconnected:", event.code, event.reason);
        },
      },
      deserializer: (e) => JSON.parse(e.data),
      serializer: (value) => JSON.stringify(value),
    });

    this.events$ = this.socket$.pipe(
      tap((msg) => {
        // Track sequence for missed event detection
        if (msg.seq) {
          store.setLastEventId(String(msg.seq));
        }

        // Handle connection ID from 'hello' event
        if (msg.event === "hello" && msg.data) {
          const data = msg.data as { connection_id?: string };
          if (data.connection_id) {
            store.setConnectionId(data.connection_id);
          }
        }
      }),
      retry({
        count: this.config.reconnectAttempts,
        delay: (error, retryCount) => {
          store.setConnectionState("reconnecting");
          store.incrementReconnectAttempts();

          // Vendor formula: constant delay until maxFails, then n² growth
          // See: vendor/desktop/webapp/platform/client/src/websocket.ts:244-249
          let retryTime = this.config.reconnectDelay; // 3000ms base

          if (retryCount > this.config.reconnectAttempts) {
            // After max fails: n² backoff
            retryTime = retryTime * retryCount * retryCount;
            if (retryTime > this.config.reconnectDelayMax) {
              retryTime = this.config.reconnectDelayMax; // Cap at 5 min
            }
          }

          // Jitter to avoid thundering herd
          const jitter = Math.random() * this.config.reconnectJitter;
          const totalDelay = retryTime + jitter;

          console.log(
            `[WS] Retry ${retryCount}/${this.config.reconnectAttempts} in ${Math.round(totalDelay)}ms`,
          );
          return timer(totalDelay);
        },
      }),
      catchError((error) => {
        store.setConnectionState("disconnected");
        console.error("[WS] Connection failed after all retries:", error);
        return EMPTY;
      }),
      takeUntil(this.destroy$),
      share(), // Share single connection across all subscribers
    );

    // Start the connection by subscribing
    this.events$.subscribe();

    return this.events$;
  }

  /**
   * Send a message through the WebSocket.
   * @param event Event type name
   * @param data Event payload
   */
  send<T>(event: string, data: T): void {
    if (!this.socket$ || !this.isConnected()) {
      console.warn("[WS] Cannot send - not connected");
      return;
    }
    this.socket$.next({ event, data, seq: 0 } as IWebSocketEvent<T>);
  }

  /**
   * Check if currently connected.
   */
  isConnected(): boolean {
    return useConnectionStore.getState().status === "connected";
  }

  /**
   * Disconnect from WebSocket server.
   */
  disconnect(): void {
    this.destroy$.next();
    this.destroy$.complete();
    this.socket$?.complete();
    this.socket$ = null;
    useConnectionStore.getState().setStatus("disconnected");
    console.log("[WS] Disconnected by client");
  }

  /**
   * Reconnect to WebSocket server (manual trigger).
   */
  reconnect(): void {
    if (this.config.url && this.config.token) {
      this.disconnect();
      this.connect(this.config);
    }
  }
}

/** Singleton WebSocket service instance */
export const websocketService = new WebSocketService();

//#endregion WebSocket Service
```

## Index Export

```typescript
// apps/v2/src/services/websocket/index.ts

export { websocketService } from "./socket";
export type { IWebSocketConfig, IWebSocketEvent } from "./socket";

// Event streams (from T8.02)
export * from "./streams";
```

## Acceptance Criteria

- [ ] `websocketService.connect()` establishes WebSocket connection
- [ ] `websocketService.disconnect()` cleanly closes connection
- [ ] `websocketService.send()` sends messages through socket
- [ ] `websocketService.events$` emits all received events
- [ ] Auto-reconnect with vendor n² backoff (3s constant for first 7, then n² growth)
- [ ] Jitter added to reconnection delays (0-2000ms random)
- [ ] Max reconnect delay capped at 300000ms (5 minutes)
- [ ] Max 7 reconnection attempts before giving up
- [ ] Connection state updates in `useWebSocketStore`
- [ ] Sequence number tracking via `setLastEventId`
- [ ] Connection ID captured from 'hello' event
- [ ] `share()` operator ensures single connection for multiple subscribers
- [ ] Clean unsubscription via `takeUntil(destroy$)`
- [ ] TypeScript strict mode passes
- [ ] No `any` types

## Testing

```typescript
// apps/v2/src/services/websocket/socket.spec.ts

import { Subject } from "rxjs";
import { websocketService, IWebSocketEvent } from "./socket";
import { useConnectionStore } from "@/stores/connection";

//#region Mocks

// Mock rxjs/webSocket
jest.mock("rxjs/webSocket", () => ({
  webSocket: jest.fn(() => {
    const subject = new Subject<IWebSocketEvent>();
    return Object.assign(subject, {
      next: jest.fn((value) => subject.next(value)),
      complete: jest.fn(() => subject.complete()),
    });
  }),
}));

//#endregion Mocks

//#region Tests

describe("WebSocketService", () => {
  beforeEach(() => {
    useConnectionStore.getState().reset();
  });

  describe("connect", () => {
    it("sets connection state to connecting", () => {
      websocketService.connect({
        url: "wss://test.com/ws",
        token: "test-token",
      });

      // Initial state should be connecting
      expect(useConnectionStore.getState().status).toBe("connecting");
    });

    it("returns events$ observable", () => {
      const events$ = websocketService.connect({
        url: "wss://test.com/ws",
        token: "test-token",
      });

      expect(events$).toBeDefined();
      expect(typeof events$.subscribe).toBe("function");
    });
  });

  describe("disconnect", () => {
    it("sets connection state to idle", () => {
      websocketService.connect({
        url: "wss://test.com/ws",
        token: "test-token",
      });

      websocketService.disconnect();

      expect(useConnectionStore.getState().status).toBe("disconnected");
    });
  });

  describe("isConnected", () => {
    it("returns false when disconnected", () => {
      expect(websocketService.isConnected()).toBe(false);
    });
  });
});

//#endregion Tests
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- socket.spec
```

## Notes

- Uses `rxjs/webSocket` which is a thin wrapper around native WebSocket
- The `share()` operator is critical - ensures single connection even with multiple subscribers
- Connection state is managed by `useConnectionStore` (T7.30) but all logic is in this service
- Sequence numbers from server are tracked for missed event detection (used in reconnect)
- The 'hello' event from server contains connection_id used for session tracking
