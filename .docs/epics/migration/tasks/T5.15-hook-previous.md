# T5.15: usePrevious Hook

## Metadata

| Field        | Value      |
| ------------ | ---------- |
| **ID**       | T5.15      |
| **Layer**    | L5 - Hooks |
| **Status**   | pending    |
| **Priority** | medium     |
| **Estimate** | 0.5h       |
| **Parallel** | true       |
| **Assignee** | -          |
| **Created**  | 2026-01-06 |
| **Updated**  | 2026-01-06 |

## Dependencies

| Task ID | Name |
| ------- | ---- |
| None    | -    |

## Blocks

| Task ID | Name                 |
| ------- | -------------------- |
| T6.\*   | Animation components |
| T9.\*   | Comparison hooks     |

## Description

Get the previous value of a state or prop. Commonly used for comparison effects and animations.

**Note:** Not found in vendor codebase - standard React pattern.

## Migration Target

- **Target File**: `apps/v2/src/hooks/usePrevious/usePrevious.ts`
- **Index Export**: `apps/v2/src/hooks/usePrevious/index.ts`

## Implementation

```typescript
// apps/v2/src/hooks/usePrevious/usePrevious.ts

/**
 * Previous value tracking hooks
 * Standard React patterns for accessing previous render values
 */

import { useEffect, useRef } from "react";

//#region usePrevious

/**
 * Returns the previous value of a state or prop
 *
 * @param value - Current value to track
 * @returns Previous value (undefined on first render)
 *
 * @example
 * const [count, setCount] = useState(0);
 * const prevCount = usePrevious(count);
 *
 * // First render: prevCount = undefined, count = 0
 * // After setCount(1): prevCount = 0, count = 1
 * // After setCount(5): prevCount = 1, count = 5
 *
 * @example
 * // Detect value changes for side effects
 * const prevStatus = usePrevious(status);
 * useEffect(() => {
 *   if (prevStatus === 'loading' && status === 'success') {
 *     showSuccessToast();
 *   }
 * }, [status, prevStatus]);
 */
export function usePrevious<T>(value: T): T | undefined {
  const ref = useRef<T | undefined>(undefined);

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
}

//#endregion usePrevious

//#region usePreviousWithInitial

/**
 * Returns the previous value with a specified initial value
 *
 * @param value - Current value to track
 * @param initialValue - Value to return on first render
 * @returns Previous value (initialValue on first render)
 *
 * @example
 * const prevCount = usePreviousWithInitial(count, 0);
 * // First render: prevCount = 0 (not undefined)
 * // After setCount(5): prevCount = 0
 * // After setCount(10): prevCount = 5
 */
export function usePreviousWithInitial<T>(value: T, initialValue: T): T {
  const ref = useRef<T>(initialValue);

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
}

//#endregion usePreviousWithInitial

//#region useHasChanged

/**
 * Check if a value has changed since last render
 *
 * @param value - Value to check
 * @param compareFn - Custom comparison function (default: Object.is)
 * @returns true if value changed, false otherwise
 *
 * @example
 * const userChanged = useHasChanged(user);
 * useEffect(() => {
 *   if (userChanged) {
 *     fetchUserData();
 *   }
 * }, [userChanged, user]);
 *
 * @example
 * // Custom comparison for objects
 * const userChanged = useHasChanged(user, (prev, curr) =>
 *   prev?.id !== curr?.id
 * );
 */
export function useHasChanged<T>(
  value: T,
  compareFn: (prev: T | undefined, curr: T) => boolean = (prev, curr) =>
    !Object.is(prev, curr),
): boolean {
  const prevValue = usePrevious(value);
  return compareFn(prevValue, value);
}

//#endregion useHasChanged

//#region useFirstRender

/**
 * Check if this is the first render
 *
 * @returns true on first render, false on subsequent renders
 *
 * @example
 * const isFirstRender = useFirstRender();
 * useEffect(() => {
 *   if (!isFirstRender) {
 *     // Skip effect on first render
 *     doSomething();
 *   }
 * }, [dependency]);
 */
export function useFirstRender(): boolean {
  const isFirst = useRef(true);

  useEffect(() => {
    isFirst.current = false;
  }, []);

  return isFirst.current;
}

//#endregion useFirstRender

//#region usePreviousDistinct

/**
 * Returns the previous distinct value (ignores duplicate consecutive values)
 *
 * @param value - Current value to track
 * @param compareFn - Equality check function (default: Object.is)
 * @returns Previous distinct value (undefined until value changes)
 *
 * @example
 * const [count, setCount] = useState(0);
 * const prevDistinct = usePreviousDistinct(count);
 *
 * // setCount(0) multiple times: prevDistinct remains undefined
 * // setCount(1): prevDistinct = 0
 * // setCount(1) again: prevDistinct = 0 (unchanged)
 * // setCount(2): prevDistinct = 1
 */
export function usePreviousDistinct<T>(
  value: T,
  compareFn: (a: T, b: T) => boolean = Object.is,
): T | undefined {
  const prevRef = useRef<T | undefined>(undefined);
  const currentRef = useRef<T>(value);

  if (!compareFn(currentRef.current, value)) {
    prevRef.current = currentRef.current;
    currentRef.current = value;
  }

  return prevRef.current;
}

//#endregion usePreviousDistinct
```

## Index Export

```typescript
// apps/v2/src/hooks/usePrevious/index.ts

export {
  usePrevious,
  usePreviousWithInitial,
  useHasChanged,
  useFirstRender,
  usePreviousDistinct,
} from "./usePrevious";
```

## Acceptance Criteria

- [ ] `usePrevious` returns undefined on first render
- [ ] `usePreviousWithInitial` returns specified initial value
- [ ] `useHasChanged` returns boolean for value changes
- [ ] `useFirstRender` returns true only on first render
- [ ] `usePreviousDistinct` ignores duplicate consecutive values
- [ ] Works with all value types (primitives, objects, arrays)
- [ ] All types use `I` prefix naming convention
- [ ] TypeScript strict mode passes
- [ ] No `any` types

## Testing

```typescript
// apps/v2/src/hooks/usePrevious/usePrevious.spec.ts

import { renderHook } from "@testing-library/react-native";

import {
  usePrevious,
  usePreviousWithInitial,
  useHasChanged,
  useFirstRender,
  usePreviousDistinct,
} from "./usePrevious";

//#region usePrevious Tests

describe("usePrevious", () => {
  it("returns undefined on first render", () => {
    const { result } = renderHook(() => usePrevious(1));
    expect(result.current).toBeUndefined();
  });

  it("returns previous value after update", () => {
    const { result, rerender } = renderHook(({ value }) => usePrevious(value), {
      initialProps: { value: 1 },
    });

    expect(result.current).toBeUndefined();

    rerender({ value: 2 });
    expect(result.current).toBe(1);

    rerender({ value: 3 });
    expect(result.current).toBe(2);
  });

  it("works with objects", () => {
    const obj1 = { a: 1 };
    const obj2 = { a: 2 };

    const { result, rerender } = renderHook(({ value }) => usePrevious(value), {
      initialProps: { value: obj1 },
    });

    rerender({ value: obj2 });
    expect(result.current).toBe(obj1);
  });

  it("works with null and undefined", () => {
    const { result, rerender } = renderHook(({ value }) => usePrevious(value), {
      initialProps: { value: null as string | null },
    });

    rerender({ value: "hello" });
    expect(result.current).toBeNull();

    rerender({ value: null });
    expect(result.current).toBe("hello");
  });
});

//#endregion usePrevious Tests

//#region usePreviousWithInitial Tests

describe("usePreviousWithInitial", () => {
  it("returns initial value on first render", () => {
    const { result } = renderHook(() => usePreviousWithInitial(5, 0));
    expect(result.current).toBe(0);
  });

  it("returns previous value after update", () => {
    const { result, rerender } = renderHook(
      ({ value }) => usePreviousWithInitial(value, 0),
      { initialProps: { value: 5 } },
    );

    expect(result.current).toBe(0);

    rerender({ value: 10 });
    expect(result.current).toBe(5);
  });
});

//#endregion usePreviousWithInitial Tests

//#region useHasChanged Tests

describe("useHasChanged", () => {
  it("returns false on first render", () => {
    const { result } = renderHook(() => useHasChanged(1));
    // First render compares undefined with 1, which is a change
    expect(result.current).toBe(true);
  });

  it("returns true when value changes", () => {
    const { result, rerender } = renderHook(
      ({ value }) => useHasChanged(value),
      { initialProps: { value: 1 } },
    );

    rerender({ value: 2 });
    expect(result.current).toBe(true);
  });

  it("returns false when value stays same", () => {
    const { result, rerender } = renderHook(
      ({ value }) => useHasChanged(value),
      { initialProps: { value: 1 } },
    );

    rerender({ value: 1 });
    expect(result.current).toBe(false);
  });

  it("supports custom comparison function", () => {
    const compare = (prev: { id: number } | undefined, curr: { id: number }) =>
      prev?.id !== curr.id;

    const { result, rerender } = renderHook(
      ({ value }) => useHasChanged(value, compare),
      { initialProps: { value: { id: 1, name: "a" } } },
    );

    // Same id, different name
    rerender({ value: { id: 1, name: "b" } });
    expect(result.current).toBe(false);

    // Different id
    rerender({ value: { id: 2, name: "b" } });
    expect(result.current).toBe(true);
  });
});

//#endregion useHasChanged Tests

//#region useFirstRender Tests

describe("useFirstRender", () => {
  it("returns true on first render", () => {
    const { result } = renderHook(() => useFirstRender());
    expect(result.current).toBe(true);
  });

  it("returns false on subsequent renders", () => {
    const { result, rerender } = renderHook(() => useFirstRender());

    expect(result.current).toBe(true);

    rerender();
    expect(result.current).toBe(false);

    rerender();
    expect(result.current).toBe(false);
  });
});

//#endregion useFirstRender Tests

//#region usePreviousDistinct Tests

describe("usePreviousDistinct", () => {
  it("returns undefined until value changes", () => {
    const { result, rerender } = renderHook(
      ({ value }) => usePreviousDistinct(value),
      { initialProps: { value: 1 } },
    );

    expect(result.current).toBeUndefined();

    // Same value
    rerender({ value: 1 });
    expect(result.current).toBeUndefined();
  });

  it("returns previous distinct value after change", () => {
    const { result, rerender } = renderHook(
      ({ value }) => usePreviousDistinct(value),
      { initialProps: { value: 1 } },
    );

    rerender({ value: 2 });
    expect(result.current).toBe(1);

    // Same value again
    rerender({ value: 2 });
    expect(result.current).toBe(1);

    rerender({ value: 3 });
    expect(result.current).toBe(2);
  });

  it("supports custom comparison", () => {
    const compare = (a: { id: number }, b: { id: number }) => a.id === b.id;

    const { result, rerender } = renderHook(
      ({ value }) => usePreviousDistinct(value, compare),
      { initialProps: { value: { id: 1, name: "a" } } },
    );

    // Same id, different object
    rerender({ value: { id: 1, name: "b" } });
    expect(result.current).toBeUndefined();

    // Different id
    rerender({ value: { id: 2, name: "c" } });
    expect(result.current).toEqual({ id: 1, name: "b" });
  });
});

//#endregion usePreviousDistinct Tests
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- usePrevious
```
