# T9.18: useSearchQuery Hook

## Metadata

| Field        | Value            |
| ------------ | ---------------- |
| **ID**       | T9.18            |
| **Layer**    | L9 - State Hooks |
| **Status**   | pending          |
| **Priority** | medium           |
| **Estimate** | 2h               |
| **Parallel** | true             |
| **Assignee** | -                |
| **Created**  | 2026-01-06       |
| **Updated**  | 2026-01-07       |

## Dependencies

| Task ID | Name        |
| ------- | ----------- |
| T7.01   | API Client  |
| T7.02   | QueryClient |
| T7.03   | Query Keys  |

## Description

Create a TanStack Query hook for search functionality. Uses `useQuery` with manual refetch
trigger (enabled: false initially). Local state for query/filters is managed separately.

**Architecture Note:** Search results are server state (from REST API). Local UI state
(query string, filters) is managed with useState. See `.docs/architecture/state-management.md`.

## Source Analysis

- **Redux Actions**: `vendor/desktop/webapp/channels/src/actions/views/search.ts`
- **API Endpoint**: `POST /api/v4/teams/{team_id}/posts/search`

## Migration Target

- **Target File**: `apps/v2/src/hooks/useSearchQuery/useSearchQuery.ts`
- **Index Export**: `apps/v2/src/hooks/useSearchQuery/index.ts`

## Implementation

````typescript
// apps/v2/src/hooks/useSearchQuery/useSearchQuery.ts

import { useState } from "react";
import { useQuery, UseQueryOptions } from "@tanstack/react-query";
import { searchApi } from "@/api/search";
import { queryKeys } from "@/queries/keys";
import type { IPost, ISearchParams, ISearchResults } from "@/types";

//#region Types

type ISearchFilters = {
  from?: string;
  in?: string;
  on?: string;
  before?: string;
  after?: string;
  ext?: string;
};

type IUseSearchQueryOptions = Omit<
  UseQueryOptions<ISearchResults, Error>,
  "queryKey" | "queryFn" | "enabled"
>;

//#endregion Types

//#region Helpers

function buildSearchQuery(query: string, filters: ISearchFilters): string {
  let searchQuery = query;

  if (filters.from) searchQuery += ` from:${filters.from}`;
  if (filters.in) searchQuery += ` in:${filters.in}`;
  if (filters.on) searchQuery += ` on:${filters.on}`;
  if (filters.before) searchQuery += ` before:${filters.before}`;
  if (filters.after) searchQuery += ` after:${filters.after}`;
  if (filters.ext) searchQuery += ` ext:${filters.ext}`;

  return searchQuery.trim();
}

//#endregion Helpers

//#region Query Hook

/**
 * Fetches search results using TanStack Query.
 * Query is disabled by default - use `refetch()` to execute search.
 *
 * @param teamId - Team ID to search within
 * @param searchQuery - Search query string with filters applied
 * @param options - TanStack Query options
 * @returns Query result with data, isLoading, error, refetch, etc.
 *
 * @example
 * ```tsx
 * function SearchResults({ teamId, query }: { teamId: string; query: string }) {
 *   const { data, isLoading, refetch } = useSearchQuery(teamId, query, {
 *     enabled: false,
 *   });
 *
 *   const handleSearch = () => refetch();
 *
 *   return (
 *     <>
 *       <Button onPress={handleSearch}>Search</Button>
 *       {data?.posts.map((post) => <PostItem key={post.id} post={post} />)}
 *     </>
 *   );
 * }
 * ```
 */
export function useSearchQuery(
  teamId: string | null | undefined,
  searchQuery: string,
  options?: IUseSearchQueryOptions,
) {
  return useQuery({
    queryKey: queryKeys.posts.search(searchQuery, { teamId: teamId! }),
    queryFn: () =>
      searchApi.searchPosts(teamId!, {
        terms: searchQuery,
        is_or_search: false,
      }),
    enabled: false, // Manual trigger via refetch()
    staleTime: 1000 * 60 * 5, // Cache for 5 minutes
    ...options,
  });
}

//#endregion Query Hook

//#region Combined Hook

/**
 * Convenience hook that combines search state and query.
 * Manages query string, filters, and provides search execution.
 *
 * @param teamId - Team ID to search within
 * @returns Search state and actions
 */
export function useSearch(teamId: string | null | undefined) {
  const [query, setQuery] = useState("");
  const [filters, setFilters] = useState<ISearchFilters>({});

  const fullQuery = buildSearchQuery(query, filters);

  const {
    data: results,
    isLoading: isSearching,
    error,
    refetch,
    isFetched,
  } = useSearchQuery(teamId, fullQuery);

  const search = () => {
    if (query.trim()) {
      refetch();
    }
  };

  const clearSearch = () => {
    setQuery("");
    setFilters({});
  };

  return {
    query,
    filters,
    results: isFetched ? results : null,
    isSearching,
    error,
    setQuery,
    setFilters,
    search,
    clearSearch,
  };
}

//#endregion Combined Hook
````

## Index Export

```typescript
// apps/v2/src/hooks/useSearchQuery/index.ts

export { useSearchQuery, useSearch } from "./useSearchQuery";
```

## Acceptance Criteria

- [ ] Uses TanStack Query `useQuery` hook
- [ ] Query disabled by default (manual trigger via refetch)
- [ ] `useSearchQuery` for low-level access
- [ ] `useSearch` convenience hook with local state
- [ ] Builds search query from terms + filters
- [ ] Returns results, isSearching, error
- [ ] TypeScript strict mode passes

## Testing

```typescript
// apps/v2/src/hooks/useSearchQuery/useSearchQuery.spec.ts

import { renderHook, waitFor, act } from "@testing-library/react-native";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useSearch } from "./useSearchQuery";
import { searchApi } from "@/api/search";

jest.mock("@/api/search");

const mockResults = {
  posts: [{ id: "post-1", message: "Hello world" }],
  order: ["post-1"],
  matches: {},
};

function createWrapper() {
  const queryClient = new QueryClient({
    defaultOptions: { queries: { retry: false } },
  });
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
}

describe("useSearch", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("executes search on search() call", async () => {
    (searchApi.searchPosts as jest.Mock).mockResolvedValue(mockResults);

    const { result } = renderHook(() => useSearch("team-1"), {
      wrapper: createWrapper(),
    });

    act(() => {
      result.current.setQuery("hello");
    });

    await act(async () => {
      result.current.search();
    });

    await waitFor(() => {
      expect(result.current.results).toEqual(mockResults);
    });
  });

  it("does not search with empty query", async () => {
    const { result } = renderHook(() => useSearch("team-1"), {
      wrapper: createWrapper(),
    });

    await act(async () => {
      result.current.search();
    });

    expect(searchApi.searchPosts).not.toHaveBeenCalled();
  });

  it("builds query with filters", () => {
    const { result } = renderHook(() => useSearch("team-1"), {
      wrapper: createWrapper(),
    });

    act(() => {
      result.current.setQuery("test");
      result.current.setFilters({ from: "user1", in: "general" });
    });

    // Query should include filters when search is called
    expect(result.current.query).toBe("test");
    expect(result.current.filters.from).toBe("user1");
  });
});
```

## Notes

- **Hybrid pattern** — TanStack Query for server state, useState for UI state
- **Manual trigger** — Search is user-initiated, so `enabled: false` with `refetch()`
- **Search history** — Could be stored in Zustand if needed (useSearchStore)
