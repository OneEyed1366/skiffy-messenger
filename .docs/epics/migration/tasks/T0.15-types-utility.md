# T0.15: Utility Types

## Metadata

| Field        | Value      |
| ------------ | ---------- |
| **ID**       | T0.15      |
| **Layer**    | L0 - Types |
| **Status**   | pending    |
| **Priority** | high       |
| **Estimate** | 1h         |
| **Parallel** | true       |
| **Assignee** | -          |
| **Created**  | 2026-01-04 |
| **Updated**  | 2026-01-04 |

## Dependencies

None

## Blocks

| Task ID | Name                            |
| ------- | ------------------------------- |
| T0.\*   | All other type files use these  |
| T7.\*   | All store implementations       |
| T8.\*   | All hooks                       |
| T10*.*  | All components with mapped data |

## Description

Migrate utility/helper TypeScript types from Mattermost. These are foundational generic types used throughout the codebase for:

- Relation mappings (one-to-one, one-to-many)
- ID-mapped object collections
- Deep partial transformations
- Type-level utilities (ValueOf, Either, RequireOnlyOne, etc.)
- Type guard functions
- Collection helper functions

## Source Files

- `vendor/desktop/webapp/platform/types/src/utilities.ts`

## Target File

`apps/v2/src/types/utility.ts`

## Implementation

```typescript
// apps/v2/src/types/utility.ts

/**
 * Utility type definitions
 * Migrated from: vendor/desktop/webapp/platform/types/src/utilities.ts
 */

//#region Entity Constraint

/**
 * Base constraint for entities with an ID field
 */
export type IEntity = { id: string };

//#endregion

//#region Relation Types

/**
 * Maps entity IDs to values of type T
 * Example: { [userId]: UserPreferences }
 */
export type IRelationOneToOne<E extends IEntity, T> = {
  [x in E["id"]]: T;
};

/**
 * Maps entity IDs to arrays of related entity IDs
 * Example: { [teamId]: [userId1, userId2, ...] }
 */
export type IRelationOneToMany<E1 extends IEntity, E2 extends IEntity> = {
  [x in E1["id"]]: Array<E2["id"]>;
};

/**
 * Maps entity IDs to unique sets of related entity IDs
 * Example: { [channelId]: Set<userId> }
 */
export type IRelationOneToManyUnique<E1 extends IEntity, E2 extends IEntity> = {
  [x in E1["id"]]: Set<E2["id"]>;
};

//#endregion

//#region ID Mapped Collections

/**
 * Maps entity IDs to entities of the same type
 * Shorthand for IRelationOneToOne<E, E>
 */
export type IIDMappedObjects<E extends IEntity> = IRelationOneToOne<E, E>;

/**
 * Collection with data map, order array, and optional errors/warnings
 */
export type IIDMappedCollection<T extends IEntity> = {
  data: IIDMappedObjects<T>;
  order: Array<T["id"]>;
  errors?: IRelationOneToOne<T, Error>;
  warnings?: IRelationOneToOne<T, { [Key in keyof T]?: string }>;
};

//#endregion

//#region Deep Partial

/**
 * Recursively makes all properties optional
 * Preserves Set and Map types without recursion
 */
export type IDeepPartial<T> = {
  [K in keyof T]?: T[K] extends Set<unknown>
    ? T[K]
    : T[K] extends Map<unknown, unknown>
      ? T[K]
      : T[K] extends object
        ? IDeepPartial<T[K]>
        : T[K] extends object | undefined
          ? IDeepPartial<T[K]>
          : T[K];
};

//#endregion

//#region Type-Level Utilities

/**
 * Extracts the value type from an object type
 */
export type IValueOf<T> = T[keyof T];

/**
 * Requires exactly one of the specified keys
 * Based on https://stackoverflow.com/a/49725198
 */
export type IRequireOnlyOne<T, Keys extends keyof T = keyof T> = Pick<
  T,
  Exclude<keyof T, Keys>
> &
  {
    [K in Keys]-?: Required<Pick<T, K>> &
      Partial<Record<Exclude<Keys, K>, undefined>>;
  }[Keys];

/**
 * Gets the intersection of two types (only shared properties)
 */
export type IIntersection<T1, T2> = Omit<
  Omit<T1 & T2, keyof Omit<T1, keyof T2>>,
  keyof Omit<T2, keyof T1>
>;

/**
 * Helper for IEither - makes T's props required and U's props never
 */
type IOnly<T, U> = { [P in keyof T]: T[P] } & { [P in keyof U]?: never };

/**
 * Exclusive OR - either T or U but not both
 * Based on https://stackoverflow.com/a/66605669
 */
export type IEither<T, U> = IOnly<T, U> | IOnly<U, T>;

/**
 * Makes all properties partial except the specified keys
 */
export type IPartialExcept<
  T extends Record<string, unknown>,
  TKeysNotPartial extends keyof T,
> = Partial<T> & Pick<T, TKeysNotPartial>;

//#endregion

//#region Type Guards

/**
 * Type guard to check if value is an array where all elements pass the check
 */
export function isArrayOf<T>(
  v: unknown,
  check: (e: unknown) => boolean,
): v is T[] {
  if (!Array.isArray(v)) {
    return false;
  }
  return v.every(check);
}

/**
 * Type guard to check if value is a string array
 */
export function isStringArray(v: unknown): v is string[] {
  return isArrayOf(v, (e) => typeof e === "string");
}

/**
 * Type guard to check if value is a record with string keys
 */
export function isRecordOf<T>(
  v: unknown,
  check: (e: unknown) => boolean,
): v is Record<string, T> {
  if (typeof v !== "object" || !v) {
    return false;
  }
  if (!Object.keys(v).every((k) => typeof k === "string")) {
    return false;
  }
  if (!Object.values(v).every(check)) {
    return false;
  }
  return true;
}

//#endregion

//#region Collection Helpers

/**
 * Creates an IIDMappedCollection from an array of entities
 */
export const collectionFromArray = <T extends IEntity>(
  arr: T[] = [],
): IIDMappedCollection<T> => {
  return arr.reduce(
    (current, item) => {
      current.data = { ...current.data, [item.id]: item };
      current.order.push(item.id);
      return current;
    },
    { data: {} as IIDMappedObjects<T>, order: [] as string[] },
  );
};

/**
 * Converts an IIDMappedCollection back to an array, preserving order
 */
export const collectionToArray = <T extends IEntity>({
  data,
  order,
}: IIDMappedCollection<T>): T[] => {
  return order.map((id) => data[id]);
};

/**
 * Replaces items in a collection (updates data, keeps order)
 */
export const collectionReplaceItem = <T extends IEntity>(
  collection: IIDMappedCollection<T>,
  ...items: T[]
) => {
  return {
    ...collection,
    data: idMappedObjectsFromArr(items, collection.data),
  };
};

/**
 * Adds items to a collection (updates data and appends to order)
 */
export const collectionAddItem = <T extends IEntity>(
  collection: IIDMappedCollection<T>,
  ...items: T[]
) => {
  return {
    ...collectionReplaceItem(collection, ...items),
    order: [...collection.order, ...items.map(({ id }) => id)],
  };
};

/**
 * Removes an item from a collection
 */
export const collectionRemoveItem = <T extends IEntity>(
  collection: IIDMappedCollection<T>,
  item: T,
) => {
  const data = { ...collection.data };
  Reflect.deleteProperty(data, item.id);
  const order = collection.order.filter((id) => id !== item.id);
  return { ...collection, data, order };
};

/**
 * Creates an IIDMappedObjects from an array, optionally merging with existing
 */
export const idMappedObjectsFromArr = <T extends IEntity>(
  items: T[],
  current?: IIDMappedObjects<T>,
) => {
  return items.reduce((r, item) => ({ ...r, [item.id]: item }), {
    ...current,
  } as IIDMappedObjects<T>);
};

//#endregion
```

## Index Export

```typescript
// apps/v2/src/types/index.ts

export type {
  // Entity constraint
  IEntity,
  // Relation types
  IRelationOneToOne,
  IRelationOneToMany,
  IRelationOneToManyUnique,
  // ID mapped collections
  IIDMappedObjects,
  IIDMappedCollection,
  // Deep partial
  IDeepPartial,
  // Type-level utilities
  IValueOf,
  IRequireOnlyOne,
  IIntersection,
  IEither,
  IPartialExcept,
} from "./utility";

export {
  // Type guards
  isArrayOf,
  isStringArray,
  isRecordOf,
  // Collection helpers
  collectionFromArray,
  collectionToArray,
  collectionReplaceItem,
  collectionAddItem,
  collectionRemoveItem,
  idMappedObjectsFromArr,
} from "./utility";
```

## Acceptance Criteria

- [ ] All types defined with `type` keyword
- [ ] All types prefixed with `I`
- [ ] Uses `#region` comments for organization
- [ ] Exported from `types/index.ts`
- [ ] No `any` types
- [ ] TypeScript strict mode passes
- [ ] Type guards are properly typed
- [ ] Collection helpers work with generic IEntity constraint

## Testing

```bash
pnpm --filter @retrievly/app tsc --noEmit
```

### Unit Tests

```typescript
// apps/v2/src/types/utility.spec.ts

import {
  isArrayOf,
  isStringArray,
  isRecordOf,
  collectionFromArray,
  collectionToArray,
  collectionAddItem,
  collectionRemoveItem,
  collectionReplaceItem,
  idMappedObjectsFromArr,
} from "./utility";
import type { IIDMappedCollection, IEntity } from "./utility";

type ITestEntity = IEntity & { name: string };

describe("utility types", () => {
  //#region Type Guards

  describe("isArrayOf", () => {
    it("returns true for array matching check", () => {
      expect(isArrayOf<number>([1, 2, 3], (e) => typeof e === "number")).toBe(
        true,
      );
    });

    it("returns false for non-array", () => {
      expect(isArrayOf<number>("not array", (e) => typeof e === "number")).toBe(
        false,
      );
    });

    it("returns false when element fails check", () => {
      expect(
        isArrayOf<number>([1, "two", 3], (e) => typeof e === "number"),
      ).toBe(false);
    });
  });

  describe("isStringArray", () => {
    it("returns true for string array", () => {
      expect(isStringArray(["a", "b", "c"])).toBe(true);
    });

    it("returns false for mixed array", () => {
      expect(isStringArray(["a", 1, "c"])).toBe(false);
    });

    it("returns false for non-array", () => {
      expect(isStringArray("not array")).toBe(false);
    });
  });

  describe("isRecordOf", () => {
    it("returns true for valid record", () => {
      expect(
        isRecordOf<number>({ a: 1, b: 2 }, (e) => typeof e === "number"),
      ).toBe(true);
    });

    it("returns false for null", () => {
      expect(isRecordOf<number>(null, (e) => typeof e === "number")).toBe(
        false,
      );
    });

    it("returns false when values fail check", () => {
      expect(
        isRecordOf<number>({ a: 1, b: "two" }, (e) => typeof e === "number"),
      ).toBe(false);
    });
  });

  //#endregion

  //#region Collection Helpers

  describe("collectionFromArray", () => {
    it("creates collection from array", () => {
      const items: ITestEntity[] = [
        { id: "1", name: "One" },
        { id: "2", name: "Two" },
      ];
      const collection = collectionFromArray(items);

      expect(collection.order).toEqual(["1", "2"]);
      expect(collection.data["1"]).toEqual({ id: "1", name: "One" });
      expect(collection.data["2"]).toEqual({ id: "2", name: "Two" });
    });

    it("handles empty array", () => {
      const collection = collectionFromArray<ITestEntity>([]);
      expect(collection.order).toEqual([]);
      expect(collection.data).toEqual({});
    });
  });

  describe("collectionToArray", () => {
    it("converts collection to array preserving order", () => {
      const collection: IIDMappedCollection<ITestEntity> = {
        data: {
          "1": { id: "1", name: "One" },
          "2": { id: "2", name: "Two" },
        },
        order: ["2", "1"],
      };
      const arr = collectionToArray(collection);
      expect(arr).toEqual([
        { id: "2", name: "Two" },
        { id: "1", name: "One" },
      ]);
    });
  });

  describe("collectionAddItem", () => {
    it("adds items to collection", () => {
      const collection = collectionFromArray<ITestEntity>([
        { id: "1", name: "One" },
      ]);
      const updated = collectionAddItem(collection, { id: "2", name: "Two" });

      expect(updated.order).toEqual(["1", "2"]);
      expect(updated.data["2"]).toEqual({ id: "2", name: "Two" });
    });
  });

  describe("collectionRemoveItem", () => {
    it("removes item from collection", () => {
      const collection = collectionFromArray<ITestEntity>([
        { id: "1", name: "One" },
        { id: "2", name: "Two" },
      ]);
      const updated = collectionRemoveItem(collection, {
        id: "1",
        name: "One",
      });

      expect(updated.order).toEqual(["2"]);
      expect(updated.data["1"]).toBeUndefined();
    });
  });

  describe("collectionReplaceItem", () => {
    it("replaces item in collection without changing order", () => {
      const collection = collectionFromArray<ITestEntity>([
        { id: "1", name: "One" },
      ]);
      const updated = collectionReplaceItem(collection, {
        id: "1",
        name: "Updated",
      });

      expect(updated.order).toEqual(["1"]);
      expect(updated.data["1"]).toEqual({ id: "1", name: "Updated" });
    });
  });

  describe("idMappedObjectsFromArr", () => {
    it("creates mapped objects from array", () => {
      const items: ITestEntity[] = [
        { id: "1", name: "One" },
        { id: "2", name: "Two" },
      ];
      const mapped = idMappedObjectsFromArr(items);

      expect(mapped["1"]).toEqual({ id: "1", name: "One" });
      expect(mapped["2"]).toEqual({ id: "2", name: "Two" });
    });

    it("merges with existing", () => {
      const existing = { "0": { id: "0", name: "Zero" } };
      const items: ITestEntity[] = [{ id: "1", name: "One" }];
      const mapped = idMappedObjectsFromArr(items, existing);

      expect(mapped["0"]).toEqual({ id: "0", name: "Zero" });
      expect(mapped["1"]).toEqual({ id: "1", name: "One" });
    });
  });

  //#endregion
});
```
