# T3.05: Notification Utilities

## Metadata

| Field        | Value               |
| ------------ | ------------------- |
| **ID**       | T3.05               |
| **Layer**    | L3 - Platform Utils |
| **Status**   | pending             |
| **Priority** | high                |
| **Estimate** | 3h                  |
| **Parallel** | true                |
| **Assignee** | -                   |
| **Created**  | 2026-01-07          |
| **Updated**  | 2026-01-07          |

## Dependencies

| Task ID | Name               |
| ------- | ------------------ |
| T3.01   | Platform Detection |

## Blocks

| Task ID | Name                       |
| ------- | -------------------------- |
| T10d.\* | Push notification handling |
| T10e.\* | Background sync            |

## Description

Migrate notification utilities from Mattermost's `utils/notifications.ts` to use `expo-notifications` for cross-platform push and local notification handling. Provides permission management, local notification display, and notification cancellation.

**Platform Considerations:**

- **iOS**: Requires explicit permission request, supports badges, sounds, and alerts
- **Android**: Notifications work by default, but channels required for Android 8+
- **Web**: Uses Web Notifications API (limited support)

## Source Files

- `vendor/desktop/webapp/channels/src/utils/notifications.ts`
- `expo-notifications` package documentation

## Target File

`apps/v2/src/utils/notifications.ts`

## Implementation

````typescript
// apps/v2/src/utils/notifications.ts

/**
 * Notification utilities
 * Migrated from: vendor/desktop/webapp/channels/src/utils/notifications.ts
 *
 * Provides cross-platform notification handling using expo-notifications.
 */

import * as Notifications from "expo-notifications";
import { Platform } from "react-native";

//#region Types

export type INotificationPermissionStatus =
  | "granted"
  | "denied"
  | "undetermined";

export type INotificationOptions = {
  title: string;
  body: string;
  data?: Record<string, unknown>;
  sound?: boolean;
  badge?: number;
  categoryIdentifier?: string;
  /** iOS: subtitle displayed below title */
  subtitle?: string;
  /** Android: channel ID (defaults to 'default') */
  channelId?: string;
  /** Trigger delay in seconds (0 for immediate) */
  delaySeconds?: number;
};

export type INotificationChannel = {
  id: string;
  name: string;
  description?: string;
  importance?: "default" | "high" | "low" | "min" | "max";
  sound?: boolean;
  vibration?: boolean;
  badge?: boolean;
};

//#endregion

//#region Constants

/** Permission status when notifications are allowed */
export const NOTIFICATION_PERMISSION_GRANTED: INotificationPermissionStatus =
  "granted";

/** Permission status when notifications are denied */
export const NOTIFICATION_PERMISSION_DENIED: INotificationPermissionStatus =
  "denied";

/** Permission status when user hasn't been asked yet */
export const NOTIFICATION_PERMISSION_UNDETERMINED: INotificationPermissionStatus =
  "undetermined";

/** Default notification channel for Android */
export const DEFAULT_CHANNEL_ID = "default";

//#endregion

//#region Permission Management

/**
 * Request notification permission from the user.
 *
 * On iOS, shows the system permission dialog.
 * On Android 13+, requests POST_NOTIFICATIONS permission.
 * On Android <13, returns true (no permission needed).
 *
 * @returns Promise resolving to true if permission granted, false otherwise
 *
 * @example
 * ```typescript
 * const granted = await requestNotificationPermission();
 * if (granted) {
 *   await showLocalNotification({ title: "Welcome!", body: "Notifications enabled" });
 * } else {
 *   showPermissionDeniedMessage();
 * }
 * ```
 */
export async function requestNotificationPermission(): Promise<boolean> {
  try {
    const { status: existingStatus } =
      await Notifications.getPermissionsAsync();

    if (existingStatus === "granted") {
      return true;
    }

    const { status } = await Notifications.requestPermissionsAsync();
    return status === "granted";
  } catch (error) {
    console.error("Failed to request notification permission:", error);
    return false;
  }
}

/**
 * Get current notification permission status.
 *
 * @returns Promise resolving to permission status
 *
 * @example
 * ```typescript
 * const status = await getNotificationPermissionStatus();
 * if (status === NOTIFICATION_PERMISSION_DENIED) {
 *   showSettingsPrompt();
 * }
 * ```
 */
export async function getNotificationPermissionStatus(): Promise<INotificationPermissionStatus> {
  try {
    const { status } = await Notifications.getPermissionsAsync();

    switch (status) {
      case "granted":
        return NOTIFICATION_PERMISSION_GRANTED;
      case "denied":
        return NOTIFICATION_PERMISSION_DENIED;
      default:
        return NOTIFICATION_PERMISSION_UNDETERMINED;
    }
  } catch (error) {
    console.error("Failed to get notification permission status:", error);
    return NOTIFICATION_PERMISSION_UNDETERMINED;
  }
}

//#endregion

//#region Local Notifications

/**
 * Show a local notification.
 *
 * @param options - Notification configuration
 * @returns Promise resolving to notification ID for later cancellation
 *
 * @example
 * ```typescript
 * // Immediate notification
 * const id = await showLocalNotification({
 *   title: "New Message",
 *   body: "You have a new message from John",
 *   data: { channelId: "channel-123" },
 * });
 *
 * // Delayed notification
 * const reminderId = await showLocalNotification({
 *   title: "Reminder",
 *   body: "Meeting in 5 minutes",
 *   delaySeconds: 300,
 * });
 * ```
 */
export async function showLocalNotification(
  options: INotificationOptions,
): Promise<string> {
  try {
    const {
      title,
      body,
      data,
      sound = true,
      badge,
      subtitle,
      channelId,
      delaySeconds = 0,
    } = options;

    // Build notification content
    const content: Notifications.NotificationContentInput = {
      title,
      body,
      data,
      sound: sound ? "default" : undefined,
      badge,
    };

    // iOS-specific: subtitle
    if (Platform.OS === "ios" && subtitle) {
      content.subtitle = subtitle;
    }

    // Android-specific: channel
    if (Platform.OS === "android") {
      (content as { channelId?: string }).channelId =
        channelId ?? DEFAULT_CHANNEL_ID;
    }

    // Build trigger (immediate or delayed)
    const trigger: Notifications.NotificationTriggerInput =
      delaySeconds > 0 ? { seconds: delaySeconds } : null;

    const notificationId = await Notifications.scheduleNotificationAsync({
      content,
      trigger,
    });

    return notificationId;
  } catch (error) {
    console.error("Failed to show local notification:", error);
    throw error;
  }
}

//#endregion

//#region Notification Management

/**
 * Cancel a scheduled or displayed notification by ID.
 *
 * @param id - Notification ID returned from showLocalNotification
 *
 * @example
 * ```typescript
 * const id = await showLocalNotification({ title: "Test", body: "..." });
 * // Later...
 * await cancelNotification(id);
 * ```
 */
export async function cancelNotification(id: string): Promise<void> {
  try {
    await Notifications.cancelScheduledNotificationAsync(id);
  } catch (error) {
    console.error("Failed to cancel notification:", error);
    // Don't throw - canceling a non-existent notification shouldn't be fatal
  }
}

/**
 * Cancel all scheduled and displayed notifications.
 *
 * @example
 * ```typescript
 * // On logout
 * await cancelAllNotifications();
 * ```
 */
export async function cancelAllNotifications(): Promise<void> {
  try {
    await Notifications.cancelAllScheduledNotificationsAsync();
    await Notifications.dismissAllNotificationsAsync();
  } catch (error) {
    console.error("Failed to cancel all notifications:", error);
  }
}

/**
 * Get all pending scheduled notifications.
 *
 * @returns Promise resolving to array of scheduled notification IDs
 */
export async function getScheduledNotifications(): Promise<string[]> {
  try {
    const notifications =
      await Notifications.getAllScheduledNotificationsAsync();
    return notifications.map((n) => n.identifier);
  } catch (error) {
    console.error("Failed to get scheduled notifications:", error);
    return [];
  }
}

//#endregion

//#region Android Channels

/**
 * Create a notification channel (Android 8+ only).
 *
 * Channels allow users to customize notification behavior per category.
 * On iOS, this function does nothing.
 *
 * @param channel - Channel configuration
 *
 * @example
 * ```typescript
 * // Create channels on app startup
 * await createNotificationChannel({
 *   id: "messages",
 *   name: "Messages",
 *   description: "New message notifications",
 *   importance: "high",
 *   sound: true,
 * });
 *
 * await createNotificationChannel({
 *   id: "updates",
 *   name: "Updates",
 *   description: "App updates and announcements",
 *   importance: "low",
 * });
 * ```
 */
export async function createNotificationChannel(
  channel: INotificationChannel,
): Promise<void> {
  if (Platform.OS !== "android") {
    return;
  }

  try {
    const importanceMap: Record<string, Notifications.AndroidImportance> = {
      default: Notifications.AndroidImportance.DEFAULT,
      high: Notifications.AndroidImportance.HIGH,
      low: Notifications.AndroidImportance.LOW,
      min: Notifications.AndroidImportance.MIN,
      max: Notifications.AndroidImportance.MAX,
    };

    await Notifications.setNotificationChannelAsync(channel.id, {
      name: channel.name,
      description: channel.description,
      importance: importanceMap[channel.importance ?? "default"],
      sound: channel.sound !== false ? "default" : undefined,
      vibrationPattern:
        channel.vibration !== false ? [0, 250, 250, 250] : undefined,
      enableVibrate: channel.vibration !== false,
    });
  } catch (error) {
    console.error("Failed to create notification channel:", error);
  }
}

/**
 * Delete a notification channel (Android only).
 *
 * @param channelId - Channel ID to delete
 */
export async function deleteNotificationChannel(
  channelId: string,
): Promise<void> {
  if (Platform.OS !== "android") {
    return;
  }

  try {
    await Notifications.deleteNotificationChannelAsync(channelId);
  } catch (error) {
    console.error("Failed to delete notification channel:", error);
  }
}

//#endregion

//#region Badge Management

/**
 * Set the app badge count (iOS only).
 *
 * @param count - Badge number (0 to clear)
 *
 * @example
 * ```typescript
 * // Set unread count
 * await setBadgeCount(5);
 *
 * // Clear badge
 * await setBadgeCount(0);
 * ```
 */
export async function setBadgeCount(count: number): Promise<void> {
  try {
    await Notifications.setBadgeCountAsync(count);
  } catch (error) {
    console.error("Failed to set badge count:", error);
  }
}

/**
 * Get current app badge count (iOS only).
 *
 * @returns Promise resolving to current badge count
 */
export async function getBadgeCount(): Promise<number> {
  try {
    return await Notifications.getBadgeCountAsync();
  } catch (error) {
    console.error("Failed to get badge count:", error);
    return 0;
  }
}

//#endregion

//#region Notification Behavior

/**
 * Configure how notifications are handled when app is in foreground.
 *
 * Call this once during app initialization.
 *
 * @example
 * ```typescript
 * // In App.tsx or initialization
 * configureNotificationHandler({
 *   shouldShowAlert: true,
 *   shouldPlaySound: true,
 *   shouldSetBadge: false,
 * });
 * ```
 */
export function configureNotificationHandler(options: {
  shouldShowAlert?: boolean;
  shouldPlaySound?: boolean;
  shouldSetBadge?: boolean;
}): void {
  Notifications.setNotificationHandler({
    handleNotification: async () => ({
      shouldShowAlert: options.shouldShowAlert ?? true,
      shouldPlaySound: options.shouldPlaySound ?? false,
      shouldSetBadge: options.shouldSetBadge ?? false,
    }),
  });
}

//#endregion
````

## Index Export

```typescript
// apps/v2/src/utils/index.ts

export {
  // Permission
  requestNotificationPermission,
  getNotificationPermissionStatus,
  // Local Notifications
  showLocalNotification,
  // Management
  cancelNotification,
  cancelAllNotifications,
  getScheduledNotifications,
  // Android Channels
  createNotificationChannel,
  deleteNotificationChannel,
  // Badge
  setBadgeCount,
  getBadgeCount,
  // Configuration
  configureNotificationHandler,
  // Constants
  NOTIFICATION_PERMISSION_GRANTED,
  NOTIFICATION_PERMISSION_DENIED,
  NOTIFICATION_PERMISSION_UNDETERMINED,
  DEFAULT_CHANNEL_ID,
} from "./notifications";

export type {
  INotificationPermissionStatus,
  INotificationOptions,
  INotificationChannel,
} from "./notifications";
```

## Platform Considerations

| Feature               | iOS           | Android                      | Web            |
| --------------------- | ------------- | ---------------------------- | -------------- |
| Permission required   | Yes (always)  | Yes (Android 13+)            | Yes            |
| Notification channels | N/A           | Required (Android 8+)        | N/A            |
| Badge count           | Supported     | Limited (launcher dependent) | N/A            |
| Sound customization   | Supported     | Per-channel                  | Limited        |
| Subtitle              | Supported     | N/A (use body)               | N/A            |
| Background delivery   | APNs required | FCM recommended              | Service Worker |

### iOS Specifics

- First permission request shows system dialog
- Denied permission requires user to go to Settings
- Critical alerts require special entitlement
- Provisional authorization available for quiet notifications

### Android Specifics

- Android 8+ requires notification channels
- Android 13+ requires POST_NOTIFICATIONS runtime permission
- Channel settings persist after app reinstall
- Users can disable specific channels in system settings

## Acceptance Criteria

- [ ] Uses `expo-notifications` package
- [ ] `requestNotificationPermission()` returns boolean success
- [ ] `getNotificationPermissionStatus()` returns typed status
- [ ] `showLocalNotification()` displays notification and returns ID
- [ ] `cancelNotification()` cancels by ID
- [ ] `cancelAllNotifications()` clears all notifications
- [ ] Android channel support with `createNotificationChannel()`
- [ ] Badge management with `setBadgeCount()`
- [ ] Constants exported: `NOTIFICATION_PERMISSION_GRANTED`, `NOTIFICATION_PERMISSION_DENIED`
- [ ] Error handling with console.error logging
- [ ] All types prefixed with `I`
- [ ] Uses `#region` comments for organization
- [ ] Exported from `utils/index.ts`
- [ ] No `any` types
- [ ] TypeScript strict mode passes

## Testing

```typescript
// apps/v2/src/utils/notifications.spec.ts

import * as Notifications from "expo-notifications";
import { Platform } from "react-native";

import {
  requestNotificationPermission,
  getNotificationPermissionStatus,
  showLocalNotification,
  cancelNotification,
  cancelAllNotifications,
  getScheduledNotifications,
  createNotificationChannel,
  setBadgeCount,
  getBadgeCount,
  NOTIFICATION_PERMISSION_GRANTED,
  NOTIFICATION_PERMISSION_DENIED,
  NOTIFICATION_PERMISSION_UNDETERMINED,
} from "./notifications";

jest.mock("expo-notifications");

const mockNotifications = Notifications as jest.Mocked<typeof Notifications>;

describe("notification utilities", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  //#region Permission Management

  describe("requestNotificationPermission", () => {
    it("returns true when permission already granted", async () => {
      mockNotifications.getPermissionsAsync.mockResolvedValue({
        status: "granted",
        expires: "never",
        granted: true,
        canAskAgain: true,
      });

      const result = await requestNotificationPermission();

      expect(result).toBe(true);
      expect(mockNotifications.requestPermissionsAsync).not.toHaveBeenCalled();
    });

    it("requests permission when not granted", async () => {
      mockNotifications.getPermissionsAsync.mockResolvedValue({
        status: "undetermined",
        expires: "never",
        granted: false,
        canAskAgain: true,
      });
      mockNotifications.requestPermissionsAsync.mockResolvedValue({
        status: "granted",
        expires: "never",
        granted: true,
        canAskAgain: true,
      });

      const result = await requestNotificationPermission();

      expect(result).toBe(true);
      expect(mockNotifications.requestPermissionsAsync).toHaveBeenCalled();
    });

    it("returns false when permission denied", async () => {
      mockNotifications.getPermissionsAsync.mockResolvedValue({
        status: "undetermined",
        expires: "never",
        granted: false,
        canAskAgain: true,
      });
      mockNotifications.requestPermissionsAsync.mockResolvedValue({
        status: "denied",
        expires: "never",
        granted: false,
        canAskAgain: false,
      });

      const result = await requestNotificationPermission();

      expect(result).toBe(false);
    });

    it("returns false on error", async () => {
      mockNotifications.getPermissionsAsync.mockRejectedValue(
        new Error("Failed"),
      );
      const consoleSpy = jest.spyOn(console, "error").mockImplementation();

      const result = await requestNotificationPermission();

      expect(result).toBe(false);
      consoleSpy.mockRestore();
    });
  });

  describe("getNotificationPermissionStatus", () => {
    it("returns granted when permission granted", async () => {
      mockNotifications.getPermissionsAsync.mockResolvedValue({
        status: "granted",
        expires: "never",
        granted: true,
        canAskAgain: true,
      });

      const result = await getNotificationPermissionStatus();

      expect(result).toBe(NOTIFICATION_PERMISSION_GRANTED);
    });

    it("returns denied when permission denied", async () => {
      mockNotifications.getPermissionsAsync.mockResolvedValue({
        status: "denied",
        expires: "never",
        granted: false,
        canAskAgain: false,
      });

      const result = await getNotificationPermissionStatus();

      expect(result).toBe(NOTIFICATION_PERMISSION_DENIED);
    });

    it("returns undetermined for new users", async () => {
      mockNotifications.getPermissionsAsync.mockResolvedValue({
        status: "undetermined",
        expires: "never",
        granted: false,
        canAskAgain: true,
      });

      const result = await getNotificationPermissionStatus();

      expect(result).toBe(NOTIFICATION_PERMISSION_UNDETERMINED);
    });
  });

  //#endregion

  //#region Local Notifications

  describe("showLocalNotification", () => {
    it("schedules notification and returns ID", async () => {
      mockNotifications.scheduleNotificationAsync.mockResolvedValue(
        "notif-123",
      );

      const id = await showLocalNotification({
        title: "Test Title",
        body: "Test Body",
      });

      expect(id).toBe("notif-123");
      expect(mockNotifications.scheduleNotificationAsync).toHaveBeenCalledWith({
        content: expect.objectContaining({
          title: "Test Title",
          body: "Test Body",
        }),
        trigger: null,
      });
    });

    it("includes data in notification", async () => {
      mockNotifications.scheduleNotificationAsync.mockResolvedValue(
        "notif-123",
      );

      await showLocalNotification({
        title: "Test",
        body: "Body",
        data: { channelId: "ch-123" },
      });

      expect(mockNotifications.scheduleNotificationAsync).toHaveBeenCalledWith({
        content: expect.objectContaining({
          data: { channelId: "ch-123" },
        }),
        trigger: null,
      });
    });

    it("schedules delayed notification", async () => {
      mockNotifications.scheduleNotificationAsync.mockResolvedValue(
        "notif-123",
      );

      await showLocalNotification({
        title: "Reminder",
        body: "In 5 minutes",
        delaySeconds: 300,
      });

      expect(mockNotifications.scheduleNotificationAsync).toHaveBeenCalledWith({
        content: expect.anything(),
        trigger: { seconds: 300 },
      });
    });

    it("throws on error", async () => {
      mockNotifications.scheduleNotificationAsync.mockRejectedValue(
        new Error("Schedule failed"),
      );
      const consoleSpy = jest.spyOn(console, "error").mockImplementation();

      await expect(
        showLocalNotification({ title: "Test", body: "Body" }),
      ).rejects.toThrow();

      consoleSpy.mockRestore();
    });
  });

  //#endregion

  //#region Notification Management

  describe("cancelNotification", () => {
    it("cancels notification by ID", async () => {
      mockNotifications.cancelScheduledNotificationAsync.mockResolvedValue();

      await cancelNotification("notif-123");

      expect(
        mockNotifications.cancelScheduledNotificationAsync,
      ).toHaveBeenCalledWith("notif-123");
    });

    it("does not throw on error", async () => {
      mockNotifications.cancelScheduledNotificationAsync.mockRejectedValue(
        new Error("Not found"),
      );
      const consoleSpy = jest.spyOn(console, "error").mockImplementation();

      await expect(cancelNotification("invalid")).resolves.not.toThrow();

      consoleSpy.mockRestore();
    });
  });

  describe("cancelAllNotifications", () => {
    it("cancels all scheduled and displayed notifications", async () => {
      mockNotifications.cancelAllScheduledNotificationsAsync.mockResolvedValue();
      mockNotifications.dismissAllNotificationsAsync.mockResolvedValue();

      await cancelAllNotifications();

      expect(
        mockNotifications.cancelAllScheduledNotificationsAsync,
      ).toHaveBeenCalled();
      expect(mockNotifications.dismissAllNotificationsAsync).toHaveBeenCalled();
    });
  });

  describe("getScheduledNotifications", () => {
    it("returns array of notification IDs", async () => {
      mockNotifications.getAllScheduledNotificationsAsync.mockResolvedValue([
        { identifier: "notif-1" } as Notifications.NotificationRequest,
        { identifier: "notif-2" } as Notifications.NotificationRequest,
      ]);

      const ids = await getScheduledNotifications();

      expect(ids).toEqual(["notif-1", "notif-2"]);
    });

    it("returns empty array on error", async () => {
      mockNotifications.getAllScheduledNotificationsAsync.mockRejectedValue(
        new Error("Failed"),
      );
      const consoleSpy = jest.spyOn(console, "error").mockImplementation();

      const ids = await getScheduledNotifications();

      expect(ids).toEqual([]);
      consoleSpy.mockRestore();
    });
  });

  //#endregion

  //#region Badge Management

  describe("setBadgeCount", () => {
    it("sets badge count", async () => {
      mockNotifications.setBadgeCountAsync.mockResolvedValue(true);

      await setBadgeCount(5);

      expect(mockNotifications.setBadgeCountAsync).toHaveBeenCalledWith(5);
    });
  });

  describe("getBadgeCount", () => {
    it("returns badge count", async () => {
      mockNotifications.getBadgeCountAsync.mockResolvedValue(3);

      const count = await getBadgeCount();

      expect(count).toBe(3);
    });

    it("returns 0 on error", async () => {
      mockNotifications.getBadgeCountAsync.mockRejectedValue(
        new Error("Failed"),
      );
      const consoleSpy = jest.spyOn(console, "error").mockImplementation();

      const count = await getBadgeCount();

      expect(count).toBe(0);
      consoleSpy.mockRestore();
    });
  });

  //#endregion
});
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- notifications
```

### Type Check

```bash
pnpm --filter @retrievly/app tsc --noEmit
```

## Migration Notes

### API Differences from Mattermost

| Original (notifications.ts)        | New (notifications.ts)              | Notes                          |
| ---------------------------------- | ----------------------------------- | ------------------------------ |
| `Notification.permission`          | `getNotificationPermissionStatus()` | Async, uses expo-notifications |
| `Notification.requestPermission()` | `requestNotificationPermission()`   | Returns boolean                |
| `new Notification(title, opts)`    | `showLocalNotification(opts)`       | Returns notification ID        |
| N/A                                | `createNotificationChannel()`       | Android 8+ requirement         |
| `notification.close()`             | `cancelNotification(id)`            | By ID instead of reference     |

### Push Notifications

This task covers **local notifications only**. Push notification setup (FCM/APNs tokens, server registration) is handled in a separate task for push notification infrastructure.
