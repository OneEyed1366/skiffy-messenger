# T4.03: Markdown Utilities

## Metadata

| Field        | Value                 |
| ------------ | --------------------- |
| **ID**       | T4.03                 |
| **Layer**    | L4 - Formatting Utils |
| **Status**   | pending               |
| **Priority** | high                  |
| **Estimate** | 6h                    |
| **Parallel** | true                  |
| **Assignee** | -                     |
| **Created**  | 2026-01-04            |
| **Updated**  | 2026-01-04            |

## Dependencies

| Task ID | Name                  |
| ------- | --------------------- |
| T4.02   | utils-text-formatting |

## Blocks

| Task ID | Name                         |
| ------- | ---------------------------- |
| T10b.\* | Message rendering components |
| T10c.\* | Post content display         |

## Description

Migrate markdown parsing utilities from Mattermost. The original uses the `marked` library with custom renderers for HTML output. For React Native, we need a different approach using `react-native-markdown-display` or similar that produces React Native components instead of HTML strings.

This task covers parsing-only utilities. Actual rendering will be handled in components.

## Source Files

- `vendor/desktop/webapp/channels/src/utils/markdown/index.ts` - Main format functions
- `vendor/desktop/webapp/channels/src/utils/markdown/apply_markdown.ts` - Apply markdown to text input
- `vendor/desktop/webapp/channels/src/utils/markdown/remove_markdown.ts` - Strip markdown from text
- `vendor/desktop/webapp/channels/src/utils/markdown/helpers.ts` - Image dimension parsing
- `vendor/desktop/webapp/channels/src/utils/markdown/renderer.tsx` - Custom HTML renderer
- `vendor/desktop/webapp/channels/src/utils/markdown/plain_renderer.ts` - Plain text renderer

### Source Analysis

**Library Used:** `marked` (v4.x) - A CommonMark-compliant markdown parser that outputs HTML strings.

**Architecture:**

1. **Custom Renderers** - Extend `marked.Renderer` to customize output:
   - `Renderer` - Full HTML renderer with CSS classes, search highlighting, emoji support
   - `RemoveMarkdown` - Strips all markdown, returns plain text
   - `PlainRenderer` - Converts to plain text with whitespace preserved

2. **Supported Syntax:**
   - **Inline:** bold (`**`), italic (`*`), strikethrough (`~~`), code (`` ` ``), links (`[]()`), images (`![]()`)
   - **Block:** headings (`#`), blockquotes (`>`), code blocks (` ``` `), lists (ordered/unordered), tables, horizontal rules
   - **Extended:** task lists (`- [ ]`), LaTeX (`tex`/`latex` code blocks), image dimensions (`=WxH`)

3. **apply_markdown.ts** - Editor helper functions:
   - `applyMarkdown()` - Main dispatcher for markdown mode
   - Modes: `bold`, `italic`, `link`, `strike`, `code`, `heading`, `quote`, `ul`, `ol`
   - Returns new message + updated selection positions

4. **Key Patterns:**
   - URL scheme filtering via Redux selector
   - Search term highlighting in rendered output
   - Task list checkbox rendering
   - Image proxy support

## Target File

`apps/v2/src/utils/markdown/markdown.ts`

## Implementation

### Approach

For React Native, we'll use `marked` for parsing to tokens and `react-native-markdown-display` for rendering. This task provides:

1. Token-based parsing utilities
2. Plain text stripping
3. Editor markdown application helpers

````typescript
// apps/v2/src/utils/markdown/markdown.ts

import { marked, type Token, type Tokens } from "marked";

//#region Types

export type IMarkdownMode =
  | "bold"
  | "italic"
  | "link"
  | "strike"
  | "code"
  | "heading"
  | "quote"
  | "ul"
  | "ol";

export type IApplyMarkdownOptions = {
  markdownMode: IMarkdownMode;
  selectionStart: number | null;
  selectionEnd: number | null;
  message: string;
};

export type IApplyMarkdownResult = {
  selectionStart: number;
  selectionEnd: number;
  message: string;
};

export type IApplyLinkMarkdownOptions = IApplyMarkdownResult & {
  url?: string;
};

export type IImageDimensions = {
  href: string;
  height: string;
  width: string;
};

export type IMarkdownToken = Token;

//#endregion Types

//#region Parsing

/**
 * Parse markdown text into tokens (AST).
 * Use this for analysis or custom rendering logic.
 *
 * @param text - Markdown text to parse
 * @returns Array of markdown tokens
 *
 * @example
 * const tokens = parseMarkdown("**bold** and *italic*");
 * // => [{ type: 'paragraph', tokens: [...] }]
 */
export function parseMarkdown(text: string): IMarkdownToken[] {
  return marked.lexer(text);
}

/**
 * Strip all markdown formatting from text.
 * Useful for notifications, search indexing, or plain text previews.
 *
 * @param text - Markdown text to strip
 * @returns Plain text without markdown formatting
 *
 * @example
 * stripMarkdown("**bold** and [link](url)");
 * // => "bold and link"
 */
export function stripMarkdown(text: string): string {
  if (typeof text !== "string" || text.length === 0) {
    return text;
  }

  const tokens = marked.lexer(text);
  return tokensToPlainText(tokens).trim();
}

/**
 * Convert markdown tokens to plain text recursively.
 */
function tokensToPlainText(tokens: Token[]): string {
  let result = "";

  for (const token of tokens) {
    switch (token.type) {
      case "text":
      case "codespan":
        result += token.text?.replace(/\n/g, " ") ?? "";
        break;
      case "code":
        result += token.text?.replace(/\n/g, " ") ?? "";
        result += " ";
        break;
      case "heading":
      case "paragraph":
        result +=
          tokensToPlainText((token as Tokens.Heading).tokens ?? []) + " ";
        break;
      case "blockquote":
        result +=
          tokensToPlainText((token as Tokens.Blockquote).tokens ?? []) + " ";
        break;
      case "list":
        for (const item of (token as Tokens.List).items) {
          result += tokensToPlainText(item.tokens ?? []) + " ";
        }
        break;
      case "list_item":
        result +=
          tokensToPlainText((token as Tokens.ListItem).tokens ?? []) + " ";
        break;
      case "strong":
      case "em":
      case "del":
        result += tokensToPlainText((token as Tokens.Strong).tokens ?? []);
        break;
      case "link":
      case "image":
        result += (token as Tokens.Link).text ?? "";
        break;
      case "br":
      case "hr":
        result += " ";
        break;
      case "space":
        break;
      case "html":
        // Strip HTML tags
        result += (token.text ?? "").replace(/<[^>]*>/g, "");
        break;
      case "table":
        // Skip tables in plain text
        break;
      default:
        // Handle any token with nested tokens
        if ("tokens" in token && Array.isArray(token.tokens)) {
          result += tokensToPlainText(token.tokens);
        } else if ("text" in token) {
          result += token.text ?? "";
        }
    }
  }

  return result;
}

//#endregion Parsing

//#region Image Helpers

/**
 * Parse image dimensions from markdown image href.
 * Supports format: `image.png =100x200` or `image.png =100` or `image.png =x200`
 *
 * @param input - Image href potentially containing dimensions
 * @returns Parsed href and dimensions
 *
 * @example
 * parseImageDimensions("image.png =100x200");
 * // => { href: "image.png", width: "100", height: "200" }
 */
export function parseImageDimensions(input: string): IImageDimensions {
  const match = / =(\d*)(?:x(\d+))?$/.exec(input);

  if (!match) {
    return { href: input, height: "", width: "" };
  }

  let width = match[1];
  let height = match[2];

  if (!width && !height) {
    return { href: input, height: "", width: "" };
  }

  if (width && !height) {
    height = "auto";
  } else if (height && !width) {
    width = "auto";
  }

  return {
    href: input.substring(0, input.length - match[0].length),
    height,
    width,
  };
}

//#endregion Image Helpers

//#region Apply Markdown (Editor Helpers)

const DEFAULT_PLACEHOLDER_URL = "url";

/**
 * Apply markdown formatting to text selection.
 * Used by message composer for keyboard shortcuts and toolbar buttons.
 *
 * @param options - Markdown mode, selection range, and message
 * @returns Updated message and selection positions
 *
 * @example
 * applyMarkdown({
 *   markdownMode: "bold",
 *   selectionStart: 0,
 *   selectionEnd: 4,
 *   message: "text",
 * });
 * // => { message: "**text**", selectionStart: 2, selectionEnd: 6 }
 */
export function applyMarkdown(
  options: IApplyMarkdownOptions,
): IApplyMarkdownResult {
  const { selectionEnd, selectionStart, message, markdownMode } = options;

  if (selectionStart === null || selectionEnd === null) {
    return {
      message,
      selectionStart: message.length,
      selectionEnd: message.length,
    };
  }

  switch (markdownMode) {
    case "bold":
      return applyBoldMarkdown({ selectionEnd, selectionStart, message });
    case "italic":
      return applyItalicMarkdown({ selectionEnd, selectionStart, message });
    case "link":
      return applyLinkMarkdown({ selectionEnd, selectionStart, message });
    case "ol":
      return applyOlMarkdown({ selectionEnd, selectionStart, message });
    case "ul":
      return applyMarkdownToSelectedLines({
        selectionEnd,
        selectionStart,
        message,
        delimiter: "- ",
      });
    case "heading":
      return applyMarkdownToSelectedLines({
        selectionEnd,
        selectionStart,
        message,
        delimiter: "### ",
      });
    case "quote":
      return applyMarkdownToSelectedLines({
        selectionEnd,
        selectionStart,
        message,
        delimiter: "> ",
      });
    case "strike":
      return applyMarkdownToSelection({
        selectionEnd,
        selectionStart,
        message,
        delimiter: "~~",
      });
    case "code":
      return applyCodeMarkdown({ selectionEnd, selectionStart, message });
    default:
      throw new Error(`Unsupported markdown mode: ${markdownMode}`);
  }
}

type IApplySpecificOptions = IApplyMarkdownResult & {
  delimiter?: string;
  delimiterStart?: string;
  delimiterEnd?: string;
};

function applyMarkdownToSelection({
  selectionEnd,
  selectionStart,
  message,
  delimiter,
  delimiterStart,
  delimiterEnd,
}: IApplySpecificOptions): IApplyMarkdownResult {
  const openingDelimiter = delimiterStart ?? delimiter;
  const closingDelimiter = delimiterEnd ?? delimiter;

  if (!openingDelimiter || !closingDelimiter) {
    return { message, selectionStart, selectionEnd };
  }

  let prefix = message.slice(0, selectionStart);
  let selection = message.slice(selectionStart, selectionEnd);
  let suffix = message.slice(selectionEnd);

  const hasCurrentMarkdown =
    prefix.endsWith(openingDelimiter) && suffix.startsWith(closingDelimiter);

  let newValue: string;
  let newStart = selectionStart;
  let newEnd = selectionEnd;

  if (selection.endsWith(" ")) {
    selection = selection.slice(0, -1);
    suffix = ` ${suffix}`;
    newEnd -= 1;
  }

  if (selection.startsWith(" ")) {
    selection = selection.slice(1);
    prefix = `${prefix} `;
    newStart += 1;
  }

  if (hasCurrentMarkdown) {
    newValue =
      prefix.slice(0, prefix.length - openingDelimiter.length) +
      selection +
      suffix.slice(closingDelimiter.length);
    newStart -= openingDelimiter.length;
    newEnd -= closingDelimiter.length;
  } else {
    newValue =
      prefix + openingDelimiter + selection + closingDelimiter + suffix;
    newStart += openingDelimiter.length;
    newEnd += closingDelimiter.length;
  }

  return { message: newValue, selectionStart: newStart, selectionEnd: newEnd };
}

function applyMarkdownToSelectedLines({
  selectionEnd,
  selectionStart,
  message,
  delimiter,
}: IApplySpecificOptions): IApplyMarkdownResult {
  if (!delimiter) {
    return { message, selectionStart, selectionEnd };
  }

  const prefix = message.slice(0, selectionStart);
  const selection = message.slice(selectionStart, selectionEnd);
  const suffix = message.slice(selectionEnd);

  const newPrefix = prefix.includes("\n")
    ? prefix.slice(0, prefix.lastIndexOf("\n"))
    : "";
  const multilinePrefix = prefix.includes("\n")
    ? prefix.slice(prefix.lastIndexOf("\n"))
    : prefix;

  const multilineSuffix = getMultilineSuffix(suffix);
  const newSuffix = getNewSuffix(suffix);
  let multilineSelection: string =
    multilinePrefix + selection + multilineSuffix;

  const isFirstLineSelected = !multilineSelection.startsWith("\n");

  if (selection.startsWith("\n")) {
    multilineSelection = prefix + selection + multilineSuffix;
  }

  const linesQuantity = (multilineSelection.match(/\n/g) || []).length;
  const delimiterRegex = new RegExp(`\n${escapeRegex(delimiter)}`, "g");
  const newLinesWithDelimitersQuantity = (
    multilineSelection.match(delimiterRegex) || []
  ).length;

  const hasCurrentMarkdown =
    (newLinesWithDelimitersQuantity === linesQuantity &&
      !isFirstLineSelected) ||
    (linesQuantity === newLinesWithDelimitersQuantity &&
      multilineSelection.startsWith(delimiter));

  let newValue: string;
  let newStart: number;
  let newEnd: number;

  if (hasCurrentMarkdown) {
    let cleaned = multilineSelection;
    if (isFirstLineSelected) {
      cleaned = cleaned.slice(delimiter.length);
    }

    newValue = newPrefix + cleaned.replace(delimiterRegex, "\n") + newSuffix;

    let count = isFirstLineSelected ? 1 : 0;
    count += (multilineSelection.match(/\n/g) || []).length;

    newStart = Math.max(selectionStart - delimiter.length, 0);
    newEnd = Math.max(selectionEnd - delimiter.length * count, 0);
  } else {
    newValue =
      newPrefix +
      multilineSelection.replace(/\n/g, `\n${delimiter}`) +
      newSuffix;

    let count = 0;
    if (isFirstLineSelected) {
      newValue = delimiter + newValue;
      count++;
    }
    count += (multilineSelection.match(/\n/g) || []).length;

    newStart = selectionStart + delimiter.length;
    newEnd = selectionEnd + delimiter.length * count;
  }

  return { message: newValue, selectionStart: newStart, selectionEnd: newEnd };
}

function applyOlMarkdown({
  selectionEnd,
  selectionStart,
  message,
}: IApplySpecificOptions): IApplyMarkdownResult {
  const prefix = message.slice(0, selectionStart);
  const selection = message.slice(selectionStart, selectionEnd);
  const suffix = message.slice(selectionEnd);

  const newPrefix = prefix.includes("\n")
    ? prefix.slice(0, prefix.lastIndexOf("\n"))
    : "";
  const multilinePrefix = prefix.includes("\n")
    ? prefix.slice(prefix.lastIndexOf("\n"))
    : prefix;

  const multilineSuffix = getMultilineSuffix(suffix);
  const newSuffix = getNewSuffix(suffix);

  const delimiterLength = 3;
  let counter = 1;
  const getDelimiter = (num?: number): string => {
    if (num !== undefined) counter = num;
    return `${counter++}. `;
  };

  let multilineSelection = multilinePrefix + selection + multilineSuffix;
  const isFirstLineSelected = !multilineSelection.startsWith("\n");

  if (selection.startsWith("\n")) {
    multilineSelection = prefix + selection + multilineSuffix;
  }

  const linesQuantity = (multilineSelection.match(/\n/g) || []).length;
  const newLinesWithDelimitersQuantity = (
    multilineSelection.match(/\n\d+\. /g) || []
  ).length;

  const hasCurrentMarkdown =
    (newLinesWithDelimitersQuantity === linesQuantity &&
      !isFirstLineSelected) ||
    (linesQuantity === newLinesWithDelimitersQuantity &&
      /^\d+\. /.test(multilineSelection));

  let newValue: string;
  let newStart: number;
  let newEnd: number;

  if (hasCurrentMarkdown) {
    let cleaned = multilineSelection;
    if (isFirstLineSelected) {
      cleaned = cleaned.slice(delimiterLength);
    }

    newValue = newPrefix + cleaned.replace(/\n\d+\. /g, "\n") + newSuffix;

    let count = isFirstLineSelected ? 1 : 0;
    count += (multilineSelection.match(/\n/g) || []).length;

    newStart = Math.max(selectionStart - delimiterLength, 0);
    newEnd = Math.max(selectionEnd - delimiterLength * count, 0);
  } else {
    let count = 0;
    if (isFirstLineSelected) {
      multilineSelection = getDelimiter() + multilineSelection;
      count++;
    }

    const selectionArr = Array.from(multilineSelection);
    for (let i = 0; i < selectionArr.length; i++) {
      if (selectionArr[i] === "\n") {
        selectionArr[i] = `\n${getDelimiter()}`;
      }
    }
    multilineSelection = selectionArr.join("");
    newValue = newPrefix + multilineSelection + newSuffix;

    count += (multilineSelection.match(/\n/g) || []).length;

    newStart = selectionStart + delimiterLength;
    newEnd = selectionEnd + delimiterLength * count;
  }

  return { message: newValue, selectionStart: newStart, selectionEnd: newEnd };
}

function applyBoldMarkdown(
  options: IApplySpecificOptions,
): IApplyMarkdownResult {
  return applyBoldItalicMarkdown({ ...options, mode: "bold" });
}

function applyItalicMarkdown(
  options: IApplySpecificOptions,
): IApplyMarkdownResult {
  return applyBoldItalicMarkdown({ ...options, mode: "italic" });
}

function applyBoldItalicMarkdown({
  selectionEnd,
  selectionStart,
  message,
  mode,
}: IApplySpecificOptions & { mode: "bold" | "italic" }): IApplyMarkdownResult {
  const BOLD_MD = "**";
  const ITALIC_MD = "*";

  const isForceBold = mode === "bold";
  const isForceItalic = mode === "italic";

  let prefix = message.slice(0, selectionStart);
  let selection = message.slice(selectionStart, selectionEnd);
  let suffix = message.slice(selectionEnd);

  let newStart = selectionStart;
  let newEnd = selectionEnd;

  if (selection.endsWith(" ")) {
    selection = selection.slice(0, -1);
    suffix = ` ${suffix}`;
    newEnd -= 1;
  }

  if (selection.startsWith(" ")) {
    selection = selection.slice(1);
    prefix = `${prefix} `;
    newStart += 1;
  }

  let isItalicFollowedByBold = false;
  let delimiter = "";

  if (isForceBold) {
    delimiter = BOLD_MD;
  } else if (isForceItalic) {
    delimiter = ITALIC_MD;
    isItalicFollowedByBold =
      prefix.endsWith(BOLD_MD) && suffix.startsWith(BOLD_MD);
  }

  const hasCurrentMarkdown =
    prefix.endsWith(delimiter) && suffix.startsWith(delimiter);
  const hasItalicAndBold =
    prefix.endsWith(BOLD_MD + ITALIC_MD) &&
    suffix.startsWith(BOLD_MD + ITALIC_MD);

  let newValue: string;

  if (hasItalicAndBold || (hasCurrentMarkdown && !isItalicFollowedByBold)) {
    newValue =
      prefix.slice(0, prefix.length - delimiter.length) +
      selection +
      suffix.slice(delimiter.length);
    newStart -= delimiter.length;
    newEnd -= delimiter.length;
  } else {
    newValue = prefix + delimiter + selection + delimiter + suffix;
    newStart += delimiter.length;
    newEnd += delimiter.length;
  }

  return { message: newValue, selectionStart: newStart, selectionEnd: newEnd };
}

/**
 * Apply link markdown with optional URL.
 */
export function applyLinkMarkdown({
  selectionEnd,
  selectionStart,
  message,
  url = DEFAULT_PLACEHOLDER_URL,
}: IApplyLinkMarkdownOptions): IApplyMarkdownResult {
  const prefix = message.slice(0, selectionStart);
  const selection = message.slice(selectionStart, selectionEnd);
  const suffix = message.slice(selectionEnd);

  const delimiterStart = "[";
  const delimiterEnd = `](${url})`;

  const hasMarkdown =
    prefix.endsWith(delimiterStart) && suffix.startsWith(delimiterEnd);

  let newValue: string;
  let newStart: number;
  let newEnd: number;

  const urlShift = delimiterStart.length + 2; // '['.length + ']('.length

  if (hasMarkdown) {
    newValue =
      prefix.slice(0, prefix.length - delimiterStart.length) +
      selection +
      suffix.slice(delimiterEnd.length);
    newStart = selectionStart - delimiterStart.length;
    newEnd = selectionEnd - delimiterStart.length;
  } else if (message.length === 0) {
    newValue = delimiterStart + delimiterEnd;
    newStart = delimiterStart.length;
    newEnd = delimiterStart.length;
  } else if (selectionStart < selectionEnd) {
    newValue = prefix + delimiterStart + selection + delimiterEnd + suffix;
    newStart = selectionEnd + urlShift;
    newEnd = newStart + url.length;
  } else {
    const spaceBefore = prefix.charAt(prefix.length - 1) === " ";
    const spaceAfter = suffix.charAt(0) === " ";
    const cursorBeforeWord =
      (selectionStart !== 0 && spaceBefore && !spaceAfter) ||
      (selectionStart === 0 && !spaceAfter);
    const cursorAfterWord =
      (selectionEnd !== message.length && spaceAfter && !spaceBefore) ||
      (selectionEnd === message.length && !spaceBefore);

    if (cursorBeforeWord) {
      const word = message.slice(
        selectionStart,
        findWordEnd(message, selectionStart),
      );
      newValue =
        prefix +
        delimiterStart +
        word +
        delimiterEnd +
        suffix.slice(word.length);
      newStart = selectionStart + word.length + urlShift;
      newEnd = newStart + urlShift;
    } else if (cursorAfterWord) {
      const cursorAtEndOfLine =
        selectionStart === selectionEnd && selectionEnd === message.length;
      if (cursorAtEndOfLine) {
        newValue = message + " " + delimiterStart + delimiterEnd;
        newStart = selectionEnd + 1 + delimiterStart.length;
        newEnd = newStart;
      } else {
        const word = message.slice(
          findWordStart(message, selectionStart),
          selectionStart,
        );
        newValue =
          prefix.slice(0, prefix.length - word.length) +
          delimiterStart +
          word +
          delimiterEnd +
          suffix;
        newStart = selectionStart + urlShift;
        newEnd = newStart + urlShift;
      }
    } else {
      const wordStart = findWordStart(message, selectionStart);
      const wordEnd = findWordEnd(message, selectionStart);
      const word = message.slice(wordStart, wordEnd);
      newValue =
        prefix.slice(0, wordStart) +
        delimiterStart +
        word +
        delimiterEnd +
        message.slice(wordEnd);
      newStart = wordEnd + urlShift;
      newEnd = newStart + urlShift;
    }
  }

  return { message: newValue, selectionStart: newStart, selectionEnd: newEnd };
}

function applyCodeMarkdown({
  selectionEnd,
  selectionStart,
  message,
}: IApplySpecificOptions): IApplyMarkdownResult {
  if (isSelectionMultiline(message, selectionStart, selectionEnd)) {
    return applyMarkdownToSelection({
      selectionEnd,
      selectionStart,
      message,
      delimiterStart: "```\n",
      delimiterEnd: "\n```",
    });
  }
  return applyMarkdownToSelection({
    selectionEnd,
    selectionStart,
    message,
    delimiter: "`",
  });
}

//#endregion Apply Markdown

//#region Helpers

function getMultilineSuffix(suffix: string): string {
  if (suffix.startsWith("\n")) {
    return "";
  }
  return suffix.indexOf("\n") === -1
    ? suffix
    : suffix.slice(0, suffix.indexOf("\n"));
}

function getNewSuffix(suffix: string): string {
  if (suffix.startsWith("\n")) {
    return suffix;
  }
  return suffix.indexOf("\n") === -1 ? "" : suffix.slice(suffix.indexOf("\n"));
}

function findWordEnd(text: string, start: number): number {
  const wordEnd = text.indexOf(" ", start);
  return wordEnd === -1 ? text.length : wordEnd;
}

function findWordStart(text: string, start: number): number {
  const wordStart = text.lastIndexOf(" ", start - 1) + 1;
  return wordStart === -1 ? 0 : wordStart;
}

function isSelectionMultiline(
  message: string,
  selectionStart: number,
  selectionEnd: number,
): boolean {
  return message.slice(selectionStart, selectionEnd).includes("\n");
}

function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

//#endregion Helpers
````

### Index Export

```typescript
// apps/v2/src/utils/markdown/index.ts

export {
  parseMarkdown,
  stripMarkdown,
  parseImageDimensions,
  applyMarkdown,
  applyLinkMarkdown,
} from "./markdown";

export type {
  IMarkdownMode,
  IMarkdownToken,
  IApplyMarkdownOptions,
  IApplyMarkdownResult,
  IApplyLinkMarkdownOptions,
  IImageDimensions,
} from "./markdown";
```

### Utils Index Update

```typescript
// apps/v2/src/utils/index.ts

export * from "./markdown";
```

## Package Dependency

```bash
pnpm --filter @retrievly/app add marked
pnpm --filter @retrievly/app add -D @types/marked
```

## Supported Markdown Syntax

| Syntax          | Markdown       | Example Input        | Parsed Token Type |
| --------------- | -------------- | -------------------- | ----------------- |
| Bold            | `**text**`     | `**bold**`           | `strong`          |
| Italic          | `*text*`       | `*italic*`           | `em`              |
| Strikethrough   | `~~text~~`     | `~~deleted~~`        | `del`             |
| Inline Code     | `` `code` ``   | `` `code` ``         | `codespan`        |
| Code Block      | ` ``` `        | ` ```js\ncode\n``` ` | `code`            |
| Link            | `[text](url)`  | `[link](url)`        | `link`            |
| Image           | `![alt](url)`  | `![img](url)`        | `image`           |
| Heading         | `# text`       | `# Title`            | `heading`         |
| Blockquote      | `> text`       | `> quote`            | `blockquote`      |
| Unordered List  | `- item`       | `- item`             | `list`            |
| Ordered List    | `1. item`      | `1. item`            | `list`            |
| Task List       | `- [ ] task`   | `- [x] done`         | `list_item`       |
| Horizontal Rule | `---`          | `---`                | `hr`              |
| Table           | `\| a \| b \|` | `\| H1 \| H2 \|`     | `table`           |
| Line Break      | `\n\n`         | double newline       | `space`           |

## Acceptance Criteria

- [ ] `parseMarkdown` returns valid token array from marked lexer
- [ ] `stripMarkdown` removes all formatting, returns plain text
- [ ] `parseImageDimensions` extracts width/height from image URLs
- [ ] `applyMarkdown` handles all modes: bold, italic, link, strike, code, heading, quote, ul, ol
- [ ] `applyLinkMarkdown` correctly wraps text or inserts placeholder
- [ ] All types exported with `I` prefix
- [ ] No `any` types
- [ ] TypeScript strict mode passes
- [ ] Exported from `utils/index.ts`

## Testing

````typescript
// apps/v2/src/utils/markdown/markdown.spec.ts

import {
  parseMarkdown,
  stripMarkdown,
  parseImageDimensions,
  applyMarkdown,
  applyLinkMarkdown,
} from "./markdown";

describe("parseMarkdown", () => {
  it("parses bold text into tokens", () => {
    const tokens = parseMarkdown("**bold**");

    expect(tokens).toHaveLength(1);
    expect(tokens[0].type).toBe("paragraph");
  });

  it("parses multiple inline elements", () => {
    const tokens = parseMarkdown("**bold** and *italic*");

    expect(tokens).toHaveLength(1);
  });

  it("parses code blocks with language", () => {
    const tokens = parseMarkdown("```js\nconst x = 1;\n```");

    expect(tokens.some((t) => t.type === "code")).toBe(true);
  });

  it("parses lists", () => {
    const tokens = parseMarkdown("- item 1\n- item 2");

    expect(tokens.some((t) => t.type === "list")).toBe(true);
  });
});

describe("stripMarkdown", () => {
  it("removes bold formatting", () => {
    expect(stripMarkdown("**bold**")).toBe("bold");
  });

  it("removes italic formatting", () => {
    expect(stripMarkdown("*italic*")).toBe("italic");
  });

  it("removes link formatting, keeps text", () => {
    expect(stripMarkdown("[link text](https://example.com)")).toBe("link text");
  });

  it("removes code block formatting", () => {
    expect(stripMarkdown("```\ncode\n```")).toBe("code");
  });

  it("handles empty string", () => {
    expect(stripMarkdown("")).toBe("");
  });

  it("handles plain text without changes", () => {
    expect(stripMarkdown("plain text")).toBe("plain text");
  });

  it("removes multiple formatting types", () => {
    expect(stripMarkdown("**bold** and *italic* and `code`")).toBe(
      "bold and italic and code",
    );
  });
});

describe("parseImageDimensions", () => {
  it("extracts width and height", () => {
    const result = parseImageDimensions("image.png =100x200");

    expect(result).toEqual({
      href: "image.png",
      width: "100",
      height: "200",
    });
  });

  it("extracts width only, sets height to auto", () => {
    const result = parseImageDimensions("image.png =100");

    expect(result).toEqual({
      href: "image.png",
      width: "100",
      height: "auto",
    });
  });

  it("extracts height only, sets width to auto", () => {
    const result = parseImageDimensions("image.png =x200");

    expect(result).toEqual({
      href: "image.png",
      width: "auto",
      height: "200",
    });
  });

  it("returns original href when no dimensions", () => {
    const result = parseImageDimensions("image.png");

    expect(result).toEqual({
      href: "image.png",
      width: "",
      height: "",
    });
  });
});

describe("applyMarkdown", () => {
  describe("bold", () => {
    it("wraps selection with **", () => {
      const result = applyMarkdown({
        markdownMode: "bold",
        selectionStart: 0,
        selectionEnd: 4,
        message: "text",
      });

      expect(result.message).toBe("**text**");
      expect(result.selectionStart).toBe(2);
      expect(result.selectionEnd).toBe(6);
    });

    it("removes ** when already applied", () => {
      const result = applyMarkdown({
        markdownMode: "bold",
        selectionStart: 2,
        selectionEnd: 6,
        message: "**text**",
      });

      expect(result.message).toBe("text");
    });
  });

  describe("italic", () => {
    it("wraps selection with *", () => {
      const result = applyMarkdown({
        markdownMode: "italic",
        selectionStart: 0,
        selectionEnd: 4,
        message: "text",
      });

      expect(result.message).toBe("*text*");
    });
  });

  describe("code", () => {
    it("wraps inline selection with `", () => {
      const result = applyMarkdown({
        markdownMode: "code",
        selectionStart: 0,
        selectionEnd: 4,
        message: "code",
      });

      expect(result.message).toBe("`code`");
    });

    it("wraps multiline selection with ```", () => {
      const result = applyMarkdown({
        markdownMode: "code",
        selectionStart: 0,
        selectionEnd: 10,
        message: "line1\nline2",
      });

      expect(result.message).toBe("```\nline1\nline2\n```");
    });
  });

  describe("strike", () => {
    it("wraps selection with ~~", () => {
      const result = applyMarkdown({
        markdownMode: "strike",
        selectionStart: 0,
        selectionEnd: 4,
        message: "text",
      });

      expect(result.message).toBe("~~text~~");
    });
  });

  describe("heading", () => {
    it("prepends ### to line", () => {
      const result = applyMarkdown({
        markdownMode: "heading",
        selectionStart: 0,
        selectionEnd: 5,
        message: "title",
      });

      expect(result.message).toBe("### title");
    });
  });

  describe("quote", () => {
    it("prepends > to line", () => {
      const result = applyMarkdown({
        markdownMode: "quote",
        selectionStart: 0,
        selectionEnd: 5,
        message: "quote",
      });

      expect(result.message).toBe("> quote");
    });
  });

  describe("ul", () => {
    it("prepends - to line", () => {
      const result = applyMarkdown({
        markdownMode: "ul",
        selectionStart: 0,
        selectionEnd: 4,
        message: "item",
      });

      expect(result.message).toBe("- item");
    });
  });

  describe("ol", () => {
    it("prepends 1. to line", () => {
      const result = applyMarkdown({
        markdownMode: "ol",
        selectionStart: 0,
        selectionEnd: 4,
        message: "item",
      });

      expect(result.message).toBe("1. item");
    });

    it("numbers multiple lines sequentially", () => {
      const result = applyMarkdown({
        markdownMode: "ol",
        selectionStart: 0,
        selectionEnd: 11,
        message: "one\ntwo\nthree",
      });

      expect(result.message).toBe("1. one\n2. two\n3. three");
    });
  });

  it("handles null selection gracefully", () => {
    const result = applyMarkdown({
      markdownMode: "bold",
      selectionStart: null,
      selectionEnd: null,
      message: "text",
    });

    expect(result.message).toBe("text");
    expect(result.selectionStart).toBe(4);
    expect(result.selectionEnd).toBe(4);
  });
});

describe("applyLinkMarkdown", () => {
  it("wraps selection as link text", () => {
    const result = applyLinkMarkdown({
      selectionStart: 0,
      selectionEnd: 4,
      message: "text",
    });

    expect(result.message).toBe("[text](url)");
  });

  it("uses provided URL", () => {
    const result = applyLinkMarkdown({
      selectionStart: 0,
      selectionEnd: 4,
      message: "text",
      url: "https://example.com",
    });

    expect(result.message).toBe("[text](https://example.com)");
  });

  it("creates empty link on empty message", () => {
    const result = applyLinkMarkdown({
      selectionStart: 0,
      selectionEnd: 0,
      message: "",
    });

    expect(result.message).toBe("[](url)");
  });
});
````

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- markdown.spec
```
