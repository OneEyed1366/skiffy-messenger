# T4.06: URL Utilities

## Metadata

| Field        | Value                 |
| ------------ | --------------------- |
| **ID**       | T4.06                 |
| **Layer**    | L4 - Formatting Utils |
| **Status**   | pending               |
| **Priority** | medium                |
| **Estimate** | 2h                    |
| **Parallel** | true                  |
| **Assignee** | -                     |
| **Created**  | 2026-01-04            |
| **Updated**  | 2026-01-04            |

## Dependencies

| Task ID | Name         |
| ------- | ------------ |
| T2.03   | utils-string |

## Blocks

| Task ID | Name                  |
| ------- | --------------------- |
| T4.02   | utils-text-formatting |

## Description

Migrate URL utilities from Mattermost. The original `url.tsx` contains various URL manipulation functions. We extract and modernize the core utilities using the native `URL` API for parsing and construction, removing React/intl dependencies.

## Source Files

- `vendor/desktop/webapp/channels/src/utils/url.tsx`

### Source Analysis

Key functions from source:

1. **`isValidUrl`** (line 283-286): Simple regex check for `https?://` prefix
2. **`isInternalURL`** (line 243-245): Checks if URL starts with siteURL, `/`, or `#`
3. **`getScheme`** (line 104-108): Extracts protocol scheme from URL
4. **`removeScheme`** (line 110-112): Strips protocol from URL
5. **`isUrlSafe`** (line 80-94): XSS protection - blocks javascript:/vbscript:/data: URLs
6. **`getShortenedURL`** (line 33-39): Truncates long URLs with ellipsis
7. **`validHttpUrl`** (line 358-373): Parses and validates HTTP URLs using native URL API

Additional patterns observed:

- Uses native `URL` constructor for parsing (line 367)
- Protocol normalization with `parseLink` function
- Domain extraction via `location.hostname`

## Target File

`apps/v2/src/utils/url/url.ts`

## Implementation

```typescript
// apps/v2/src/utils/url/url.ts

//#region Types

type IUrlParts = {
  protocol: string;
  hostname: string;
  port: string;
  pathname: string;
  search: string;
  hash: string;
  origin: string;
};

type IQueryParams = Record<
  string,
  string | number | boolean | undefined | null
>;

//#endregion Types

//#region Validation

/**
 * Checks if a string is a valid HTTP/HTTPS URL.
 *
 * @param url - The URL string to validate
 * @returns True if the URL starts with http:// or https://
 *
 * @example
 * isValidUrl('https://example.com'); // true
 * isValidUrl('ftp://example.com');   // false
 * isValidUrl('example.com');         // false
 */
export function isValidUrl(url: string): boolean {
  if (!url) {
    return false;
  }
  return /^https?:\/\//i.test(url);
}

/**
 * Checks if a URL is safe (not a dangerous protocol like javascript:, vbscript:, data:).
 * Protects against XSS attacks via URL injection.
 *
 * @param url - The URL string to check
 * @returns True if the URL is safe to use
 *
 * @example
 * isUrlSafe('https://example.com');     // true
 * isUrlSafe('javascript:alert(1)');     // false
 * isUrlSafe('data:text/html,...');      // false
 */
export function isUrlSafe(url: string): boolean {
  if (!url) {
    return true;
  }

  let decoded: string;
  try {
    decoded = decodeURIComponent(url);
  } catch {
    decoded = unescape(url);
  }

  const normalized = decoded.replace(/[^\w:]/g, "").toLowerCase();

  return (
    !normalized.startsWith("javascript:") &&
    !normalized.startsWith("vbscript:") &&
    !normalized.startsWith("data:")
  );
}

//#endregion Validation

//#region Parsing

/**
 * Parses a URL string into its component parts using the native URL API.
 * Returns null if the URL is invalid.
 *
 * @param url - The URL string to parse
 * @returns The parsed URL parts or null if invalid
 *
 * @example
 * parseUrl('https://example.com:8080/path?q=1#hash');
 * // => { protocol: 'https:', hostname: 'example.com', port: '8080', ... }
 *
 * parseUrl('invalid');
 * // => null
 */
export function parseUrl(url: string): IUrlParts | null {
  if (!url) {
    return null;
  }

  try {
    const parsed = new URL(url);
    return {
      protocol: parsed.protocol,
      hostname: parsed.hostname,
      port: parsed.port,
      pathname: parsed.pathname,
      search: parsed.search,
      hash: parsed.hash,
      origin: parsed.origin,
    };
  } catch {
    return null;
  }
}

/**
 * Extracts the domain (hostname) from a URL.
 *
 * @param url - The URL string
 * @returns The domain/hostname or null if invalid
 *
 * @example
 * getUrlDomain('https://example.com/path'); // 'example.com'
 * getUrlDomain('https://sub.example.com');  // 'sub.example.com'
 * getUrlDomain('invalid');                  // null
 */
export function getUrlDomain(url: string): string | null {
  const parsed = parseUrl(url);
  return parsed?.hostname ?? null;
}

/**
 * Extracts the URL scheme/protocol.
 *
 * @param url - The URL string
 * @returns The scheme without colon (e.g., 'https') or null if not found
 *
 * @example
 * getScheme('https://example.com'); // 'https'
 * getScheme('ftp://files.com');     // 'ftp'
 * getScheme('example.com');         // null
 */
export function getScheme(url: string): string | null {
  if (!url) {
    return null;
  }
  const match = /^!?([a-z0-9+.-]+):/i.exec(url);
  return match?.[1] ?? null;
}

/**
 * Removes the scheme/protocol from a URL.
 *
 * @param url - The URL string
 * @returns The URL without the scheme
 *
 * @example
 * removeScheme('https://example.com/path'); // 'example.com/path'
 * removeScheme('example.com');              // 'example.com'
 */
export function removeScheme(url: string): string {
  if (!url) {
    return "";
  }
  return url.replace(/^([a-z0-9+.-]+):\/\//i, "");
}

//#endregion Parsing

//#region Building

/**
 * Builds a URL string from a base URL and optional path/query parameters.
 *
 * @param baseUrl - The base URL (e.g., 'https://example.com')
 * @param path - Optional path to append
 * @param params - Optional query parameters
 * @returns The constructed URL string or null if baseUrl is invalid
 *
 * @example
 * buildUrl('https://example.com', '/api/users', { page: 1, limit: 10 });
 * // => 'https://example.com/api/users?page=1&limit=10'
 *
 * buildUrl('https://example.com', '/search', { q: 'hello world' });
 * // => 'https://example.com/search?q=hello%20world'
 */
export function buildUrl(
  baseUrl: string,
  path?: string,
  params?: IQueryParams,
): string | null {
  if (!baseUrl) {
    return null;
  }

  try {
    const url = new URL(path ?? "", baseUrl);

    if (params) {
      for (const [key, value] of Object.entries(params)) {
        if (value !== undefined && value !== null) {
          url.searchParams.set(key, String(value));
        }
      }
    }

    return url.toString();
  } catch {
    return null;
  }
}

/**
 * Adds query parameters to an existing URL.
 *
 * @param url - The URL string
 * @param params - The query parameters to add
 * @returns The URL with added parameters or null if URL is invalid
 *
 * @example
 * addQueryParams('https://example.com/search', { q: 'test', page: 2 });
 * // => 'https://example.com/search?q=test&page=2'
 *
 * addQueryParams('https://example.com?existing=1', { new: 'param' });
 * // => 'https://example.com?existing=1&new=param'
 */
export function addQueryParams(
  url: string,
  params: IQueryParams,
): string | null {
  if (!url) {
    return null;
  }

  try {
    const parsed = new URL(url);

    for (const [key, value] of Object.entries(params)) {
      if (value !== undefined && value !== null) {
        parsed.searchParams.set(key, String(value));
      }
    }

    return parsed.toString();
  } catch {
    return null;
  }
}

/**
 * Removes query parameters from a URL.
 *
 * @param url - The URL string
 * @param keys - The parameter keys to remove
 * @returns The URL without the specified parameters or null if URL is invalid
 *
 * @example
 * removeQueryParams('https://example.com?a=1&b=2&c=3', ['a', 'c']);
 * // => 'https://example.com?b=2'
 *
 * removeQueryParams('https://example.com?token=secret', ['token']);
 * // => 'https://example.com'
 */
export function removeQueryParams(url: string, keys: string[]): string | null {
  if (!url) {
    return null;
  }

  try {
    const parsed = new URL(url);

    for (const key of keys) {
      parsed.searchParams.delete(key);
    }

    return parsed.toString();
  } catch {
    return null;
  }
}

//#endregion Building

//#region Domain Checks

/**
 * Checks if a URL is an internal link (same domain or relative path).
 *
 * @param url - The URL to check
 * @param siteUrl - The site's base URL for comparison
 * @returns True if the URL is internal (same domain, relative, or hash link)
 *
 * @example
 * isInternalLink('https://example.com/page', 'https://example.com'); // true
 * isInternalLink('/relative/path', 'https://example.com');           // true
 * isInternalLink('#section', 'https://example.com');                 // true
 * isInternalLink('https://other.com', 'https://example.com');        // false
 */
export function isInternalLink(url: string, siteUrl: string): boolean {
  if (!url) {
    return false;
  }

  // Relative paths and hash links are always internal
  if (url.startsWith("/") || url.startsWith("#")) {
    return true;
  }

  // Check if URL starts with siteUrl
  if (siteUrl && url.startsWith(siteUrl)) {
    return true;
  }

  // Compare domains
  const urlDomain = getUrlDomain(url);
  const siteDomain = getUrlDomain(siteUrl);

  if (!urlDomain || !siteDomain) {
    return false;
  }

  return urlDomain === siteDomain;
}

/**
 * Checks if two URLs have the same domain.
 *
 * @param url1 - First URL
 * @param url2 - Second URL
 * @returns True if both URLs have the same hostname
 *
 * @example
 * isSameDomain('https://example.com/a', 'https://example.com/b'); // true
 * isSameDomain('https://a.example.com', 'https://b.example.com'); // false
 */
export function isSameDomain(url1: string, url2: string): boolean {
  const domain1 = getUrlDomain(url1);
  const domain2 = getUrlDomain(url2);

  if (!domain1 || !domain2) {
    return false;
  }

  return domain1 === domain2;
}

//#endregion Domain Checks

//#region Formatting

/**
 * Shortens a URL for display by truncating the middle.
 *
 * @param url - The URL to shorten
 * @param maxLength - Maximum length (default: 35)
 * @returns The shortened URL with ellipsis if needed
 *
 * @example
 * getShortenedUrl('https://example.com/very/long/path/to/resource', 30);
 * // => 'https://exa...to/resource'
 */
export function getShortenedUrl(url: string, maxLength = 35): string {
  if (!url || url.length <= maxLength) {
    return url ?? "";
  }

  const prefixLength = 10;
  const suffixLength = maxLength - prefixLength - 3; // 3 for '...'

  return `${url.substring(0, prefixLength)}...${url.substring(url.length - suffixLength)}`;
}

/**
 * Ensures a URL has a protocol, defaulting to https.
 *
 * @param url - The URL string
 * @param defaultProtocol - Protocol to use if none present (default: 'https')
 * @returns URL with protocol
 *
 * @example
 * ensureProtocol('example.com');           // 'https://example.com'
 * ensureProtocol('http://example.com');    // 'http://example.com'
 * ensureProtocol('example.com', 'http');   // 'http://example.com'
 */
export function ensureProtocol(
  url: string,
  defaultProtocol: "http" | "https" = "https",
): string {
  if (!url) {
    return "";
  }

  if (url.startsWith("/")) {
    return url;
  }

  const scheme = getScheme(url);
  if (scheme) {
    return url;
  }

  return `${defaultProtocol}://${url}`;
}

//#endregion Formatting
```

## Index Export

```typescript
// apps/v2/src/utils/url/index.ts

export {
  isValidUrl,
  isUrlSafe,
  parseUrl,
  getUrlDomain,
  getScheme,
  removeScheme,
  buildUrl,
  addQueryParams,
  removeQueryParams,
  isInternalLink,
  isSameDomain,
  getShortenedUrl,
  ensureProtocol,
} from "./url";

export type { IUrlParts, IQueryParams } from "./url";
```

```typescript
// apps/v2/src/utils/index.ts (add to existing)

export * from "./url";
```

## Acceptance Criteria

- [ ] Uses native `URL` API for parsing/construction
- [ ] No React/intl dependencies (pure functions)
- [ ] All functions handle edge cases (null, empty, invalid URLs)
- [ ] XSS protection via `isUrlSafe`
- [ ] TypeScript strict mode passes
- [ ] No `any` types
- [ ] Exported from `utils/index.ts`
- [ ] Co-located tests pass

## Testing

```typescript
// apps/v2/src/utils/url/url.spec.ts

import {
  isValidUrl,
  isUrlSafe,
  parseUrl,
  getUrlDomain,
  getScheme,
  removeScheme,
  buildUrl,
  addQueryParams,
  removeQueryParams,
  isInternalLink,
  isSameDomain,
  getShortenedUrl,
  ensureProtocol,
} from "./url";

//#region isValidUrl

describe("isValidUrl", () => {
  it("returns true for https URLs", () => {
    expect(isValidUrl("https://example.com")).toBe(true);
  });

  it("returns true for http URLs", () => {
    expect(isValidUrl("http://example.com")).toBe(true);
  });

  it("returns false for ftp URLs", () => {
    expect(isValidUrl("ftp://example.com")).toBe(false);
  });

  it("returns false for URLs without protocol", () => {
    expect(isValidUrl("example.com")).toBe(false);
  });

  it("returns false for empty string", () => {
    expect(isValidUrl("")).toBe(false);
  });

  it("is case insensitive", () => {
    expect(isValidUrl("HTTPS://EXAMPLE.COM")).toBe(true);
  });
});

//#endregion isValidUrl

//#region isUrlSafe

describe("isUrlSafe", () => {
  it("returns true for https URLs", () => {
    expect(isUrlSafe("https://example.com")).toBe(true);
  });

  it("returns false for javascript: URLs", () => {
    expect(isUrlSafe("javascript:alert(1)")).toBe(false);
  });

  it("returns false for vbscript: URLs", () => {
    expect(isUrlSafe("vbscript:msgbox(1)")).toBe(false);
  });

  it("returns false for data: URLs", () => {
    expect(isUrlSafe("data:text/html,<script>alert(1)</script>")).toBe(false);
  });

  it("returns false for encoded javascript: URLs", () => {
    expect(isUrlSafe("javascript%3Aalert(1)")).toBe(false);
  });

  it("returns true for empty string", () => {
    expect(isUrlSafe("")).toBe(true);
  });
});

//#endregion isUrlSafe

//#region parseUrl

describe("parseUrl", () => {
  it("parses a complete URL", () => {
    const result = parseUrl("https://example.com:8080/path?q=1#hash");

    expect(result).toEqual({
      protocol: "https:",
      hostname: "example.com",
      port: "8080",
      pathname: "/path",
      search: "?q=1",
      hash: "#hash",
      origin: "https://example.com:8080",
    });
  });

  it("returns null for invalid URLs", () => {
    expect(parseUrl("not-a-url")).toBeNull();
  });

  it("returns null for empty string", () => {
    expect(parseUrl("")).toBeNull();
  });

  it("parses URL without port", () => {
    const result = parseUrl("https://example.com/path");

    expect(result?.port).toBe("");
    expect(result?.hostname).toBe("example.com");
  });
});

//#endregion parseUrl

//#region getUrlDomain

describe("getUrlDomain", () => {
  it("extracts domain from URL", () => {
    expect(getUrlDomain("https://example.com/path")).toBe("example.com");
  });

  it("extracts subdomain", () => {
    expect(getUrlDomain("https://sub.example.com")).toBe("sub.example.com");
  });

  it("returns null for invalid URL", () => {
    expect(getUrlDomain("invalid")).toBeNull();
  });
});

//#endregion getUrlDomain

//#region getScheme

describe("getScheme", () => {
  it("extracts https scheme", () => {
    expect(getScheme("https://example.com")).toBe("https");
  });

  it("extracts ftp scheme", () => {
    expect(getScheme("ftp://files.com")).toBe("ftp");
  });

  it("returns null for URL without scheme", () => {
    expect(getScheme("example.com")).toBeNull();
  });

  it("returns null for empty string", () => {
    expect(getScheme("")).toBeNull();
  });
});

//#endregion getScheme

//#region removeScheme

describe("removeScheme", () => {
  it("removes https scheme", () => {
    expect(removeScheme("https://example.com/path")).toBe("example.com/path");
  });

  it("returns original if no scheme", () => {
    expect(removeScheme("example.com")).toBe("example.com");
  });

  it("returns empty string for empty input", () => {
    expect(removeScheme("")).toBe("");
  });
});

//#endregion removeScheme

//#region buildUrl

describe("buildUrl", () => {
  it("builds URL with path and params", () => {
    const result = buildUrl("https://example.com", "/api/users", {
      page: 1,
      limit: 10,
    });

    expect(result).toBe("https://example.com/api/users?page=1&limit=10");
  });

  it("encodes special characters in params", () => {
    const result = buildUrl("https://example.com", "/search", {
      q: "hello world",
    });

    expect(result).toBe("https://example.com/search?q=hello+world");
  });

  it("skips undefined and null params", () => {
    const result = buildUrl("https://example.com", "/api", {
      a: 1,
      b: undefined,
      c: null,
    });

    expect(result).toBe("https://example.com/api?a=1");
  });

  it("returns null for invalid base URL", () => {
    expect(buildUrl("not-a-url", "/path")).toBeNull();
  });

  it("returns null for empty base URL", () => {
    expect(buildUrl("", "/path")).toBeNull();
  });
});

//#endregion buildUrl

//#region addQueryParams

describe("addQueryParams", () => {
  it("adds params to URL without query string", () => {
    const result = addQueryParams("https://example.com/path", {
      a: 1,
      b: "test",
    });

    expect(result).toBe("https://example.com/path?a=1&b=test");
  });

  it("adds params to URL with existing query string", () => {
    const result = addQueryParams("https://example.com?existing=1", {
      new: "param",
    });

    expect(result).toBe("https://example.com/?existing=1&new=param");
  });

  it("returns null for invalid URL", () => {
    expect(addQueryParams("invalid", { a: 1 })).toBeNull();
  });
});

//#endregion addQueryParams

//#region removeQueryParams

describe("removeQueryParams", () => {
  it("removes specified params", () => {
    const result = removeQueryParams("https://example.com?a=1&b=2&c=3", [
      "a",
      "c",
    ]);

    expect(result).toBe("https://example.com/?b=2");
  });

  it("removes all params if all keys specified", () => {
    const result = removeQueryParams("https://example.com?token=secret", [
      "token",
    ]);

    expect(result).toBe("https://example.com/");
  });

  it("returns null for invalid URL", () => {
    expect(removeQueryParams("invalid", ["a"])).toBeNull();
  });
});

//#endregion removeQueryParams

//#region isInternalLink

describe("isInternalLink", () => {
  const siteUrl = "https://example.com";

  it("returns true for same domain", () => {
    expect(isInternalLink("https://example.com/page", siteUrl)).toBe(true);
  });

  it("returns true for relative paths", () => {
    expect(isInternalLink("/relative/path", siteUrl)).toBe(true);
  });

  it("returns true for hash links", () => {
    expect(isInternalLink("#section", siteUrl)).toBe(true);
  });

  it("returns false for different domain", () => {
    expect(isInternalLink("https://other.com", siteUrl)).toBe(false);
  });

  it("returns false for empty URL", () => {
    expect(isInternalLink("", siteUrl)).toBe(false);
  });
});

//#endregion isInternalLink

//#region isSameDomain

describe("isSameDomain", () => {
  it("returns true for same domain", () => {
    expect(isSameDomain("https://example.com/a", "https://example.com/b")).toBe(
      true,
    );
  });

  it("returns false for different subdomains", () => {
    expect(isSameDomain("https://a.example.com", "https://b.example.com")).toBe(
      false,
    );
  });

  it("returns false for invalid URLs", () => {
    expect(isSameDomain("invalid", "https://example.com")).toBe(false);
  });
});

//#endregion isSameDomain

//#region getShortenedUrl

describe("getShortenedUrl", () => {
  it("returns original URL if under max length", () => {
    expect(getShortenedUrl("https://example.com", 35)).toBe(
      "https://example.com",
    );
  });

  it("truncates long URLs with ellipsis", () => {
    const longUrl = "https://example.com/very/long/path/to/resource/file.html";
    const result = getShortenedUrl(longUrl, 30);

    expect(result.length).toBe(30);
    expect(result).toContain("...");
  });

  it("returns empty string for empty input", () => {
    expect(getShortenedUrl("")).toBe("");
  });
});

//#endregion getShortenedUrl

//#region ensureProtocol

describe("ensureProtocol", () => {
  it("adds https to URL without protocol", () => {
    expect(ensureProtocol("example.com")).toBe("https://example.com");
  });

  it("preserves existing http protocol", () => {
    expect(ensureProtocol("http://example.com")).toBe("http://example.com");
  });

  it("preserves existing https protocol", () => {
    expect(ensureProtocol("https://example.com")).toBe("https://example.com");
  });

  it("uses custom default protocol", () => {
    expect(ensureProtocol("example.com", "http")).toBe("http://example.com");
  });

  it("preserves relative paths", () => {
    expect(ensureProtocol("/relative/path")).toBe("/relative/path");
  });

  it("returns empty string for empty input", () => {
    expect(ensureProtocol("")).toBe("");
  });
});

//#endregion ensureProtocol
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- url.spec
```
