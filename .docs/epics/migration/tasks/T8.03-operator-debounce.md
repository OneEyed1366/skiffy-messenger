# T8.03: debounceAfterN Operator

## Metadata

| Field        | Value               |
| ------------ | ------------------- |
| **ID**       | T8.03               |
| **Layer**    | L8 - WebSocket RxJS |
| **Status**   | pending             |
| **Priority** | high                |
| **Estimate** | 1.5h                |
| **Parallel** | T7.12               |
| **Assignee** | -                   |
| **Created**  | 2026-01-05          |
| **Updated**  | 2026-01-05          |

## Dependencies

| Task ID | Name              |
| ------- | ----------------- |
| -       | (no dependencies) |

## Blocks

| Task ID | Name                    |
| ------- | ----------------------- |
| T8.02   | WebSocket Event Streams |

## Description

Create a custom RxJS operator `debounceAfterN` that matches the vendor's `debouncePostEvent` behavior exactly. This operator is critical for the `posts$` stream to avoid adding latency to single posts while still batching rapid bursts.

## Source Files

- `vendor/desktop/webapp/channels/src/actions/websocket_actions.jsx` (lines 730-767)

### Source Analysis

**Vendor `debouncePostEvent` behavior:**

```javascript
function debouncePostEvent(wait) {
  let timeout;
  let queue = [];
  let count = 0;

  const triggered = () => {
    timeout = null;
    if (queue.length > 0) {
      dispatch(handleNewPostEvents(queue));
    }
    queue = [];
    count = 0;
  };

  return function fx(msg) {
    if (timeout && count > 4) {
      // After first 5: queue events
      if (queue.push(msg) > 200) {
        queue = []; // Overflow protection
        console.log("channel broken because of too many incoming messages");
      }
      clearTimeout(timeout);
      timeout = setTimeout(triggered, wait);
    } else {
      // First 5: dispatch immediately
      count += 1;
      dispatch(handleNewPostEvent(msg));
      clearTimeout(timeout);
      timeout = setTimeout(triggered, wait);
    }
  };
}

const handleNewPostEventDebounced = debouncePostEvent(100);
```

**Key behavior:**

| Phase    | Events      | Handling                            |
| -------- | ----------- | ----------------------------------- |
| First 5  | 1-5         | Dispatched IMMEDIATELY              |
| After 5  | 6+          | Queued, flushed after 100ms silence |
| Overflow | >200 queued | Queue cleared (protection)          |
| Reset    | After flush | Count resets to 0                   |

**Why this matters:**

| Scenario            | `bufferTime(100)` | `debounceAfterN(5, 100)`        |
| ------------------- | ----------------- | ------------------------------- |
| Single post arrives | 100ms delay       | 0ms delay                       |
| 3 posts in 50ms     | 100ms delay       | 0ms delay                       |
| 100 posts burst     | 100ms delay       | First 5 immediate, rest batched |

## Migration Target

- **Target File**: `apps/v2/src/services/websocket/operators/debounceAfterN.ts`
- **Test File**: `apps/v2/src/services/websocket/operators/debounceAfterN.spec.ts`
- **Index Export**: `apps/v2/src/services/websocket/operators/index.ts`

## Implementation

### Operator

````typescript
// apps/v2/src/services/websocket/operators/debounceAfterN.ts

import { Observable, OperatorFunction } from "rxjs";

/**
 * Emits first N items immediately as single-item arrays.
 * After N items, buffers and flushes after `wait` ms of silence.
 * Resets count after each flush (matching vendor behavior).
 *
 * This operator matches vendor debouncePostEvent from:
 * vendor/desktop/webapp/channels/src/actions/websocket_actions.jsx:730-767
 *
 * @param n - Number of items to emit immediately before buffering (vendor: 5)
 * @param wait - Buffer flush delay in ms after silence (vendor: 100)
 * @param maxQueueSize - Max queue size before dropping (vendor: 200)
 * @returns OperatorFunction that emits arrays of T
 *
 * @example
 * ```typescript
 * source$.pipe(
 *   debounceAfterN(5, 100, 200),
 *   mergeMap(batch => of(...batch)),
 * )
 * ```
 */
export function debounceAfterN<T>(
  n: number,
  wait: number,
  maxQueueSize = 200,
): OperatorFunction<T, T[]> {
  return (source$: Observable<T>) =>
    new Observable<T[]>((subscriber) => {
      let count = 0;
      let queue: T[] = [];
      let timeoutId: ReturnType<typeof setTimeout> | null = null;

      const clearTimer = () => {
        if (timeoutId !== null) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
      };

      const flush = () => {
        timeoutId = null;
        if (queue.length > 0) {
          subscriber.next([...queue]);
          queue = [];
        }
        count = 0; // Reset for next batch (matches vendor)
      };

      const subscription = source$.subscribe({
        next: (value) => {
          clearTimer();

          if (count < n) {
            // First N items: emit immediately as single-item batch
            count++;
            subscriber.next([value]);
            timeoutId = setTimeout(flush, wait);
          } else {
            // After N: queue for batch
            if (queue.length < maxQueueSize) {
              queue.push(value);
            } else {
              // Overflow protection (vendor: "channel broken")
              console.warn(
                "[debounceAfterN] Queue overflow (%d items), dropping queued events",
                maxQueueSize,
              );
              queue = [];
            }
            timeoutId = setTimeout(flush, wait);
          }
        },
        error: (err) => {
          clearTimer();
          subscriber.error(err);
        },
        complete: () => {
          clearTimer();
          // Flush remaining queue on complete
          if (queue.length > 0) {
            subscriber.next(queue);
          }
          subscriber.complete();
        },
      });

      // Cleanup on unsubscribe
      return () => {
        clearTimer();
        subscription.unsubscribe();
      };
    });
}
````

### Index Export

```typescript
// apps/v2/src/services/websocket/operators/index.ts

export { debounceAfterN } from "./debounceAfterN";
```

## Unit Tests

```typescript
// apps/v2/src/services/websocket/operators/debounceAfterN.spec.ts

import { Subject, of } from "rxjs";
import { toArray } from "rxjs/operators";
import { debounceAfterN } from "./debounceAfterN";

describe("debounceAfterN", () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  describe("immediate emission (first N items)", () => {
    it("emits first N items immediately as single-item arrays", () => {
      const results: number[][] = [];
      const subject = new Subject<number>();

      subject.pipe(debounceAfterN(5, 100)).subscribe((batch) => {
        results.push(batch);
      });

      // Emit 5 items
      subject.next(1);
      subject.next(2);
      subject.next(3);
      subject.next(4);
      subject.next(5);

      // All 5 should be emitted immediately
      expect(results).toEqual([[1], [2], [3], [4], [5]]);
    });

    it("does not wait for timeout for first N items", () => {
      const results: string[][] = [];
      const subject = new Subject<string>();

      subject.pipe(debounceAfterN(3, 100)).subscribe((batch) => {
        results.push(batch);
      });

      subject.next("a");
      expect(results).toEqual([["a"]]);

      subject.next("b");
      expect(results).toEqual([["a"], ["b"]]);

      subject.next("c");
      expect(results).toEqual([["a"], ["b"], ["c"]]);
    });
  });

  describe("buffering (after N items)", () => {
    it("queues items after N and flushes after wait time", () => {
      const results: number[][] = [];
      const subject = new Subject<number>();

      subject.pipe(debounceAfterN(3, 100)).subscribe((batch) => {
        results.push(batch);
      });

      // First 3: immediate
      subject.next(1);
      subject.next(2);
      subject.next(3);
      expect(results).toEqual([[1], [2], [3]]);

      // Next 3: queued
      subject.next(4);
      subject.next(5);
      subject.next(6);
      expect(results).toEqual([[1], [2], [3]]); // Still only first 3

      // After timeout: batch emitted
      jest.advanceTimersByTime(100);
      expect(results).toEqual([[1], [2], [3], [4, 5, 6]]);
    });

    it("resets timer on each new item in queue", () => {
      const results: number[][] = [];
      const subject = new Subject<number>();

      subject.pipe(debounceAfterN(2, 100)).subscribe((batch) => {
        results.push(batch);
      });

      subject.next(1);
      subject.next(2); // Now queuing starts

      subject.next(3);
      jest.advanceTimersByTime(50); // 50ms

      subject.next(4);
      jest.advanceTimersByTime(50); // 50ms more (100ms total from item 3, but timer reset)

      // Should not have flushed yet
      expect(results).toEqual([[1], [2]]);

      jest.advanceTimersByTime(50); // 100ms from last item
      expect(results).toEqual([[1], [2], [3, 4]]);
    });
  });

  describe("count reset after flush", () => {
    it("resets count to 0 after flush, allowing immediate emission again", () => {
      const results: string[][] = [];
      const subject = new Subject<string>();

      subject.pipe(debounceAfterN(2, 100)).subscribe((batch) => {
        results.push(batch);
      });

      // First batch: a, b immediate, c queued
      subject.next("a");
      subject.next("b");
      subject.next("c");

      jest.advanceTimersByTime(100); // Flush
      expect(results).toEqual([["a"], ["b"], ["c"]]);

      // After flush, count reset - d, e should be immediate
      subject.next("d");
      expect(results).toEqual([["a"], ["b"], ["c"], ["d"]]);

      subject.next("e");
      expect(results).toEqual([["a"], ["b"], ["c"], ["d"], ["e"]]);
    });
  });

  describe("overflow protection", () => {
    it("clears queue when maxQueueSize exceeded", () => {
      const results: number[][] = [];
      const consoleSpy = jest.spyOn(console, "warn").mockImplementation();
      const subject = new Subject<number>();

      subject.pipe(debounceAfterN(2, 100, 3)).subscribe((batch) => {
        results.push(batch);
      });

      // First 2: immediate
      subject.next(1);
      subject.next(2);

      // Next 3: fill queue
      subject.next(3);
      subject.next(4);
      subject.next(5);

      // This triggers overflow (queue had 3, adding 4th > maxQueueSize)
      subject.next(6);

      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining("Queue overflow"),
        3,
      );

      // After timeout: queue was cleared, so nothing batched
      jest.advanceTimersByTime(100);
      expect(results).toEqual([[1], [2]]);

      consoleSpy.mockRestore();
    });
  });

  describe("completion handling", () => {
    it("flushes remaining queue on complete", async () => {
      const result = await of(1, 2, 3, 4, 5)
        .pipe(debounceAfterN(3, 100), toArray())
        .toPromise();

      // First 3 immediate, last 2 flushed on complete
      expect(result).toEqual([[1], [2], [3], [4, 5]]);
    });

    it("completes without emission if queue empty", async () => {
      const result = await of(1, 2)
        .pipe(debounceAfterN(5, 100), toArray())
        .toPromise();

      expect(result).toEqual([[1], [2]]);
    });
  });

  describe("error handling", () => {
    it("clears timer and propagates error", () => {
      const results: number[][] = [];
      let receivedError: Error | null = null;
      const subject = new Subject<number>();

      subject.pipe(debounceAfterN(2, 100)).subscribe({
        next: (batch) => results.push(batch),
        error: (err) => {
          receivedError = err;
        },
      });

      subject.next(1);
      subject.next(2);
      subject.next(3); // Queued

      const testError = new Error("Test error");
      subject.error(testError);

      expect(receivedError).toBe(testError);
      expect(results).toEqual([[1], [2]]); // Queued item not flushed on error
    });
  });

  describe("unsubscription", () => {
    it("clears timer on unsubscribe", () => {
      const subject = new Subject<number>();
      const subscription = subject
        .pipe(debounceAfterN(2, 100))
        .subscribe(() => {});

      subject.next(1);
      subject.next(2);
      subject.next(3); // Queued, timer started

      subscription.unsubscribe();

      // Should not throw or cause issues
      jest.advanceTimersByTime(100);
    });
  });
});
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- debounceAfterN
```

## Usage in posts$

```typescript
// apps/v2/src/services/websocket/streams/posts$.ts

import { filter, mergeMap, of, share } from "rxjs";
import { debounceAfterN } from "../operators";

export const posts$ = websocketService.events$.pipe(
  filter(isPostEvent),
  debounceAfterN(5, 100, 200), // Matches vendor exactly
  mergeMap((batch) => of(...batch.map(transformPost))),
  share(),
);
```

## Acceptance Criteria

- [ ] First N items emitted immediately as single-item arrays
- [ ] Items after N are queued and flushed after wait ms
- [ ] Timer resets on each new item (debounce behavior)
- [ ] Count resets to 0 after flush
- [ ] Queue cleared when maxQueueSize exceeded (overflow protection)
- [ ] Console warning logged on overflow
- [ ] Remaining queue flushed on source complete
- [ ] Timer cleared on error and unsubscribe
- [ ] All unit tests pass
- [ ] TypeScript strict mode passes

## Notes

- This operator is specifically designed to match vendor behavior for WebSocket post events
- The "debounce after N" pattern is uncommon — most apps would use simple `bufferTime`
- Overflow protection prevents memory exhaustion during message storms
- Count reset after flush allows the pattern to repeat (burst → batch → reset → next burst)
