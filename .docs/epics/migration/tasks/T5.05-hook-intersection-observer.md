# T5.05: IntersectionObserver Hook

## Metadata

| Field        | Value           |
| ------------ | --------------- |
| **ID**       | T5.05           |
| **Layer**    | L5 - Pure Hooks |
| **Status**   | pending         |
| **Priority** | medium          |
| **Estimate** | 4h              |
| **Parallel** | true            |
| **Assignee** | -               |
| **Created**  | 2026-01-04      |
| **Updated**  | 2026-01-04      |

## Dependencies

| Task ID | Name          |
| ------- | ------------- |
| T0.15   | types-utility |

## Blocks

| Task ID | Name                                 |
| ------- | ------------------------------------ |
| T6.\*   | Components with lazy loading         |
| T10b.\* | Components with visibility detection |
| T10c.\* | Lazy loading components              |
| T10c.\* | Infinite scroll lists                |

## Description

IntersectionObserver wrapper for visibility detection. The original `useSectionNavigation` hook uses the native `IntersectionObserver` API to track which sections are visible in the viewport.

For React Native mobile, use `@shopify/flash-list` viewability callbacks or custom scroll-based detection as an alternative, since `IntersectionObserver` API is not available.

## Source Files

- `vendor/desktop/webapp/channels/src/components/common/hooks/useSectionNavigation.ts` (lines 1-85)
- `vendor/desktop/webapp/channels/src/components/admin_console/ldap_wizard/ldap_wizard.tsx` (lines 40-44 - observer options)

### Source Analysis

The original implementation:

- **IntersectionObserver API**: Browser-native visibility detection
- **Section tracking**: Tracks which sections are visible via `data-section-key` attribute
- **Active section**: Determines first visible section in DOM order
- **Configurable options**: Accepts `IntersectionObserverInit` for root, rootMargin, threshold

Key patterns:
| Pattern | Purpose |
|---------|---------|
| `sectionRefs` | Ref object mapping section keys to DOM elements |
| `intersectingSectionKeys` | Set of currently visible section keys |
| `observerCallback` | Updates visibility state on intersection changes |
| `observerOptions` | Configures detection zone (rootMargin, threshold) |

## Migration Target

- **Target File (Web)**: `apps/v2/src/hooks/useIntersectionObserver/useIntersectionObserver.ts`
- **Target File (RN)**: `apps/v2/src/hooks/useIntersectionObserver/useIntersectionObserver.native.ts`
- **Index Export**: `apps/v2/src/hooks/useIntersectionObserver/index.ts`

## Implementation (Web)

```typescript
// apps/v2/src/hooks/useIntersectionObserver/useIntersectionObserver.ts

/**
 * IntersectionObserver hook for visibility detection (Web)
 * Migrated from: vendor/desktop/webapp/channels/src/components/common/hooks/useSectionNavigation.ts
 *
 * @platform web
 */

import { useEffect, useRef, useState, useCallback } from "react";

//#region Types

type IIntersectionObserverOptions = {
  /**
   * Element that is used as the viewport for checking visibility.
   * Defaults to browser viewport if null.
   */
  root?: Element | Document | null;

  /**
   * Margin around the root. Can have values similar to CSS margin.
   * @example "-40% 0px -40% 0px" - Active when in middle 20% of viewport
   */
  rootMargin?: string;

  /**
   * Number or array of numbers between 0.0 and 1.0, indicating at what
   * percentage of target visibility the callback should be executed.
   */
  threshold?: number | number[];

  /**
   * Whether to freeze observation once element becomes visible.
   * Useful for lazy-loading scenarios.
   */
  freezeOnceVisible?: boolean;

  /**
   * Initial state before first observation.
   */
  initialIsIntersecting?: boolean;

  /**
   * Callback when intersection changes.
   */
  onChange?: (entry: IntersectionObserverEntry) => void;
};

type IIntersectionObserverResult = {
  /**
   * Whether the target element is currently intersecting.
   */
  isIntersecting: boolean;

  /**
   * The IntersectionObserverEntry from the latest observation.
   */
  entry: IntersectionObserverEntry | null;

  /**
   * Ref callback to attach to the target element.
   */
  ref: React.RefCallback<Element>;
};

//#endregion Types

//#region Hook

/**
 * Hook to observe element visibility using IntersectionObserver API.
 *
 * @param options - IntersectionObserver configuration options
 * @returns Object with isIntersecting state, entry data, and ref callback
 *
 * @example
 * function LazyImage({ src }: { src: string }) {
 *   const { ref, isIntersecting } = useIntersectionObserver({
 *     threshold: 0.1,
 *     freezeOnceVisible: true,
 *   });
 *
 *   return (
 *     <div ref={ref}>
 *       {isIntersecting ? <img src={src} /> : <Placeholder />}
 *     </div>
 *   );
 * }
 */
export function useIntersectionObserver(
  options: IIntersectionObserverOptions = {},
): IIntersectionObserverResult {
  const {
    root = null,
    rootMargin = "0px",
    threshold = 0,
    freezeOnceVisible = false,
    initialIsIntersecting = false,
    onChange,
  } = options;

  const [entry, setEntry] = useState<IntersectionObserverEntry | null>(null);
  const [isIntersecting, setIsIntersecting] = useState(initialIsIntersecting);
  const frozen = useRef(false);
  const elementRef = useRef<Element | null>(null);
  const observerRef = useRef<IntersectionObserver | null>(null);

  const ref = useCallback((node: Element | null) => {
    elementRef.current = node;
  }, []);

  useEffect(() => {
    const element = elementRef.current;

    // Skip if frozen (for freezeOnceVisible)
    if (frozen.current) {
      return;
    }

    // Cleanup previous observer
    if (observerRef.current) {
      observerRef.current.disconnect();
      observerRef.current = null;
    }

    // Skip if no element or no IntersectionObserver support
    if (!element || typeof IntersectionObserver === "undefined") {
      return;
    }

    const observerCallback = (entries: IntersectionObserverEntry[]) => {
      const [latestEntry] = entries;
      setEntry(latestEntry);
      setIsIntersecting(latestEntry.isIntersecting);
      onChange?.(latestEntry);

      if (freezeOnceVisible && latestEntry.isIntersecting) {
        frozen.current = true;
        observerRef.current?.disconnect();
      }
    };

    observerRef.current = new IntersectionObserver(observerCallback, {
      root,
      rootMargin,
      threshold,
    });

    observerRef.current.observe(element);

    return () => {
      observerRef.current?.disconnect();
    };
  }, [root, rootMargin, threshold, freezeOnceVisible, onChange]);

  return {
    isIntersecting,
    entry,
    ref,
  };
}

//#endregion Hook

//#region Multi-Element Hook

type IMultiIntersectionObserverOptions<K extends string> = {
  /**
   * Array of unique keys identifying each section.
   */
  keys: K[];

  /**
   * IntersectionObserver options.
   */
  observerOptions?: IntersectionObserverInit;
};

type IMultiIntersectionObserverResult<K extends string> = {
  /**
   * The currently active section key (first visible in DOM order).
   */
  activeKey: K | null;

  /**
   * Set of all currently intersecting section keys.
   */
  intersectingKeys: Set<K>;

  /**
   * Ref object to attach to section elements.
   * Usage: ref={(el) => { refs.current[key] = el; }}
   */
  refs: React.MutableRefObject<Record<K, HTMLElement | null>>;

  /**
   * Manually set the active key (for programmatic navigation).
   */
  setActiveKey: (key: K | null) => void;
};

/**
 * Hook to observe multiple section elements for visibility.
 * Useful for scroll-spy navigation patterns.
 *
 * @param options - Configuration with section keys and observer options
 * @returns Object with active key, intersecting keys set, refs, and setter
 *
 * @example
 * function PageWithSections() {
 *   const { activeKey, refs } = useMultiIntersectionObserver({
 *     keys: ['section1', 'section2', 'section3'],
 *     observerOptions: {
 *       rootMargin: '-40% 0px -40% 0px',
 *       threshold: 0.01,
 *     },
 *   });
 *
 *   return (
 *     <div>
 *       <nav>Active: {activeKey}</nav>
 *       <section ref={(el) => { refs.current['section1'] = el; }}>...</section>
 *       <section ref={(el) => { refs.current['section2'] = el; }}>...</section>
 *       <section ref={(el) => { refs.current['section3'] = el; }}>...</section>
 *     </div>
 *   );
 * }
 */
export function useMultiIntersectionObserver<K extends string>(
  options: IMultiIntersectionObserverOptions<K>,
): IMultiIntersectionObserverResult<K> {
  const { keys, observerOptions = {} } = options;

  const [activeKey, setActiveKey] = useState<K | null>(
    keys.length > 0 ? keys[0] : null,
  );
  const [intersectingKeys, setIntersectingKeys] = useState<Set<K>>(new Set());
  const refs = useRef<Record<K, HTMLElement | null>>(
    {} as Record<K, HTMLElement | null>,
  );

  useEffect(() => {
    if (keys.length === 0 || typeof IntersectionObserver === "undefined") {
      return;
    }

    const observerCallback = (entries: IntersectionObserverEntry[]) => {
      setIntersectingKeys((prevKeys) => {
        const newKeys = new Set(prevKeys);

        for (const entry of entries) {
          const key = (entry.target as HTMLElement).dataset.sectionKey as
            | K
            | undefined;

          if (key) {
            if (entry.isIntersecting) {
              newKeys.add(key);
            } else {
              newKeys.delete(key);
            }
          }
        }

        return newKeys;
      });
    };

    const observer = new IntersectionObserver(
      observerCallback,
      observerOptions,
    );

    for (const key of keys) {
      const element = refs.current[key];
      if (element) {
        element.dataset.sectionKey = key;
        observer.observe(element);
      }
    }

    return () => {
      observer.disconnect();
    };
  }, [keys, observerOptions]);

  // Determine active key from intersecting keys
  useEffect(() => {
    if (intersectingKeys.size === 0) {
      return;
    }

    // Find first key in DOM order that is intersecting
    for (const key of keys) {
      if (intersectingKeys.has(key)) {
        setActiveKey(key);
        return;
      }
    }
  }, [intersectingKeys, keys]);

  return {
    activeKey,
    intersectingKeys,
    refs,
    setActiveKey,
  };
}

//#endregion Multi-Element Hook

//#region Type Exports

export type {
  IIntersectionObserverOptions,
  IIntersectionObserverResult,
  IMultiIntersectionObserverOptions,
  IMultiIntersectionObserverResult,
};

//#endregion Type Exports
```

## Implementation (React Native)

```typescript
// apps/v2/src/hooks/useIntersectionObserver/useIntersectionObserver.native.ts

/**
 * IntersectionObserver hook for visibility detection (React Native)
 *
 * Uses scroll-based detection since IntersectionObserver is not available in RN.
 * For list items, use @shopify/flash-list viewability callbacks instead.
 *
 * @platform native
 */

import { useRef, useState, useCallback } from "react";
import type { LayoutChangeEvent, View, ViewToken } from "react-native";

//#region Types

type IIntersectionEntry = {
  /** Whether the element is currently visible */
  isIntersecting: boolean;
  /** Percentage of element visible (0-1) */
  intersectionRatio: number;
  /** Element's bounding rect */
  boundingClientRect: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
};

type IIntersectionObserverOptions = {
  /**
   * Visibility threshold (0-1), default 0.
   */
  threshold?: number;

  /**
   * Root margin (pixels to extend/shrink viewport).
   */
  rootMargin?: number;

  /**
   * Whether to freeze observation once element becomes visible.
   * Useful for lazy-loading scenarios.
   */
  freezeOnceVisible?: boolean;

  /**
   * Initial state before first observation.
   */
  initialIsIntersecting?: boolean;

  /**
   * Callback when intersection changes.
   */
  onChange?: (entry: IIntersectionEntry) => void;
};

type IIntersectionObserverResult = {
  /**
   * Ref to attach to observed element.
   */
  ref: React.RefObject<View>;

  /**
   * Whether element is currently intersecting.
   */
  isIntersecting: boolean;

  /**
   * Current intersection entry.
   */
  entry: IIntersectionEntry | null;

  /**
   * Layout handler for the observed element.
   */
  onLayout: (event: LayoutChangeEvent) => void;

  /**
   * Call this with scroll position to check visibility.
   */
  checkVisibility: (viewportHeight: number, scrollY: number) => void;
};

//#endregion Types

//#region Hook

/**
 * Detects when element becomes visible in viewport.
 * React Native implementation using layout measurements.
 *
 * @param options - Configuration options
 * @returns Ref, visibility state, and handlers
 *
 * @example
 * function LazyImage({ src }: { src: string }) {
 *   const { ref, isIntersecting, onLayout, checkVisibility } =
 *     useIntersectionObserver({ freezeOnceVisible: true });
 *
 *   return (
 *     <View ref={ref} onLayout={onLayout}>
 *       {isIntersecting ? (
 *         <Image source={{ uri: src }} />
 *       ) : (
 *         <View style={styles.placeholder} />
 *       )}
 *     </View>
 *   );
 * }
 */
export function useIntersectionObserver(
  options: IIntersectionObserverOptions = {},
): IIntersectionObserverResult {
  const {
    threshold = 0,
    rootMargin = 0,
    freezeOnceVisible = false,
    initialIsIntersecting = false,
    onChange,
  } = options;

  const ref = useRef<View>(null);
  const [entry, setEntry] = useState<IIntersectionEntry | null>(null);
  const [elementLayout, setElementLayout] = useState<{
    y: number;
    height: number;
    x: number;
    width: number;
  } | null>(null);
  const hasTriggered = useRef(false);

  const onLayout = useCallback((event: LayoutChangeEvent) => {
    const { x, y, width, height } = event.nativeEvent.layout;
    setElementLayout({ x, y, width, height });
  }, []);

  const checkVisibility = useCallback(
    (viewportHeight: number, scrollY: number) => {
      if (!elementLayout) return;
      if (freezeOnceVisible && hasTriggered.current) return;

      const adjustedViewportTop = scrollY - rootMargin;
      const adjustedViewportBottom = scrollY + viewportHeight + rootMargin;
      const elementTop = elementLayout.y;
      const elementBottom = elementLayout.y + elementLayout.height;

      // Calculate how much of the element is visible
      const visibleTop = Math.max(elementTop, adjustedViewportTop);
      const visibleBottom = Math.min(elementBottom, adjustedViewportBottom);
      const visibleHeight = Math.max(0, visibleBottom - visibleTop);
      const intersectionRatio =
        elementLayout.height > 0 ? visibleHeight / elementLayout.height : 0;

      const isIntersecting = intersectionRatio >= threshold;

      const newEntry: IIntersectionEntry = {
        isIntersecting,
        intersectionRatio,
        boundingClientRect: {
          x: elementLayout.x,
          y: elementLayout.y,
          width: elementLayout.width,
          height: elementLayout.height,
        },
      };

      // Only update if intersection state changed
      if (entry?.isIntersecting !== isIntersecting) {
        setEntry(newEntry);
        onChange?.(newEntry);

        if (isIntersecting && freezeOnceVisible) {
          hasTriggered.current = true;
        }
      }
    },
    [elementLayout, entry, threshold, rootMargin, freezeOnceVisible, onChange],
  );

  return {
    ref,
    isIntersecting: entry?.isIntersecting ?? initialIsIntersecting,
    entry,
    onLayout,
    checkVisibility,
  };
}

//#endregion Hook

//#region FlashList Viewability Helpers

type IViewabilityConfig = {
  /**
   * Minimum percentage of item that must be visible.
   */
  itemVisiblePercentThreshold?: number;

  /**
   * Minimum time (ms) item must be visible before considered viewable.
   */
  minimumViewTime?: number;

  /**
   * Whether items at top/bottom edges are considered viewable.
   */
  waitForInteraction?: boolean;
};

type IViewableItemsChangeInfo<T> = {
  viewableItems: ViewToken<T>[];
  changed: ViewToken<T>[];
};

type IViewableItemsHandler<T> = (info: IViewableItemsChangeInfo<T>) => void;

/**
 * Creates a viewability config for FlashList/FlatList.
 *
 * @param threshold - Percentage visible (0-100)
 * @returns ViewabilityConfig object
 *
 * @example
 * const viewabilityConfig = createViewabilityConfig(50);
 * <FlashList viewabilityConfig={viewabilityConfig} ... />
 */
export function createViewabilityConfig(
  threshold: number = 50,
): IViewabilityConfig {
  return {
    itemVisiblePercentThreshold: threshold,
    minimumViewTime: 0,
    waitForInteraction: false,
  };
}

/**
 * Creates a handler for tracking visible item IDs.
 *
 * @param onVisibleIdsChange - Callback when visible IDs change
 * @param keyExtractor - Function to extract ID from item
 * @returns onViewableItemsChanged handler
 *
 * @example
 * const handleViewable = createViewableItemsHandler<IMessage>(
 *   (ids) => setVisibleMessageIds(ids),
 *   (item) => item.id,
 * );
 * <FlashList onViewableItemsChanged={handleViewable} ... />
 */
export function createViewableItemsHandler<T>(
  onVisibleIdsChange: (ids: Set<string>) => void,
  keyExtractor: (item: T) => string,
): IViewableItemsHandler<T> {
  return ({ viewableItems }) => {
    const visibleIds = new Set<string>();

    for (const token of viewableItems) {
      if (token.item && token.isViewable) {
        visibleIds.add(keyExtractor(token.item));
      }
    }

    onVisibleIdsChange(visibleIds);
  };
}

//#endregion FlashList Viewability Helpers

//#region Multi-Element Hook (Scroll-based)

type IMultiIntersectionObserverOptions<K extends string> = {
  /**
   * Array of unique keys identifying each section.
   */
  keys: K[];

  /**
   * Unused in RN - for API compatibility with web.
   */
  observerOptions?: unknown;
};

type IMultiIntersectionObserverResult<K extends string> = {
  /**
   * The currently active section key (first visible in DOM order).
   */
  activeKey: K | null;

  /**
   * Set of all currently intersecting section keys.
   */
  intersectingKeys: Set<K>;

  /**
   * Ref object to store layout measurements.
   */
  refs: React.MutableRefObject<Record<K, View | null>>;

  /**
   * Layout measurements for each section.
   */
  layouts: React.MutableRefObject<
    Record<K, { y: number; height: number } | null>
  >;

  /**
   * Manually set the active key (for programmatic navigation).
   */
  setActiveKey: (key: K | null) => void;

  /**
   * Create an onLayout handler for a section.
   */
  createLayoutHandler: (key: K) => (event: LayoutChangeEvent) => void;

  /**
   * Check visibility of all sections based on scroll position.
   */
  checkVisibility: (viewportHeight: number, scrollY: number) => void;
};

/**
 * Multi-element visibility detection for React Native.
 * Useful for scroll-spy navigation patterns.
 *
 * @param options - Configuration with section keys
 * @returns Object with active key, intersecting keys, refs, and handlers
 *
 * @example
 * function PageWithSections() {
 *   const { activeKey, refs, createLayoutHandler, checkVisibility } =
 *     useMultiIntersectionObserver({ keys: ['section1', 'section2'] });
 *
 *   return (
 *     <ScrollView
 *       onScroll={(e) => checkVisibility(
 *         e.nativeEvent.layoutMeasurement.height,
 *         e.nativeEvent.contentOffset.y
 *       )}
 *     >
 *       <View
 *         ref={(el) => { refs.current['section1'] = el; }}
 *         onLayout={createLayoutHandler('section1')}
 *       >...</View>
 *       <View
 *         ref={(el) => { refs.current['section2'] = el; }}
 *         onLayout={createLayoutHandler('section2')}
 *       >...</View>
 *     </ScrollView>
 *   );
 * }
 */
export function useMultiIntersectionObserver<K extends string>(
  options: IMultiIntersectionObserverOptions<K>,
): IMultiIntersectionObserverResult<K> {
  const { keys } = options;

  const [activeKey, setActiveKey] = useState<K | null>(
    keys.length > 0 ? keys[0] : null,
  );
  const [intersectingKeys, setIntersectingKeys] = useState<Set<K>>(new Set());
  const refs = useRef<Record<K, View | null>>({} as Record<K, View | null>);
  const layouts = useRef<Record<K, { y: number; height: number } | null>>(
    {} as Record<K, { y: number; height: number } | null>,
  );

  const createLayoutHandler = useCallback(
    (key: K) => (event: LayoutChangeEvent) => {
      const { y, height } = event.nativeEvent.layout;
      layouts.current[key] = { y, height };
    },
    [],
  );

  const checkVisibility = useCallback(
    (viewportHeight: number, scrollY: number) => {
      const newIntersecting = new Set<K>();
      let firstIntersecting: K | null = null;

      for (const key of keys) {
        const layout = layouts.current[key];
        if (!layout) continue;

        const elementTop = layout.y;
        const elementBottom = layout.y + layout.height;
        const viewportTop = scrollY;
        const viewportBottom = scrollY + viewportHeight;

        // Check if element overlaps with viewport
        const isIntersecting =
          elementTop < viewportBottom && elementBottom > viewportTop;

        if (isIntersecting) {
          newIntersecting.add(key);
          if (!firstIntersecting) {
            firstIntersecting = key;
          }
        }
      }

      setIntersectingKeys(newIntersecting);
      if (firstIntersecting) {
        setActiveKey(firstIntersecting);
      }
    },
    [keys],
  );

  return {
    activeKey,
    intersectingKeys,
    refs,
    layouts,
    setActiveKey,
    createLayoutHandler,
    checkVisibility,
  };
}

//#endregion Multi-Element Hook (Scroll-based)

//#region Type Exports

export type {
  IIntersectionEntry,
  IIntersectionObserverOptions,
  IIntersectionObserverResult,
  IViewabilityConfig,
  IViewableItemsChangeInfo,
  IViewableItemsHandler,
  IMultiIntersectionObserverOptions,
  IMultiIntersectionObserverResult,
};

//#endregion Type Exports
```

## Index Export

```typescript
// apps/v2/src/hooks/useIntersectionObserver/index.ts

export {
  useIntersectionObserver,
  useMultiIntersectionObserver,
} from "./useIntersectionObserver";

export type {
  IIntersectionObserverOptions,
  IIntersectionObserverResult,
  IMultiIntersectionObserverOptions,
  IMultiIntersectionObserverResult,
} from "./useIntersectionObserver";
```

## Platform Notes

| Platform     | Implementation                              |
| ------------ | ------------------------------------------- |
| Web          | Native `IntersectionObserver` API           |
| React Native | Manual layout + scroll position calculation |

### Web Usage

```tsx
function LazyImage({ src }: { src: string }) {
  const { ref, isIntersecting } = useIntersectionObserver({
    threshold: 0.1,
    freezeOnceVisible: true,
  });

  return (
    <div ref={ref}>{isIntersecting ? <img src={src} /> : <Placeholder />}</div>
  );
}
```

### React Native with ScrollView

```tsx
function LazyLoadScreen() {
  const [scrollY, setScrollY] = useState(0);
  const [viewportHeight, setViewportHeight] = useState(0);

  const { ref, isIntersecting, onLayout, checkVisibility } =
    useIntersectionObserver({ freezeOnceVisible: true });

  useEffect(() => {
    checkVisibility(viewportHeight, scrollY);
  }, [scrollY, viewportHeight, checkVisibility]);

  return (
    <ScrollView
      onScroll={(e) => setScrollY(e.nativeEvent.contentOffset.y)}
      onLayout={(e) => setViewportHeight(e.nativeEvent.layout.height)}
      scrollEventThrottle={16}
    >
      <View ref={ref} onLayout={onLayout}>
        {isIntersecting ? <ExpensiveComponent /> : <Placeholder />}
      </View>
    </ScrollView>
  );
}
```

### React Native with FlashList

```tsx
import { FlashList } from "@shopify/flash-list";
import {
  createViewabilityConfig,
  createViewableItemsHandler,
} from "@/hooks/useIntersectionObserver/useIntersectionObserver.native";

function MessageList({ messages }: { messages: IMessage[] }) {
  const [visibleIds, setVisibleIds] = useState<Set<string>>(new Set());

  const viewabilityConfig = useMemo(() => createViewabilityConfig(50), []);
  const onViewableItemsChanged = useMemo(
    () => createViewableItemsHandler<IMessage>(setVisibleIds, (msg) => msg.id),
    [],
  );

  return (
    <FlashList
      data={messages}
      viewabilityConfig={viewabilityConfig}
      onViewableItemsChanged={onViewableItemsChanged}
      renderItem={({ item }) => (
        <MessageItem message={item} isVisible={visibleIds.has(item.id)} />
      )}
    />
  );
}
```

## Acceptance Criteria

- [ ] Web: `useIntersectionObserver` uses native IntersectionObserver API
- [ ] Web: `useMultiIntersectionObserver` tracks multiple sections for scroll-spy
- [ ] Web: `freezeOnceVisible` option stops observation after first intersection
- [ ] RN: `useIntersectionObserver` works with scroll position + layout measurement
- [ ] RN: `useMultiIntersectionObserver` tracks sections via onLayout + onScroll
- [ ] RN: FlashList helpers (`createViewabilityConfig`, `createViewableItemsHandler`)
- [ ] All types use `I` prefix naming convention
- [ ] TypeScript strict mode passes
- [ ] No `any` types
- [ ] Exported from `hooks/useIntersectionObserver/index.ts`
- [ ] Unit tests pass

## Testing

```typescript
// apps/v2/src/hooks/useIntersectionObserver/useIntersectionObserver.spec.tsx

import { renderHook, act } from "@testing-library/react-native";
import {
  useIntersectionObserver,
  useMultiIntersectionObserver,
} from "./useIntersectionObserver";

//#region useIntersectionObserver Tests

describe("useIntersectionObserver", () => {
  it("returns false initially", () => {
    const { result } = renderHook(() => useIntersectionObserver());

    expect(result.current.isIntersecting).toBe(false);
    expect(result.current.entry).toBeNull();
  });

  it("returns initial state when specified", () => {
    const { result } = renderHook(() =>
      useIntersectionObserver({ initialIsIntersecting: true }),
    );

    expect(result.current.isIntersecting).toBe(true);
  });

  it("detects element in viewport", () => {
    const { result } = renderHook(() => useIntersectionObserver());

    // Simulate element layout at y=100, height=50
    act(() => {
      result.current.onLayout({
        nativeEvent: { layout: { x: 0, y: 100, width: 200, height: 50 } },
      } as any);
    });

    // Check visibility with viewport showing 0-500
    act(() => {
      result.current.checkVisibility(500, 0);
    });

    expect(result.current.isIntersecting).toBe(true);
  });

  it("detects element outside viewport", () => {
    const { result } = renderHook(() => useIntersectionObserver());

    act(() => {
      result.current.onLayout({
        nativeEvent: { layout: { x: 0, y: 600, width: 200, height: 50 } },
      } as any);
    });

    // Viewport shows 0-500, element at 600
    act(() => {
      result.current.checkVisibility(500, 0);
    });

    expect(result.current.isIntersecting).toBe(false);
  });

  it("triggers onChange callback", () => {
    const onChange = jest.fn();
    const { result } = renderHook(() => useIntersectionObserver({ onChange }));

    act(() => {
      result.current.onLayout({
        nativeEvent: { layout: { x: 0, y: 100, width: 200, height: 50 } },
      } as any);
    });

    act(() => {
      result.current.checkVisibility(500, 0);
    });

    expect(onChange).toHaveBeenCalledWith(
      expect.objectContaining({ isIntersecting: true }),
    );
  });

  it("freezes after first visibility when freezeOnceVisible is true", () => {
    const onChange = jest.fn();
    const { result } = renderHook(() =>
      useIntersectionObserver({ freezeOnceVisible: true, onChange }),
    );

    act(() => {
      result.current.onLayout({
        nativeEvent: { layout: { x: 0, y: 100, width: 200, height: 50 } },
      } as any);
    });

    act(() => {
      result.current.checkVisibility(500, 0); // Visible
    });
    act(() => {
      result.current.checkVisibility(500, 200); // Scroll away
    });
    act(() => {
      result.current.checkVisibility(500, 0); // Scroll back
    });

    // onChange should only be called once
    expect(onChange).toHaveBeenCalledTimes(1);
    // Should remain intersecting
    expect(result.current.isIntersecting).toBe(true);
  });

  it("respects threshold option", () => {
    const { result } = renderHook(() =>
      useIntersectionObserver({ threshold: 0.5 }),
    );

    act(() => {
      result.current.onLayout({
        nativeEvent: { layout: { x: 0, y: 480, width: 200, height: 100 } },
      } as any);
    });

    // Only 20px of 100px element visible (20% < 50% threshold)
    act(() => {
      result.current.checkVisibility(500, 0);
    });

    expect(result.current.isIntersecting).toBe(false);
  });

  it("respects rootMargin option", () => {
    const { result } = renderHook(() =>
      useIntersectionObserver({ rootMargin: 100 }),
    );

    act(() => {
      result.current.onLayout({
        nativeEvent: { layout: { x: 0, y: 550, width: 200, height: 50 } },
      } as any);
    });

    // Element at 550, viewport 0-500, but rootMargin extends to 600
    act(() => {
      result.current.checkVisibility(500, 0);
    });

    expect(result.current.isIntersecting).toBe(true);
  });
});

//#endregion useIntersectionObserver Tests

//#region useMultiIntersectionObserver Tests

describe("useMultiIntersectionObserver", () => {
  it("sets first key as initial active key", () => {
    const { result } = renderHook(() =>
      useMultiIntersectionObserver({ keys: ["a", "b", "c"] }),
    );

    expect(result.current.activeKey).toBe("a");
  });

  it("handles empty keys array", () => {
    const { result } = renderHook(() =>
      useMultiIntersectionObserver({ keys: [] }),
    );

    expect(result.current.activeKey).toBeNull();
  });

  it("tracks visible sections", () => {
    const { result } = renderHook(() =>
      useMultiIntersectionObserver({ keys: ["a", "b", "c"] }),
    );

    // Set up layouts
    act(() => {
      result.current.createLayoutHandler("a")({
        nativeEvent: { layout: { y: 0, height: 200 } },
      } as any);
      result.current.createLayoutHandler("b")({
        nativeEvent: { layout: { y: 200, height: 200 } },
      } as any);
      result.current.createLayoutHandler("c")({
        nativeEvent: { layout: { y: 400, height: 200 } },
      } as any);
    });

    // Viewport shows 0-300
    act(() => {
      result.current.checkVisibility(300, 0);
    });

    expect(result.current.intersectingKeys.has("a")).toBe(true);
    expect(result.current.intersectingKeys.has("b")).toBe(true);
    expect(result.current.intersectingKeys.has("c")).toBe(false);
    expect(result.current.activeKey).toBe("a");
  });

  it("updates active key on scroll", () => {
    const { result } = renderHook(() =>
      useMultiIntersectionObserver({ keys: ["a", "b", "c"] }),
    );

    act(() => {
      result.current.createLayoutHandler("a")({
        nativeEvent: { layout: { y: 0, height: 200 } },
      } as any);
      result.current.createLayoutHandler("b")({
        nativeEvent: { layout: { y: 200, height: 200 } },
      } as any);
      result.current.createLayoutHandler("c")({
        nativeEvent: { layout: { y: 400, height: 200 } },
      } as any);
    });

    // Scroll to show b and c
    act(() => {
      result.current.checkVisibility(300, 250);
    });

    expect(result.current.activeKey).toBe("b");
  });

  it("allows manual active key override", () => {
    const { result } = renderHook(() =>
      useMultiIntersectionObserver({ keys: ["a", "b", "c"] }),
    );

    act(() => {
      result.current.setActiveKey("c");
    });

    expect(result.current.activeKey).toBe("c");
  });
});

//#endregion useMultiIntersectionObserver Tests
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- useIntersectionObserver
```

## Notes

- Web implementation uses native `IntersectionObserver` API (no polyfill needed for modern browsers)
- RN implementation requires manual scroll tracking via `onScroll` + `scrollEventThrottle`
- For list items in RN, prefer FlashList/FlatList viewability callbacks over this hook
- `freezeOnceVisible` is useful for lazy-loading (load once, never unload)
- The `rootMargin` option allows triggering before element enters viewport (preloading)
