# T5.11: useFocusTrap Hook

## Metadata

| Field        | Value      |
| ------------ | ---------- |
| **ID**       | T5.11      |
| **Layer**    | L5 - Hooks |
| **Status**   | pending    |
| **Priority** | high       |
| **Estimate** | 2h         |
| **Parallel** | true       |
| **Assignee** | -          |
| **Created**  | 2026-01-06 |
| **Updated**  | 2026-01-06 |

## Dependencies

| Task ID | Name |
| ------- | ---- |
| None    | -    |

## Blocks

| Task ID | Name              |
| ------- | ----------------- |
| T6.\*   | Modal components  |
| T10.\*  | Dialog components |

## Description

Focus trap hook for accessibility in modals/dialogs. Traps keyboard focus within a container element, cycling Tab/Shift+Tab between first and last focusable elements. Supports nested traps via a stack.

**Platform Note:** Web/Desktop only. React Native handles focus differently via `accessibilityViewIsModal` and `accessibilityElementsHidden`.

## Source Files

- `vendor/desktop/webapp/platform/components/src/hooks/useFocusTrap.ts` (lines 24-157)

## Migration Target

- **Target File**: `apps/v2/src/hooks/useFocusTrap/useFocusTrap.ts`
- **Index Export**: `apps/v2/src/hooks/useFocusTrap/index.ts`
- **Platform**: Web/Desktop only

## Implementation

```typescript
// apps/v2/src/hooks/useFocusTrap/useFocusTrap.ts

/**
 * Focus trap hook for modal accessibility
 * Migrated from: vendor/desktop/webapp/platform/components/src/hooks/useFocusTrap.ts
 *
 * @platform web - Uses DOM APIs not available in React Native
 */

import { useEffect, useRef } from "react";

//#region Types

type IFocusTrapOptions = {
  /** Focus first focusable element on mount (default: false) */
  initialFocus?: boolean;
  /** Restore focus to previously focused element on unmount (default: false) */
  restoreFocus?: boolean;
  /** Delay before initializing trap in ms (default: 0) */
  delayMs?: number;
};

//#endregion Types

//#region Constants

const FOCUSABLE_SELECTOR = [
  "a[href]",
  "button:not([disabled])",
  "input:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  '[tabindex]:not([tabindex="-1"])',
].join(", ");

//#endregion Constants

//#region Global Stack

// Stack for nested focus traps - only topmost trap handles events
const activeFocusTraps: HTMLElement[] = [];

//#endregion Global Stack

//#region Helper Functions

function getFocusableElements(container: HTMLElement): HTMLElement[] {
  const elements = container.querySelectorAll<HTMLElement>(FOCUSABLE_SELECTOR);
  return Array.from(elements).filter(isElementVisible);
}

function isElementVisible(element: HTMLElement): boolean {
  if (element.offsetParent === null) return false;
  const style = window.getComputedStyle(element);
  return style.display !== "none" && style.visibility !== "hidden";
}

//#endregion Helper Functions

//#region Hook

/**
 * Trap keyboard focus within a container element
 *
 * @param isActive - Whether the trap is active
 * @param containerRef - Ref to the container element
 * @param options - Configuration options
 *
 * @example
 * function Modal({ isOpen, onClose, children }) {
 *   const containerRef = useRef<HTMLDivElement>(null);
 *   useFocusTrap(isOpen, containerRef, { initialFocus: true, restoreFocus: true });
 *
 *   return isOpen ? (
 *     <div ref={containerRef} role="dialog" aria-modal="true">
 *       {children}
 *       <button onClick={onClose}>Close</button>
 *     </div>
 *   ) : null;
 * }
 */
export function useFocusTrap(
  isActive: boolean,
  containerRef: React.RefObject<HTMLElement>,
  options: IFocusTrapOptions = {},
): void {
  const { initialFocus = false, restoreFocus = false, delayMs = 0 } = options;
  const previouslyFocusedRef = useRef<HTMLElement | null>(null);
  const focusableElementsRef = useRef<HTMLElement[]>([]);

  useEffect(() => {
    if (!isActive || !containerRef.current) return;

    const container = containerRef.current;

    // Save currently focused element for restoration
    if (restoreFocus) {
      previouslyFocusedRef.current = document.activeElement as HTMLElement;
    }

    const initializeTrap = () => {
      // Add to stack
      activeFocusTraps.push(container);

      // Get focusable elements
      focusableElementsRef.current = getFocusableElements(container);

      // Focus first element if requested
      if (initialFocus && focusableElementsRef.current.length > 0) {
        focusableElementsRef.current[0].focus();
      }
    };

    const handleKeyDown = (event: KeyboardEvent) => {
      // Only handle if we're the topmost trap
      if (activeFocusTraps[activeFocusTraps.length - 1] !== container) return;
      if (event.key !== "Tab") return;

      // Refresh focusable elements (DOM may have changed)
      focusableElementsRef.current = getFocusableElements(container);
      const focusable = focusableElementsRef.current;

      if (focusable.length === 0) return;

      const firstElement = focusable[0];
      const lastElement = focusable[focusable.length - 1];

      if (event.shiftKey) {
        // Shift+Tab: if on first element, wrap to last
        if (document.activeElement === firstElement) {
          event.preventDefault();
          lastElement.focus();
        }
      } else {
        // Tab: if on last element, wrap to first
        if (document.activeElement === lastElement) {
          event.preventDefault();
          firstElement.focus();
        }
      }
    };

    // Initialize with optional delay
    const timeoutId = setTimeout(initializeTrap, delayMs);
    document.addEventListener("keydown", handleKeyDown);

    // Set up MutationObserver to refresh focusable elements
    const observer = new MutationObserver(() => {
      focusableElementsRef.current = getFocusableElements(container);
    });
    observer.observe(container, { childList: true, subtree: true });

    return () => {
      clearTimeout(timeoutId);
      document.removeEventListener("keydown", handleKeyDown);
      observer.disconnect();

      // Remove from stack
      const index = activeFocusTraps.indexOf(container);
      if (index !== -1) {
        activeFocusTraps.splice(index, 1);
      }

      // Restore focus
      if (restoreFocus && previouslyFocusedRef.current) {
        previouslyFocusedRef.current.focus();
      }
    };
  }, [isActive, containerRef, initialFocus, restoreFocus, delayMs]);
}

//#endregion Hook
```

## Index Export

```typescript
// apps/v2/src/hooks/useFocusTrap/index.ts

export { useFocusTrap } from "./useFocusTrap";
```

## Acceptance Criteria

- [ ] Traps Tab/Shift+Tab within container
- [ ] Supports nested traps (stack-based)
- [ ] `initialFocus` option focuses first element
- [ ] `restoreFocus` option restores focus on unmount
- [ ] Uses MutationObserver for dynamic content
- [ ] Properly cleans up on unmount
- [ ] All types use `I` prefix naming convention
- [ ] TypeScript strict mode passes
- [ ] No `any` types

## Testing

```typescript
// apps/v2/src/hooks/useFocusTrap/useFocusTrap.spec.tsx

/**
 * @jest-environment jsdom
 */

import { renderHook } from "@testing-library/react-native";
import { useRef } from "react";

import { useFocusTrap } from "./useFocusTrap";

//#region Test Setup

function createContainer(): HTMLDivElement {
  const container = document.createElement("div");
  container.innerHTML = `
    <button id="btn1">First</button>
    <input id="input1" type="text" />
    <button id="btn2">Last</button>
  `;
  document.body.appendChild(container);
  return container;
}

function cleanupContainer(container: HTMLDivElement): void {
  document.body.removeChild(container);
}

//#endregion Test Setup

describe("useFocusTrap", () => {
  let container: HTMLDivElement;

  beforeEach(() => {
    container = createContainer();
  });

  afterEach(() => {
    cleanupContainer(container);
  });

  it("does nothing when inactive", () => {
    const ref = { current: container };
    renderHook(() => useFocusTrap(false, ref));

    // Focus should not be trapped
    const btn1 = document.getElementById("btn1") as HTMLButtonElement;
    btn1.focus();
    expect(document.activeElement).toBe(btn1);
  });

  it("focuses first element when initialFocus is true", () => {
    const ref = { current: container };
    renderHook(() => useFocusTrap(true, ref, { initialFocus: true }));

    const btn1 = document.getElementById("btn1");
    expect(document.activeElement).toBe(btn1);
  });

  it("restores focus on unmount when restoreFocus is true", () => {
    const outsideButton = document.createElement("button");
    outsideButton.id = "outside";
    document.body.appendChild(outsideButton);
    outsideButton.focus();

    const ref = { current: container };
    const { unmount } = renderHook(() =>
      useFocusTrap(true, ref, { initialFocus: true, restoreFocus: true }),
    );

    unmount();

    expect(document.activeElement).toBe(outsideButton);
    document.body.removeChild(outsideButton);
  });

  it("handles Tab key to cycle focus", () => {
    const ref = { current: container };
    renderHook(() => useFocusTrap(true, ref, { initialFocus: true }));

    const btn2 = document.getElementById("btn2") as HTMLButtonElement;
    btn2.focus();

    // Simulate Tab on last element
    const tabEvent = new KeyboardEvent("keydown", {
      key: "Tab",
      bubbles: true,
    });
    document.dispatchEvent(tabEvent);

    // Focus should wrap to first
    const btn1 = document.getElementById("btn1");
    expect(document.activeElement).toBe(btn1);
  });

  it("handles Shift+Tab to cycle focus backwards", () => {
    const ref = { current: container };
    renderHook(() => useFocusTrap(true, ref, { initialFocus: true }));

    const btn1 = document.getElementById("btn1") as HTMLButtonElement;
    btn1.focus();

    // Simulate Shift+Tab on first element
    const shiftTabEvent = new KeyboardEvent("keydown", {
      key: "Tab",
      shiftKey: true,
      bubbles: true,
    });
    document.dispatchEvent(shiftTabEvent);

    // Focus should wrap to last
    const btn2 = document.getElementById("btn2");
    expect(document.activeElement).toBe(btn2);
  });
});
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- useFocusTrap
```

## Notes

### React Native Alternative

For React Native, focus trapping is handled via accessibility props:

```tsx
<View
  accessibilityViewIsModal={true}
  accessibilityElementsHidden={false}
  accessible={true}
>
  {/* Modal content */}
</View>
```

This informs screen readers that this view is a modal and other content should be hidden from accessibility tree.
