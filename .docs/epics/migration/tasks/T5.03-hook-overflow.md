# T5.03: Overflow Detection Hook

## Metadata

| Field        | Value         |
| ------------ | ------------- |
| **ID**       | T5.03         |
| **Layer**    | L5 - UI Hooks |
| **Status**   | pending       |
| **Priority** | medium        |
| **Estimate** | 2h            |
| **Parallel** | true          |
| **Assignee** | -             |
| **Created**  | 2026-01-04    |
| **Updated**  | 2026-01-04    |

## Dependencies

| Task ID | Name          |
| ------- | ------------- |
| T0.15   | types-utility |

## Blocks

| Task ID | Name                              |
| ------- | --------------------------------- |
| T10b.\* | Components with "show more" logic |

## Description

Migrate overflow detection logic from Mattermost web. The original uses DOM properties (`scrollHeight`, `scrollWidth`, `offsetHeight`, `offsetWidth`) to detect content overflow. In React Native, we compare content size vs container size from `onLayout` events.

## Source Files

- `vendor/desktop/webapp/channels/src/components/post_view/show_more/show_more.tsx` (lines 78-95)
- `vendor/desktop/webapp/channels/src/components/channel_banner/channel_banner.tsx` (lines 41-50)

### Source Analysis

The original implementations use:

| File                 | Approach                                                         |
| -------------------- | ---------------------------------------------------------------- |
| `show_more.tsx`      | `scrollHeight > maxHeight` with `requestAnimationFrame` debounce |
| `channel_banner.tsx` | `offsetWidth < scrollWidth` and `offsetHeight < scrollHeight`    |

Both patterns check if content exceeds container bounds. In RN, we must use `onLayout` since there's no DOM scroll/offset properties.

Key behaviors migrated:
| Original | Purpose |
|----------|---------|
| `checkTextOverflow()` | Compare scroll height vs container max height |
| `isOverflowingHorizontally` | Check horizontal text overflow |
| `isOverflowingVertically` | Check vertical text overflow |

## Migration Target

- **Target File**: `apps/v2/src/hooks/useIsOverflow/useIsOverflow.ts`
- **Index Export**: `apps/v2/src/hooks/useIsOverflow/index.ts`

## Implementation

````typescript
// apps/v2/src/hooks/useIsOverflow/useIsOverflow.ts

/**
 * Overflow detection hook for React Native
 * Migrated from: vendor/desktop/webapp/channels/src/components/post_view/show_more/show_more.tsx
 * Migrated from: vendor/desktop/webapp/channels/src/components/channel_banner/channel_banner.tsx
 *
 * Uses onLayout to compare content size vs container size
 */

import { useState } from "react";
import type { LayoutChangeEvent } from "react-native";

//#region Types

type IOverflowDirection = "vertical" | "horizontal" | "both";

type IOverflowState = {
  isOverflow: boolean;
  isVerticalOverflow: boolean;
  isHorizontalOverflow: boolean;
};

type IOverflowConfig = {
  /**
   * Direction to check for overflow
   * @default 'vertical'
   */
  direction?: IOverflowDirection;

  /**
   * Maximum height before content is considered overflowing (vertical)
   * If not provided, uses container height from layout
   */
  maxHeight?: number;

  /**
   * Maximum width before content is considered overflowing (horizontal)
   * If not provided, uses container width from layout
   */
  maxWidth?: number;
};

type IUseIsOverflowResult = IOverflowState & {
  /**
   * Attach to the container View's onLayout
   */
  onContainerLayout: (event: LayoutChangeEvent) => void;

  /**
   * Attach to the content View's onLayout
   */
  onContentLayout: (event: LayoutChangeEvent) => void;

  /**
   * Container dimensions (for debugging/display)
   */
  containerSize: { width: number; height: number };

  /**
   * Content dimensions (for debugging/display)
   */
  contentSize: { width: number; height: number };
};

//#endregion Types

//#region Constants

const INITIAL_SIZE = { width: 0, height: 0 };

//#endregion Constants

//#region Hook

/**
 * Detects if content overflows its container in React Native.
 *
 * Unlike web where we can check scrollHeight vs offsetHeight directly,
 * RN requires measuring both container and content via onLayout events.
 *
 * @param config - Configuration options
 * @returns Overflow state and layout handlers
 *
 * @example
 * ```tsx
 * function ExpandableText({ text, maxHeight = 100 }: IProps) {
 *   const { isOverflow, onContainerLayout, onContentLayout } = useIsOverflow({
 *     direction: 'vertical',
 *     maxHeight,
 *   });
 *
 *   const [expanded, setExpanded] = useState(false);
 *
 *   return (
 *     <View>
 *       <View
 *         style={[styles.container, !expanded && { maxHeight }]}
 *         onLayout={onContainerLayout}
 *       >
 *         <View onLayout={onContentLayout}>
 *           <Text>{text}</Text>
 *         </View>
 *       </View>
 *       {isOverflow && (
 *         <Pressable onPress={() => setExpanded(!expanded)}>
 *           <Text>{expanded ? 'Show less' : 'Show more'}</Text>
 *         </Pressable>
 *       )}
 *     </View>
 *   );
 * }
 * ```
 */
export function useIsOverflow(
  config: IOverflowConfig = {},
): IUseIsOverflowResult {
  const { direction = "vertical", maxHeight, maxWidth } = config;

  const [containerSize, setContainerSize] = useState(INITIAL_SIZE);
  const [contentSize, setContentSize] = useState(INITIAL_SIZE);

  const onContainerLayout = (event: LayoutChangeEvent) => {
    const { width, height } = event.nativeEvent.layout;
    setContainerSize({ width, height });
  };

  const onContentLayout = (event: LayoutChangeEvent) => {
    const { width, height } = event.nativeEvent.layout;
    setContentSize({ width, height });
  };

  // Calculate overflow based on direction and thresholds
  const effectiveMaxHeight = maxHeight ?? containerSize.height;
  const effectiveMaxWidth = maxWidth ?? containerSize.width;

  const isVerticalOverflow =
    effectiveMaxHeight > 0 && contentSize.height > effectiveMaxHeight;

  const isHorizontalOverflow =
    effectiveMaxWidth > 0 && contentSize.width > effectiveMaxWidth;

  let isOverflow = false;
  switch (direction) {
    case "vertical":
      isOverflow = isVerticalOverflow;
      break;
    case "horizontal":
      isOverflow = isHorizontalOverflow;
      break;
    case "both":
      isOverflow = isVerticalOverflow || isHorizontalOverflow;
      break;
  }

  return {
    isOverflow,
    isVerticalOverflow,
    isHorizontalOverflow,
    onContainerLayout,
    onContentLayout,
    containerSize,
    contentSize,
  };
}

//#endregion Hook

//#region Simple Hook

/**
 * Simplified overflow detection when you only need vertical overflow
 * and have a fixed maxHeight.
 *
 * @param maxHeight - Maximum height before overflow
 * @returns Object with isOverflow state and onLayout handler
 *
 * @example
 * ```tsx
 * function CollapsibleContent({ children }: IProps) {
 *   const { isOverflow, onLayout } = useIsVerticalOverflow(200);
 *   const [collapsed, setCollapsed] = useState(true);
 *
 *   return (
 *     <View style={collapsed && { maxHeight: 200, overflow: 'hidden' }}>
 *       <View onLayout={onLayout}>{children}</View>
 *       {isOverflow && (
 *         <Button onPress={() => setCollapsed(!collapsed)}>
 *           {collapsed ? 'Expand' : 'Collapse'}
 *         </Button>
 *       )}
 *     </View>
 *   );
 * }
 * ```
 */
export function useIsVerticalOverflow(maxHeight: number) {
  const [contentHeight, setContentHeight] = useState(0);

  const onLayout = (event: LayoutChangeEvent) => {
    const { height } = event.nativeEvent.layout;
    setContentHeight(height);
  };

  const isOverflow = contentHeight > maxHeight;

  return {
    isOverflow,
    contentHeight,
    onLayout,
  };
}

//#endregion Simple Hook
````

## Index Export

```typescript
// apps/v2/src/hooks/useIsOverflow/index.ts

export { useIsOverflow, useIsVerticalOverflow } from "./useIsOverflow";
```

## Acceptance Criteria

- [ ] Detects vertical overflow (content height > max height)
- [ ] Detects horizontal overflow (content width > max width)
- [ ] Supports configurable direction ('vertical', 'horizontal', 'both')
- [ ] Provides `onContainerLayout` and `onContentLayout` handlers
- [ ] Provides simplified `useIsVerticalOverflow` for common case
- [ ] All types use `I` prefix naming convention
- [ ] No `useCallback`/`useMemo` (React Compiler handles optimization)
- [ ] Exported from `hooks/useIsOverflow/index.ts`
- [ ] TypeScript strict mode passes
- [ ] No `any` types

## Testing

```typescript
// apps/v2/src/hooks/useIsOverflow/useIsOverflow.spec.tsx

import { renderHook, act } from "@testing-library/react-native";
import type { LayoutChangeEvent } from "react-native";

import { useIsOverflow, useIsVerticalOverflow } from "./useIsOverflow";

//#region Test Helpers

function createLayoutEvent(width: number, height: number): LayoutChangeEvent {
  return {
    nativeEvent: {
      layout: { x: 0, y: 0, width, height },
    },
  } as LayoutChangeEvent;
}

//#endregion Test Helpers

//#region useIsOverflow Tests

describe("useIsOverflow", () => {
  describe("vertical overflow", () => {
    it("returns false when content fits within maxHeight", () => {
      const { result } = renderHook(() =>
        useIsOverflow({ direction: "vertical", maxHeight: 200 }),
      );

      act(() => {
        result.current.onContentLayout(createLayoutEvent(300, 150));
      });

      expect(result.current.isOverflow).toBe(false);
      expect(result.current.isVerticalOverflow).toBe(false);
    });

    it("returns true when content exceeds maxHeight", () => {
      const { result } = renderHook(() =>
        useIsOverflow({ direction: "vertical", maxHeight: 200 }),
      );

      act(() => {
        result.current.onContentLayout(createLayoutEvent(300, 250));
      });

      expect(result.current.isOverflow).toBe(true);
      expect(result.current.isVerticalOverflow).toBe(true);
    });

    it("uses container height when maxHeight not provided", () => {
      const { result } = renderHook(() =>
        useIsOverflow({ direction: "vertical" }),
      );

      act(() => {
        result.current.onContainerLayout(createLayoutEvent(300, 100));
        result.current.onContentLayout(createLayoutEvent(300, 150));
      });

      expect(result.current.isOverflow).toBe(true);
    });
  });

  describe("horizontal overflow", () => {
    it("returns false when content fits within maxWidth", () => {
      const { result } = renderHook(() =>
        useIsOverflow({ direction: "horizontal", maxWidth: 300 }),
      );

      act(() => {
        result.current.onContentLayout(createLayoutEvent(250, 100));
      });

      expect(result.current.isOverflow).toBe(false);
      expect(result.current.isHorizontalOverflow).toBe(false);
    });

    it("returns true when content exceeds maxWidth", () => {
      const { result } = renderHook(() =>
        useIsOverflow({ direction: "horizontal", maxWidth: 300 }),
      );

      act(() => {
        result.current.onContentLayout(createLayoutEvent(350, 100));
      });

      expect(result.current.isOverflow).toBe(true);
      expect(result.current.isHorizontalOverflow).toBe(true);
    });
  });

  describe("both directions", () => {
    it("returns true when vertical overflows", () => {
      const { result } = renderHook(() =>
        useIsOverflow({ direction: "both", maxHeight: 100, maxWidth: 300 }),
      );

      act(() => {
        result.current.onContentLayout(createLayoutEvent(250, 150));
      });

      expect(result.current.isOverflow).toBe(true);
      expect(result.current.isVerticalOverflow).toBe(true);
      expect(result.current.isHorizontalOverflow).toBe(false);
    });

    it("returns true when horizontal overflows", () => {
      const { result } = renderHook(() =>
        useIsOverflow({ direction: "both", maxHeight: 200, maxWidth: 300 }),
      );

      act(() => {
        result.current.onContentLayout(createLayoutEvent(350, 100));
      });

      expect(result.current.isOverflow).toBe(true);
      expect(result.current.isVerticalOverflow).toBe(false);
      expect(result.current.isHorizontalOverflow).toBe(true);
    });

    it("returns true when both overflow", () => {
      const { result } = renderHook(() =>
        useIsOverflow({ direction: "both", maxHeight: 100, maxWidth: 300 }),
      );

      act(() => {
        result.current.onContentLayout(createLayoutEvent(400, 200));
      });

      expect(result.current.isOverflow).toBe(true);
      expect(result.current.isVerticalOverflow).toBe(true);
      expect(result.current.isHorizontalOverflow).toBe(true);
    });

    it("returns false when neither overflow", () => {
      const { result } = renderHook(() =>
        useIsOverflow({ direction: "both", maxHeight: 200, maxWidth: 400 }),
      );

      act(() => {
        result.current.onContentLayout(createLayoutEvent(300, 100));
      });

      expect(result.current.isOverflow).toBe(false);
    });
  });

  describe("size tracking", () => {
    it("tracks container size", () => {
      const { result } = renderHook(() => useIsOverflow());

      act(() => {
        result.current.onContainerLayout(createLayoutEvent(320, 480));
      });

      expect(result.current.containerSize).toEqual({ width: 320, height: 480 });
    });

    it("tracks content size", () => {
      const { result } = renderHook(() => useIsOverflow());

      act(() => {
        result.current.onContentLayout(createLayoutEvent(300, 600));
      });

      expect(result.current.contentSize).toEqual({ width: 300, height: 600 });
    });
  });

  describe("default behavior", () => {
    it("defaults to vertical direction", () => {
      const { result } = renderHook(() => useIsOverflow({ maxHeight: 100 }));

      act(() => {
        result.current.onContentLayout(createLayoutEvent(300, 150));
      });

      // Vertical overflow detected
      expect(result.current.isOverflow).toBe(true);
    });

    it("returns false initially before layout", () => {
      const { result } = renderHook(() => useIsOverflow({ maxHeight: 100 }));

      expect(result.current.isOverflow).toBe(false);
      expect(result.current.containerSize).toEqual({ width: 0, height: 0 });
      expect(result.current.contentSize).toEqual({ width: 0, height: 0 });
    });
  });
});

//#endregion useIsOverflow Tests

//#region useIsVerticalOverflow Tests

describe("useIsVerticalOverflow", () => {
  it("returns false when content fits within maxHeight", () => {
    const { result } = renderHook(() => useIsVerticalOverflow(200));

    act(() => {
      result.current.onLayout(createLayoutEvent(300, 150));
    });

    expect(result.current.isOverflow).toBe(false);
    expect(result.current.contentHeight).toBe(150);
  });

  it("returns true when content exceeds maxHeight", () => {
    const { result } = renderHook(() => useIsVerticalOverflow(200));

    act(() => {
      result.current.onLayout(createLayoutEvent(300, 250));
    });

    expect(result.current.isOverflow).toBe(true);
    expect(result.current.contentHeight).toBe(250);
  });

  it("returns true when content equals maxHeight + 1", () => {
    const { result } = renderHook(() => useIsVerticalOverflow(200));

    act(() => {
      result.current.onLayout(createLayoutEvent(300, 201));
    });

    expect(result.current.isOverflow).toBe(true);
  });

  it("returns false when content equals maxHeight exactly", () => {
    const { result } = renderHook(() => useIsVerticalOverflow(200));

    act(() => {
      result.current.onLayout(createLayoutEvent(300, 200));
    });

    expect(result.current.isOverflow).toBe(false);
  });

  it("updates when content size changes", () => {
    const { result } = renderHook(() => useIsVerticalOverflow(200));

    // Initially fits
    act(() => {
      result.current.onLayout(createLayoutEvent(300, 100));
    });
    expect(result.current.isOverflow).toBe(false);

    // Now overflows
    act(() => {
      result.current.onLayout(createLayoutEvent(300, 300));
    });
    expect(result.current.isOverflow).toBe(true);

    // Back to fitting
    act(() => {
      result.current.onLayout(createLayoutEvent(300, 150));
    });
    expect(result.current.isOverflow).toBe(false);
  });
});

//#endregion useIsVerticalOverflow Tests
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- useIsOverflow
```

## Usage Examples

### Basic "Show More" Button

```tsx
import { useState } from "react";
import { View, Text, Pressable } from "react-native";
import { StyleSheet } from "react-native-unistyles";
import { useIsVerticalOverflow } from "@/hooks/useIsOverflow";

type IProps = {
  text: string;
  maxHeight?: number;
};

export function ExpandableText({ text, maxHeight = 100 }: IProps) {
  const { isOverflow, onLayout } = useIsVerticalOverflow(maxHeight);
  const [expanded, setExpanded] = useState(false);

  return (
    <View>
      <View style={!expanded && { maxHeight, overflow: "hidden" }}>
        <View onLayout={onLayout}>
          <Text style={styles.text}>{text}</Text>
        </View>
      </View>
      {isOverflow && (
        <Pressable style={styles.button} onPress={() => setExpanded(!expanded)}>
          <Text style={styles.buttonText}>
            {expanded ? "Show less" : "Show more"}
          </Text>
        </Pressable>
      )}
    </View>
  );
}

const styles = StyleSheet.create((theme) => ({
  text: {
    color: theme.colors.centerChannelColor,
  },
  button: {
    paddingVertical: theme.gap(1),
  },
  buttonText: {
    color: theme.colors.linkColor,
  },
}));
```

### Tooltip on Overflow (like channel_banner.tsx)

```tsx
import { View, Text } from "react-native";
import { useIsOverflow } from "@/hooks/useIsOverflow";
import { Tooltip } from "@/components/Tooltip";

type IProps = {
  text: string;
};

export function TruncatedTextWithTooltip({ text }: IProps) {
  const { isOverflow, onContainerLayout, onContentLayout } = useIsOverflow({
    direction: "both",
  });

  const content = (
    <View onLayout={onContainerLayout} style={{ overflow: "hidden" }}>
      <View onLayout={onContentLayout}>
        <Text numberOfLines={1}>{text}</Text>
      </View>
    </View>
  );

  if (isOverflow) {
    return <Tooltip content={text}>{content}</Tooltip>;
  }

  return content;
}
```
