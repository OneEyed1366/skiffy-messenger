# T4.11: Emoji Utilities

## Metadata

| Field        | Value                 |
| ------------ | --------------------- |
| **ID**       | T4.11                 |
| **Layer**    | L4 - Formatting Utils |
| **Status**   | pending               |
| **Priority** | medium                |
| **Estimate** | 2h                    |
| **Parallel** | true                  |
| **Assignee** | -                     |
| **Created**  | 2026-01-06            |
| **Updated**  | 2026-01-06            |

## Dependencies

| Task ID | Name |
| ------- | ---- |
| None    | -    |

## Blocks

| Task ID | Name                    |
| ------- | ----------------------- |
| T6.\*   | Text input components   |
| T11.\*  | Post/Message components |

## Description

Emoji parsing, validation, and conversion utilities. Handles Mattermost-style `:shortcode:` parsing and Unicode emoji detection. Core emoji data (shortcodeâ†’unicode mapping) is injected to keep the utility lightweight.

## Source Files

- `vendor/desktop/webapp/channels/src/utils/emoticons.tsx`
- `vendor/desktop/webapp/channels/src/utils/emoji_utils.tsx`

## Migration Target

- **Target File**: `apps/v2/src/utils/emoji/emoji.ts`
- **Index Export**: `apps/v2/src/utils/emoji/index.ts`

## Implementation

```typescript
// apps/v2/src/utils/emoji/emoji.ts

//#region Constants

/**
 * Regex to match emoji shortcodes like :smile: or :+1:
 */
export const EMOJI_SHORTCODE_REGEX = /:([a-zA-Z0-9_+-]+):/g;

/**
 * Regex to match Unicode emoji characters
 * Covers most common emoji ranges
 */
export const UNICODE_EMOJI_REGEX =
  /[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F600}-\u{1F64F}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]/gu;

//#endregion Constants

//#region Types

type IEmojiMap = Map<string, string>;

type IEmojiContext = {
  emojiMap: IEmojiMap;
};

//#endregion Types

//#region Context (for emoji data injection)

let emojiContext: IEmojiContext = {
  emojiMap: new Map(),
};

/**
 * Initialize emoji utilities with emoji data map
 * Call this during app initialization with loaded emoji data
 */
export function initializeEmojiContext(emojiMap: IEmojiMap): void {
  emojiContext = { emojiMap };
}

/**
 * Get the current emoji map
 */
export function getEmojiMap(): IEmojiMap {
  return emojiContext.emojiMap;
}

//#endregion Context

//#region Shortcode Utilities

/**
 * Check if text is a valid emoji shortcode format
 */
export function isEmojiShortcode(text: string): boolean {
  const match = text.match(/^:([a-zA-Z0-9_+-]+):$/);
  return match !== null;
}

/**
 * Extract all emoji shortcodes from text
 * Returns shortcode names without colons
 */
export function extractEmojiShortcodes(text: string): string[] {
  const regex = new RegExp(EMOJI_SHORTCODE_REGEX.source, "g");
  const matches = text.matchAll(regex);
  return Array.from(matches, (m) => m[1]);
}

/**
 * Get Unicode emoji by shortcode (without colons)
 * Returns null if shortcode not found in emoji map
 */
export function getEmojiByShortcode(shortcode: string): string | null {
  return emojiContext.emojiMap.get(shortcode) ?? null;
}

/**
 * Replace all shortcodes in text with Unicode emoji
 */
export function replaceShortcodesWithUnicode(text: string): string {
  return text.replace(
    new RegExp(EMOJI_SHORTCODE_REGEX.source, "g"),
    (match, shortcode) => {
      const unicode = getEmojiByShortcode(shortcode);
      return unicode ?? match; // Keep original if not found
    },
  );
}

//#endregion Shortcode Utilities

//#region Unicode Utilities

/**
 * Check if a string contains Unicode emoji
 */
export function containsUnicodeEmoji(text: string): boolean {
  const regex = new RegExp(UNICODE_EMOJI_REGEX.source, "gu");
  return regex.test(text);
}

/**
 * Check if a single character is a Unicode emoji
 */
export function isUnicodeEmoji(char: string): boolean {
  const regex = new RegExp(UNICODE_EMOJI_REGEX.source, "gu");
  return regex.test(char);
}

/**
 * Extract all Unicode emoji from text
 */
export function extractUnicodeEmojis(text: string): string[] {
  const regex = new RegExp(UNICODE_EMOJI_REGEX.source, "gu");
  const matches = text.matchAll(regex);
  return Array.from(matches, (m) => m[0]);
}

//#endregion Unicode Utilities

//#region Counting

/**
 * Count total emoji in text (both shortcodes and Unicode)
 */
export function countEmojis(text: string): number {
  const shortcodes = extractEmojiShortcodes(text);
  const unicodes = extractUnicodeEmojis(text);
  return shortcodes.length + unicodes.length;
}

/**
 * Check if text contains only emoji (no other text)
 */
export function isOnlyEmoji(text: string): boolean {
  const stripped = text
    .replace(new RegExp(EMOJI_SHORTCODE_REGEX.source, "g"), "")
    .replace(new RegExp(UNICODE_EMOJI_REGEX.source, "gu"), "")
    .trim();
  return stripped.length === 0 && countEmojis(text) > 0;
}

/**
 * Check if message qualifies for large emoji display (1-3 emoji only)
 */
export function isLargeEmojiOnly(text: string): boolean {
  const count = countEmojis(text);
  return isOnlyEmoji(text) && count >= 1 && count <= 3;
}

//#endregion Counting
```

## Index Export

```typescript
// apps/v2/src/utils/emoji/index.ts

export {
  // Constants
  EMOJI_SHORTCODE_REGEX,
  UNICODE_EMOJI_REGEX,
  // Context
  initializeEmojiContext,
  getEmojiMap,
  // Shortcode utilities
  isEmojiShortcode,
  extractEmojiShortcodes,
  getEmojiByShortcode,
  replaceShortcodesWithUnicode,
  // Unicode utilities
  containsUnicodeEmoji,
  isUnicodeEmoji,
  extractUnicodeEmojis,
  // Counting
  countEmojis,
  isOnlyEmoji,
  isLargeEmojiOnly,
} from "./emoji";
```

## Acceptance Criteria

- [ ] `EMOJI_SHORTCODE_REGEX` matches `:name:` format
- [ ] `extractEmojiShortcodes()` returns array of shortcode names
- [ ] `replaceShortcodesWithUnicode()` converts when emoji map has entry
- [ ] `isUnicodeEmoji()` correctly identifies Unicode emoji
- [ ] `countEmojis()` counts both types
- [ ] `isLargeEmojiOnly()` for large emoji rendering
- [ ] `initializeEmojiContext()` allows lazy loading of emoji data
- [ ] All types use `I` prefix naming convention
- [ ] TypeScript strict mode passes
- [ ] No `any` types

## Testing

```typescript
// apps/v2/src/utils/emoji/emoji.spec.ts

import {
  isEmojiShortcode,
  extractEmojiShortcodes,
  getEmojiByShortcode,
  replaceShortcodesWithUnicode,
  containsUnicodeEmoji,
  isUnicodeEmoji,
  extractUnicodeEmojis,
  countEmojis,
  isOnlyEmoji,
  isLargeEmojiOnly,
  initializeEmojiContext,
} from "./emoji";

//#region Setup

beforeEach(() => {
  initializeEmojiContext(
    new Map([
      ["smile", "ðŸ˜Š"],
      ["heart", "â¤ï¸"],
      ["thumbsup", "ðŸ‘"],
      ["+1", "ðŸ‘"],
    ]),
  );
});

//#endregion Setup

//#region Shortcode Tests

describe("isEmojiShortcode", () => {
  it("returns true for valid shortcodes", () => {
    expect(isEmojiShortcode(":smile:")).toBe(true);
    expect(isEmojiShortcode(":+1:")).toBe(true);
    expect(isEmojiShortcode(":thumbs_up:")).toBe(true);
  });

  it("returns false for invalid formats", () => {
    expect(isEmojiShortcode("smile")).toBe(false);
    expect(isEmojiShortcode(":smile")).toBe(false);
    expect(isEmojiShortcode("smile:")).toBe(false);
    expect(isEmojiShortcode("hello :smile: world")).toBe(false);
  });
});

describe("extractEmojiShortcodes", () => {
  it("extracts shortcodes from text", () => {
    const text = "Hello :smile: world :heart:!";
    expect(extractEmojiShortcodes(text)).toEqual(["smile", "heart"]);
  });

  it("returns empty array when no shortcodes", () => {
    expect(extractEmojiShortcodes("Hello world")).toEqual([]);
  });

  it("handles consecutive shortcodes", () => {
    expect(extractEmojiShortcodes(":smile::heart:")).toEqual([
      "smile",
      "heart",
    ]);
  });
});

describe("getEmojiByShortcode", () => {
  it("returns unicode for known shortcode", () => {
    expect(getEmojiByShortcode("smile")).toBe("ðŸ˜Š");
    expect(getEmojiByShortcode("+1")).toBe("ðŸ‘");
  });

  it("returns null for unknown shortcode", () => {
    expect(getEmojiByShortcode("unknown")).toBeNull();
  });
});

describe("replaceShortcodesWithUnicode", () => {
  it("replaces known shortcodes", () => {
    expect(replaceShortcodesWithUnicode("Hello :smile:!")).toBe("Hello ðŸ˜Š!");
  });

  it("keeps unknown shortcodes unchanged", () => {
    expect(replaceShortcodesWithUnicode("Hello :unknown:!")).toBe(
      "Hello :unknown:!",
    );
  });

  it("replaces multiple shortcodes", () => {
    expect(replaceShortcodesWithUnicode(":smile: :heart:")).toBe("ðŸ˜Š â¤ï¸");
  });
});

//#endregion Shortcode Tests

//#region Unicode Tests

describe("containsUnicodeEmoji", () => {
  it("detects unicode emoji", () => {
    expect(containsUnicodeEmoji("Hello ðŸ˜Š")).toBe(true);
    expect(containsUnicodeEmoji("ðŸ‘")).toBe(true);
  });

  it("returns false for text without emoji", () => {
    expect(containsUnicodeEmoji("Hello world")).toBe(false);
  });
});

describe("isUnicodeEmoji", () => {
  it("returns true for emoji", () => {
    expect(isUnicodeEmoji("ðŸ˜Š")).toBe(true);
    expect(isUnicodeEmoji("ðŸ‘")).toBe(true);
  });

  it("returns false for regular characters", () => {
    expect(isUnicodeEmoji("a")).toBe(false);
    expect(isUnicodeEmoji("1")).toBe(false);
  });
});

describe("extractUnicodeEmojis", () => {
  it("extracts all unicode emoji", () => {
    expect(extractUnicodeEmojis("Hello ðŸ˜Š world ðŸ‘")).toEqual(["ðŸ˜Š", "ðŸ‘"]);
  });

  it("returns empty array when no emoji", () => {
    expect(extractUnicodeEmojis("Hello world")).toEqual([]);
  });
});

//#endregion Unicode Tests

//#region Counting Tests

describe("countEmojis", () => {
  it("counts shortcodes and unicode", () => {
    expect(countEmojis("Hello :smile: ðŸ‘")).toBe(2);
  });

  it("returns 0 for no emoji", () => {
    expect(countEmojis("Hello world")).toBe(0);
  });
});

describe("isOnlyEmoji", () => {
  it("returns true for emoji-only content", () => {
    expect(isOnlyEmoji("ðŸ˜Š")).toBe(true);
    expect(isOnlyEmoji(":smile:")).toBe(true);
    expect(isOnlyEmoji("ðŸ˜Š ðŸ‘")).toBe(true);
  });

  it("returns false when text is present", () => {
    expect(isOnlyEmoji("Hello ðŸ˜Š")).toBe(false);
    expect(isOnlyEmoji("")).toBe(false);
  });
});

describe("isLargeEmojiOnly", () => {
  it("returns true for 1-3 emoji only", () => {
    expect(isLargeEmojiOnly("ðŸ˜Š")).toBe(true);
    expect(isLargeEmojiOnly("ðŸ˜Š ðŸ‘")).toBe(true);
    expect(isLargeEmojiOnly("ðŸ˜Š ðŸ‘ â¤ï¸")).toBe(true);
  });

  it("returns false for more than 3 emoji", () => {
    expect(isLargeEmojiOnly("ðŸ˜Š ðŸ‘ â¤ï¸ ðŸŽ‰")).toBe(false);
  });

  it("returns false when text is present", () => {
    expect(isLargeEmojiOnly("Nice ðŸ˜Š")).toBe(false);
  });
});

//#endregion Counting Tests
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- emoji
```

## Notes

The emoji map (`shortcode â†’ unicode`) should be loaded separately and injected via `initializeEmojiContext()`. This keeps the utility bundle size small and allows different emoji datasets (e.g., custom server emoji).

For full emoji support, consider using:

- `emoji-mart` for picker UI
- Server-provided emoji list for custom/server emoji
