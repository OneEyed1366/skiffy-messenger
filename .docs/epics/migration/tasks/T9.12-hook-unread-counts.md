# T9.12: useUnreadCountsQuery Hook

## Metadata

| Field        | Value            |
| ------------ | ---------------- |
| **ID**       | T9.12            |
| **Layer**    | L9 - State Hooks |
| **Status**   | pending          |
| **Priority** | high             |
| **Estimate** | 2h               |
| **Parallel** | true             |
| **Assignee** | -                |
| **Created**  | 2026-01-06       |
| **Updated**  | 2026-01-07       |

## Dependencies

| Task ID | Name        |
| ------- | ----------- |
| T7.01   | API Client  |
| T7.02   | QueryClient |
| T7.03   | Query Keys  |

## Description

Create a TanStack Query hook to fetch unread message and mention counts. Uses the
`select` option to derive aggregated counts from raw API response.

**Architecture Note:** Unread counts come from the REST API, so this uses TanStack Query.
See `.docs/architecture/state-management.md`.

## Source Analysis

- **Redux Selector**: `vendor/desktop/webapp/platform/client/src/selectors/entities/channels.ts` - `getUnreadCounts`
- **API Endpoint**: `GET /api/v4/users/{user_id}/teams/{team_id}/channels/members`

## Migration Target

- **Target File**: `apps/v2/src/hooks/useUnreadCountsQuery/useUnreadCountsQuery.ts`
- **Index Export**: `apps/v2/src/hooks/useUnreadCountsQuery/index.ts`

## Implementation

````typescript
// apps/v2/src/hooks/useUnreadCountsQuery/useUnreadCountsQuery.ts

import { useQuery, UseQueryOptions } from "@tanstack/react-query";
import { channelsApi } from "@/api/channels";
import { queryKeys } from "@/queries/keys";
import type { IChannelMember } from "@/types";

//#region Types

type IUnreadCounts = {
  totalMentions: number;
  totalMessages: number;
  byChannel: Record<string, { mentions: number; messages: number }>;
};

type IRawUnreadData = IChannelMember[];

type IUseUnreadCountsQueryOptions = Omit<
  UseQueryOptions<IRawUnreadData, Error, IUnreadCounts>,
  "queryKey" | "queryFn" | "select"
>;

//#endregion Types

//#region Helpers

function selectUnreadCounts(data: IRawUnreadData): IUnreadCounts {
  const byChannel: Record<string, { mentions: number; messages: number }> = {};
  let totalMentions = 0;
  let totalMessages = 0;

  data.forEach((member) => {
    byChannel[member.channel_id] = {
      mentions: member.mention_count,
      messages: member.msg_count,
    };
    totalMentions += member.mention_count;
    totalMessages += member.msg_count;
  });

  return { totalMentions, totalMessages, byChannel };
}

//#endregion Helpers

//#region Hook

/**
 * Fetches unread counts for all channels in a team.
 * Uses TanStack Query's `select` option to derive aggregated counts.
 *
 * @param teamId - Team ID to fetch unread counts for
 * @param options - TanStack Query options
 * @returns Query result with derived unread counts
 *
 * @example
 * ```tsx
 * function BadgeCount({ teamId }: { teamId: string }) {
 *   const { data } = useUnreadCountsQuery(teamId);
 *
 *   if (!data?.totalMentions) return null;
 *   return <Badge count={data.totalMentions} />;
 * }
 * ```
 */
export function useUnreadCountsQuery(
  teamId: string | null | undefined,
  options?: IUseUnreadCountsQueryOptions,
) {
  return useQuery({
    queryKey: queryKeys.channels.unreadCounts(teamId!),
    queryFn: () => channelsApi.getMyChannelMembers(teamId!),
    select: selectUnreadCounts,
    enabled: !!teamId && (options?.enabled ?? true),
    staleTime: 1000 * 30, // 30 seconds - unreads change frequently
    ...options,
  });
}

//#endregion Hook

//#region Channel-Specific Hook

/**
 * Convenience hook for a single channel's unread count.
 *
 * @param teamId - Team ID
 * @param channelId - Channel ID
 * @returns Mentions and message count for the channel
 */
export function useChannelUnreadCount(
  teamId: string | null | undefined,
  channelId: string | null | undefined,
) {
  const { data } = useUnreadCountsQuery(teamId);

  if (!channelId || !data) {
    return { mentions: 0, messages: 0 };
  }

  return data.byChannel[channelId] ?? { mentions: 0, messages: 0 };
}

//#endregion Channel-Specific Hook
````

## Index Export

```typescript
// apps/v2/src/hooks/useUnreadCountsQuery/index.ts

export {
  useUnreadCountsQuery,
  useChannelUnreadCount,
} from "./useUnreadCountsQuery";
```

## Acceptance Criteria

- [ ] Uses TanStack Query `useQuery` hook
- [ ] Uses `select` option to derive aggregated counts
- [ ] Returns `{ totalMentions, totalMessages, byChannel }` structure
- [ ] 30 second staleTime (unreads change frequently)
- [ ] Provides `useChannelUnreadCount` convenience hook
- [ ] TypeScript strict mode passes
- [ ] No `any` types

## Testing

```typescript
// apps/v2/src/hooks/useUnreadCountsQuery/useUnreadCountsQuery.spec.ts

import { renderHook, waitFor } from "@testing-library/react-native";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useUnreadCountsQuery, useChannelUnreadCount } from "./useUnreadCountsQuery";
import { channelsApi } from "@/api/channels";

jest.mock("@/api/channels");

const mockMembers = [
  { channel_id: "ch-1", mention_count: 5, msg_count: 10 },
  { channel_id: "ch-2", mention_count: 2, msg_count: 3 },
];

function createWrapper() {
  const queryClient = new QueryClient({
    defaultOptions: { queries: { retry: false } },
  });
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
}

describe("useUnreadCountsQuery", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("fetches and aggregates unread counts", async () => {
    (channelsApi.getMyChannelMembers as jest.Mock).mockResolvedValue(mockMembers);

    const { result } = renderHook(() => useUnreadCountsQuery("team-1"), {
      wrapper: createWrapper(),
    });

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    expect(result.current.data).toEqual({
      totalMentions: 7,
      totalMessages: 13,
      byChannel: {
        "ch-1": { mentions: 5, messages: 10 },
        "ch-2": { mentions: 2, messages: 3 },
      },
    });
  });
});
```

## Notes

- **WebSocket updates** — Unread counts update via `channels$` stream → TQ cache invalidation
- **Derived data** — Uses TQ `select` for memoized transformation (no useMemo needed)
