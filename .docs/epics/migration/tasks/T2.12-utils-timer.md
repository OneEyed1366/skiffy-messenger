# T2.12: Timer Utilities

## Metadata

| Field        | Value           |
| ------------ | --------------- |
| **ID**       | T2.12           |
| **Layer**    | L2 - Pure Utils |
| **Status**   | pending         |
| **Priority** | medium          |
| **Estimate** | 0.5h            |
| **Parallel** | true            |
| **Assignee** | -               |
| **Created**  | 2026-01-07      |
| **Updated**  | 2026-01-07      |

## Dependencies

None

## Blocks

| Task ID | Name                          |
| ------- | ----------------------------- |
| T10c.\* | Timer/countdown components    |
| T8.\*   | Hooks for burn-on-read timers |

## Description

Timer and countdown utility functions migrated from Mattermost burn-on-read timer utilities. Pure functions for calculating remaining time, formatting durations, and checking timer states.

## Source Files

- `vendor/desktop/webapp/channels/src/utils/burn_on_read_timer_utils.ts`

## Target File

`apps/v2/src/utils/timer.ts`

## Implementation

```typescript
// apps/v2/src/utils/timer.ts

/**
 * Timer and countdown utility functions
 * Migrated from: vendor/desktop/webapp/channels/src/utils/burn_on_read_timer_utils.ts
 *
 * Pure functions for timer calculations and formatting.
 */

//#region Constants

const MS_PER_SECOND = 1000;
const MS_PER_MINUTE = 60 * MS_PER_SECOND;
const SECONDS_PER_MINUTE = 60;

//#endregion

//#region Time Formatting

/**
 * Formats milliseconds as a human-readable duration string.
 * Returns "Xm Ys" for durations >= 1 minute, or "Xs" for shorter durations.
 *
 * @param ms - Duration in milliseconds
 * @returns Formatted duration string
 *
 * @example
 * formatTimeRemaining(125000) // "2m 5s"
 * formatTimeRemaining(45000)  // "45s"
 * formatTimeRemaining(60000)  // "1m 0s"
 * formatTimeRemaining(0)      // "0s"
 * formatTimeRemaining(-1000)  // "0s"
 */
export function formatTimeRemaining(ms: number): string {
  if (ms <= 0) {
    return "0s";
  }

  const totalSeconds = Math.floor(ms / MS_PER_SECOND);
  const minutes = Math.floor(totalSeconds / SECONDS_PER_MINUTE);
  const seconds = totalSeconds % SECONDS_PER_MINUTE;

  if (minutes > 0) {
    return `${minutes}m ${seconds}s`;
  }

  return `${seconds}s`;
}

//#endregion

//#region Time Calculations

/**
 * Calculates the remaining time until expiration.
 *
 * @param expiresAt - Expiration timestamp (ms since epoch) or Date
 * @param now - Current time (defaults to Date.now())
 * @returns Remaining time in milliseconds (0 if expired)
 *
 * @example
 * const expiresAt = Date.now() + 60000; // 1 minute from now
 * calculateRemainingTime(expiresAt) // ~60000
 *
 * const pastTime = Date.now() - 1000; // 1 second ago
 * calculateRemainingTime(pastTime) // 0
 */
export function calculateRemainingTime(
  expiresAt: number | Date,
  now: number = Date.now(),
): number {
  const expirationTime =
    expiresAt instanceof Date ? expiresAt.getTime() : expiresAt;
  const remaining = expirationTime - now;
  return Math.max(0, remaining);
}

//#endregion

//#region Timer State Checks

/**
 * Checks if a timer is in the warning state (close to expiration).
 *
 * @param remainingMs - Remaining time in milliseconds
 * @param warningThreshold - Warning threshold in milliseconds (default: 30 seconds)
 * @returns true if remaining time is <= threshold and > 0
 *
 * @example
 * isTimerInWarningState(25000)        // true (< 30s default)
 * isTimerInWarningState(35000)        // false (> 30s default)
 * isTimerInWarningState(5000, 10000)  // true (< 10s custom threshold)
 * isTimerInWarningState(0)            // false (expired, not warning)
 */
export function isTimerInWarningState(
  remainingMs: number,
  warningThreshold: number = 30 * MS_PER_SECOND,
): boolean {
  return remainingMs > 0 && remainingMs <= warningThreshold;
}

/**
 * Checks if a timer has expired.
 *
 * @param expiresAt - Expiration timestamp (ms since epoch) or Date
 * @param now - Current time (defaults to Date.now())
 * @returns true if current time >= expiration time
 *
 * @example
 * const pastTime = Date.now() - 1000;
 * isTimerExpired(pastTime) // true
 *
 * const futureTime = Date.now() + 60000;
 * isTimerExpired(futureTime) // false
 */
export function isTimerExpired(
  expiresAt: number | Date,
  now: number = Date.now(),
): boolean {
  const expirationTime =
    expiresAt instanceof Date ? expiresAt.getTime() : expiresAt;
  return now >= expirationTime;
}

//#endregion
```

## Index Export

```typescript
// apps/v2/src/utils/index.ts (append to existing exports)

export {
  formatTimeRemaining,
  calculateRemainingTime,
  isTimerInWarningState,
  isTimerExpired,
} from "./timer";
```

## Acceptance Criteria

- [ ] `formatTimeRemaining` formats milliseconds as "Xm Ys" or "Xs"
- [ ] `formatTimeRemaining` returns "0s" for zero or negative values
- [ ] `calculateRemainingTime` returns remaining milliseconds
- [ ] `calculateRemainingTime` returns 0 for expired times
- [ ] `isTimerInWarningState` correctly identifies warning state
- [ ] `isTimerExpired` correctly identifies expired timers
- [ ] All functions accept both timestamps and Date objects where applicable
- [ ] All functions are pure (deterministic with `now` parameter)
- [ ] No external dependencies
- [ ] Uses `#region` comments for organization
- [ ] Exported from `utils/index.ts`
- [ ] TypeScript strict mode passes

## Testing

```typescript
// apps/v2/src/utils/timer.spec.ts

import {
  formatTimeRemaining,
  calculateRemainingTime,
  isTimerInWarningState,
  isTimerExpired,
} from "./timer";

describe("formatTimeRemaining", () => {
  it("formats minutes and seconds", () => {
    expect(formatTimeRemaining(125000)).toBe("2m 5s");
    expect(formatTimeRemaining(60000)).toBe("1m 0s");
    expect(formatTimeRemaining(90000)).toBe("1m 30s");
  });

  it("formats seconds only for < 1 minute", () => {
    expect(formatTimeRemaining(45000)).toBe("45s");
    expect(formatTimeRemaining(1000)).toBe("1s");
    expect(formatTimeRemaining(59999)).toBe("59s");
  });

  it("returns 0s for zero or negative values", () => {
    expect(formatTimeRemaining(0)).toBe("0s");
    expect(formatTimeRemaining(-1000)).toBe("0s");
    expect(formatTimeRemaining(-999999)).toBe("0s");
  });

  it("truncates milliseconds", () => {
    expect(formatTimeRemaining(1999)).toBe("1s");
    expect(formatTimeRemaining(61500)).toBe("1m 1s");
  });
});

describe("calculateRemainingTime", () => {
  it("calculates remaining time from timestamp", () => {
    const now = 1000000;
    const expiresAt = 1060000; // 60 seconds later
    expect(calculateRemainingTime(expiresAt, now)).toBe(60000);
  });

  it("calculates remaining time from Date", () => {
    const now = 1000000;
    const expiresAt = new Date(1060000);
    expect(calculateRemainingTime(expiresAt, now)).toBe(60000);
  });

  it("returns 0 for expired time", () => {
    const now = 1000000;
    const expiresAt = 900000; // Already passed
    expect(calculateRemainingTime(expiresAt, now)).toBe(0);
  });

  it("returns 0 for exactly expired time", () => {
    const now = 1000000;
    expect(calculateRemainingTime(now, now)).toBe(0);
  });
});

describe("isTimerInWarningState", () => {
  it("returns true when remaining time is within threshold", () => {
    expect(isTimerInWarningState(25000)).toBe(true); // 25s < 30s default
    expect(isTimerInWarningState(30000)).toBe(true); // exactly at threshold
    expect(isTimerInWarningState(1)).toBe(true); // 1ms remaining
  });

  it("returns false when remaining time exceeds threshold", () => {
    expect(isTimerInWarningState(35000)).toBe(false);
    expect(isTimerInWarningState(60000)).toBe(false);
  });

  it("returns false when expired (0 or negative)", () => {
    expect(isTimerInWarningState(0)).toBe(false);
    expect(isTimerInWarningState(-1000)).toBe(false);
  });

  it("respects custom threshold", () => {
    expect(isTimerInWarningState(5000, 10000)).toBe(true);
    expect(isTimerInWarningState(15000, 10000)).toBe(false);
  });
});

describe("isTimerExpired", () => {
  it("returns true for past timestamps", () => {
    const now = 1000000;
    expect(isTimerExpired(900000, now)).toBe(true);
    expect(isTimerExpired(999999, now)).toBe(true);
  });

  it("returns true at exact expiration time", () => {
    const now = 1000000;
    expect(isTimerExpired(now, now)).toBe(true);
  });

  it("returns false for future timestamps", () => {
    const now = 1000000;
    expect(isTimerExpired(1000001, now)).toBe(false);
    expect(isTimerExpired(2000000, now)).toBe(false);
  });

  it("accepts Date objects", () => {
    const now = 1000000;
    expect(isTimerExpired(new Date(900000), now)).toBe(true);
    expect(isTimerExpired(new Date(2000000), now)).toBe(false);
  });
});
```

Run tests:

```bash
pnpm --filter @retrievly/app test:unit -- timer.spec
```
