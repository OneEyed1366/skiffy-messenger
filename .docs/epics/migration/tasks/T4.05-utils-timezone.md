# T4.05: Timezone Utilities

## Metadata

| Field        | Value                 |
| ------------ | --------------------- |
| **ID**       | T4.05                 |
| **Layer**    | L4 - Formatting Utils |
| **Status**   | pending               |
| **Priority** | medium                |
| **Estimate** | 2h                    |
| **Parallel** | true                  |
| **Assignee** | -                     |
| **Created**  | 2026-01-04            |
| **Updated**  | 2026-01-04            |

## Dependencies

| Task ID | Name           |
| ------- | -------------- |
| T4.01   | utils-datetime |

## Blocks

| Task ID | Name                |
| ------- | ------------------- |
| T6.13   | component-timestamp |

## Description

Migrate timezone utilities from Mattermost. The original implementation uses `moment-timezone` for all timezone operations. Replace with native `Intl.DateTimeFormat` API which is well-supported in modern browsers and React Native.

Key functions to migrate:

- `getUserTimezone` - Get user's current timezone (from browser/device)
- `formatInTimezone` - Format a date in a specific timezone
- `getTimezoneOffset` - Get UTC offset for a timezone
- `listTimezones` - Get list of all valid timezones for settings dropdown

## Source Files

- `vendor/desktop/webapp/channels/src/utils/timezone.ts`

### Original Implementation

```typescript
// Uses moment-timezone throughout
import type { Moment } from "moment-timezone";
import moment from "moment-timezone";

export function getBrowserTimezone() {
  return new Intl.DateTimeFormat().resolvedOptions().timeZone;
}

export function getBrowserUtcOffset() {
  return moment().utcOffset();
}

export function getUtcOffsetForTimeZone(timezone: string) {
  return moment.tz(timezone).utcOffset();
}

export function getCurrentDateForTimezone(timezone: string) {
  const tztime = moment().tz(timezone);
  return new Date(tztime.year(), tztime.month(), tztime.date());
}

export function getCurrentDateTimeForTimezone(timezone: string) {
  const tztime = moment().tz(timezone);
  return new Date(
    tztime.year(),
    tztime.month(),
    tztime.date(),
    tztime.hour(),
    tztime.minute(),
    tztime.second(),
  );
}

export function getCurrentMomentForTimezone(timezone?: string) {
  return timezone ? moment.tz(timezone) : moment();
}

export function isValidTimezone(timezone: string): boolean {
  return moment.tz.zone(timezone) !== null;
}

export function parseDateInTimezone(
  value: string,
  timezone?: string,
): Moment | null {
  if (!timezone || !isValidTimezone(timezone)) {
    const parsed = moment(value);
    return parsed.isValid() ? parsed : null;
  }

  const parsed = moment.tz(value, timezone);
  return parsed.isValid() ? parsed : null;
}
```

## Source Analysis

The original uses `moment-timezone` for:

1. Getting browser timezone (already uses Intl API)
2. UTC offset calculations
3. Date/time conversions between timezones
4. Timezone validation

**Migration Strategy:**

- Replace `moment-timezone` with native `Intl.DateTimeFormat`
- Use `Intl.supportedValuesOf('timeZone')` for timezone list (ES2022)
- Calculate offsets by parsing formatted timezone strings
- Validate timezones by attempting to create DateTimeFormat with timeZone option

## Target File

`apps/v2/src/utils/timezone/timezone.ts`

## Implementation

```typescript
// apps/v2/src/utils/timezone/timezone.ts

//#region Types

type ITimezoneInfo = {
  id: string;
  label: string;
  offset: number;
  offsetLabel: string;
};

type IFormatInTimezoneOptions = {
  dateStyle?: "full" | "long" | "medium" | "short";
  timeStyle?: "full" | "long" | "medium" | "short";
  hour12?: boolean;
};

//#endregion Types

//#region Core Functions

/**
 * Gets the user's current timezone from the browser/device.
 * Falls back to UTC if timezone cannot be determined.
 *
 * @returns IANA timezone identifier (e.g., "America/New_York")
 *
 * @example
 * const tz = getUserTimezone();
 * // => "America/New_York"
 */
export function getUserTimezone(): string {
  try {
    return Intl.DateTimeFormat().resolvedOptions().timeZone;
  } catch {
    return "UTC";
  }
}

/**
 * Formats a date in the specified timezone.
 *
 * @param date - Date to format (Date object, timestamp, or ISO string)
 * @param timezone - IANA timezone identifier
 * @param options - Formatting options
 * @returns Formatted date string
 *
 * @example
 * formatInTimezone(new Date(), "America/New_York", { dateStyle: "medium", timeStyle: "short" });
 * // => "Jan 4, 2026, 10:30 AM"
 */
export function formatInTimezone(
  date: Date | number | string,
  timezone: string,
  options: IFormatInTimezoneOptions = {},
): string {
  const dateObj =
    typeof date === "string" || typeof date === "number"
      ? new Date(date)
      : date;

  const { dateStyle = "medium", timeStyle = "short", hour12 = true } = options;

  try {
    return new Intl.DateTimeFormat("en-US", {
      timeZone: timezone,
      dateStyle,
      timeStyle,
      hour12,
    }).format(dateObj);
  } catch {
    // Fallback to UTC if timezone is invalid
    return new Intl.DateTimeFormat("en-US", {
      timeZone: "UTC",
      dateStyle,
      timeStyle,
      hour12,
    }).format(dateObj);
  }
}

/**
 * Gets the UTC offset in minutes for a timezone at a specific date.
 * Offset is positive for timezones ahead of UTC (e.g., +330 for Asia/Kolkata).
 *
 * @param timezone - IANA timezone identifier
 * @param date - Date to check offset for (defaults to now)
 * @returns UTC offset in minutes
 *
 * @example
 * getTimezoneOffset("America/New_York");
 * // => -300 (UTC-5 in winter) or -240 (UTC-4 in summer)
 */
export function getTimezoneOffset(
  timezone: string,
  date: Date = new Date(),
): number {
  try {
    // Get timezone offset by comparing UTC and local representations
    const utcDate = new Date(date.toLocaleString("en-US", { timeZone: "UTC" }));
    const tzDate = new Date(
      date.toLocaleString("en-US", { timeZone: timezone }),
    );

    return Math.round((tzDate.getTime() - utcDate.getTime()) / 60000);
  } catch {
    return 0;
  }
}

/**
 * Formats UTC offset as a string (e.g., "+05:30", "-08:00").
 *
 * @param offsetMinutes - Offset in minutes
 * @returns Formatted offset string
 */
function formatOffsetLabel(offsetMinutes: number): string {
  const sign = offsetMinutes >= 0 ? "+" : "-";
  const absMinutes = Math.abs(offsetMinutes);
  const hours = Math.floor(absMinutes / 60);
  const minutes = absMinutes % 60;

  return `${sign}${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
}

/**
 * Returns a list of all valid IANA timezones with metadata.
 * Useful for settings dropdowns and timezone selectors.
 *
 * @returns Array of timezone info objects sorted by offset then name
 *
 * @example
 * const timezones = listTimezones();
 * // => [
 * //   { id: "Pacific/Midway", label: "Pacific/Midway (UTC-11:00)", offset: -660, offsetLabel: "-11:00" },
 * //   ...
 * // ]
 */
export function listTimezones(): ITimezoneInfo[] {
  const now = new Date();

  // Get all supported timezones (ES2022)
  const timezoneIds = Intl.supportedValuesOf("timeZone");

  const timezones: ITimezoneInfo[] = timezoneIds.map((id) => {
    const offset = getTimezoneOffset(id, now);
    const offsetLabel = formatOffsetLabel(offset);

    return {
      id,
      label: `${id} (UTC${offsetLabel})`,
      offset,
      offsetLabel,
    };
  });

  // Sort by offset (ascending), then by id (alphabetically)
  return timezones.sort((a, b) => {
    if (a.offset !== b.offset) {
      return a.offset - b.offset;
    }
    return a.id.localeCompare(b.id);
  });
}

//#endregion Core Functions

//#region Validation

/**
 * Checks if a timezone identifier is valid.
 *
 * @param timezone - IANA timezone identifier to validate
 * @returns true if timezone is valid
 *
 * @example
 * isValidTimezone("America/New_York"); // => true
 * isValidTimezone("Invalid/Zone");     // => false
 */
export function isValidTimezone(timezone: string): boolean {
  try {
    Intl.DateTimeFormat(undefined, { timeZone: timezone });
    return true;
  } catch {
    return false;
  }
}

//#endregion Validation

//#region Date Conversion

/**
 * Gets the current date in a specific timezone (date only, no time).
 *
 * @param timezone - IANA timezone identifier
 * @returns Date object representing the date in that timezone
 *
 * @example
 * getCurrentDateForTimezone("Asia/Tokyo");
 * // => Date representing today in Tokyo
 */
export function getCurrentDateForTimezone(timezone: string): Date {
  const now = new Date();
  const parts = new Intl.DateTimeFormat("en-CA", {
    timeZone: timezone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  }).formatToParts(now);

  const year = parseInt(parts.find((p) => p.type === "year")?.value ?? "0", 10);
  const month =
    parseInt(parts.find((p) => p.type === "month")?.value ?? "1", 10) - 1;
  const day = parseInt(parts.find((p) => p.type === "day")?.value ?? "1", 10);

  return new Date(year, month, day);
}

/**
 * Gets the current date and time in a specific timezone.
 *
 * @param timezone - IANA timezone identifier
 * @returns Date object representing the current moment in that timezone
 *
 * @example
 * getCurrentDateTimeForTimezone("Europe/London");
 * // => Date representing now in London
 */
export function getCurrentDateTimeForTimezone(timezone: string): Date {
  const now = new Date();
  const parts = new Intl.DateTimeFormat("en-CA", {
    timeZone: timezone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
  }).formatToParts(now);

  const year = parseInt(parts.find((p) => p.type === "year")?.value ?? "0", 10);
  const month =
    parseInt(parts.find((p) => p.type === "month")?.value ?? "1", 10) - 1;
  const day = parseInt(parts.find((p) => p.type === "day")?.value ?? "1", 10);
  const hour = parseInt(parts.find((p) => p.type === "hour")?.value ?? "0", 10);
  const minute = parseInt(
    parts.find((p) => p.type === "minute")?.value ?? "0",
    10,
  );
  const second = parseInt(
    parts.find((p) => p.type === "second")?.value ?? "0",
    10,
  );

  return new Date(year, month, day, hour, minute, second);
}

//#endregion Date Conversion
```

## Index Export

```typescript
// apps/v2/src/utils/timezone/index.ts

export {
  getUserTimezone,
  formatInTimezone,
  getTimezoneOffset,
  listTimezones,
  isValidTimezone,
  getCurrentDateForTimezone,
  getCurrentDateTimeForTimezone,
} from "./timezone";
```

```typescript
// apps/v2/src/utils/index.ts (add to existing exports)

export * from "./timezone";
```

## Acceptance Criteria

- [ ] Uses native `Intl.DateTimeFormat` instead of `moment-timezone`
- [ ] `getUserTimezone` returns IANA timezone identifier
- [ ] `formatInTimezone` correctly formats dates in specified timezone
- [ ] `getTimezoneOffset` returns correct offset in minutes
- [ ] `listTimezones` returns all valid IANA timezones with metadata
- [ ] `isValidTimezone` correctly validates timezone identifiers
- [ ] No external dependencies (zero bundle impact)
- [ ] Exported from `utils/index.ts`
- [ ] TypeScript strict mode passes
- [ ] No `any` types

## Testing

```typescript
// apps/v2/src/utils/timezone/timezone.spec.ts

import {
  getUserTimezone,
  formatInTimezone,
  getTimezoneOffset,
  listTimezones,
  isValidTimezone,
  getCurrentDateForTimezone,
  getCurrentDateTimeForTimezone,
} from "./timezone";

describe("timezone utilities", () => {
  //#region getUserTimezone

  describe("getUserTimezone", () => {
    it("returns a valid IANA timezone identifier", () => {
      const tz = getUserTimezone();

      expect(typeof tz).toBe("string");
      expect(tz.length).toBeGreaterThan(0);
      expect(isValidTimezone(tz)).toBe(true);
    });
  });

  //#endregion getUserTimezone

  //#region formatInTimezone

  describe("formatInTimezone", () => {
    it("formats date in specified timezone", () => {
      // Fixed date: Jan 1, 2026 12:00:00 UTC
      const date = new Date("2026-01-01T12:00:00Z");

      const nyResult = formatInTimezone(date, "America/New_York", {
        dateStyle: "short",
        timeStyle: "short",
        hour12: true,
      });

      // New York is UTC-5 in January, so 12:00 UTC = 7:00 AM EST
      expect(nyResult).toContain("7:00");
      expect(nyResult).toContain("AM");
    });

    it("accepts timestamp as input", () => {
      const timestamp = new Date("2026-01-01T12:00:00Z").getTime();
      const result = formatInTimezone(timestamp, "UTC");

      expect(result).toBeTruthy();
    });

    it("accepts ISO string as input", () => {
      const result = formatInTimezone("2026-01-01T12:00:00Z", "UTC");

      expect(result).toBeTruthy();
    });

    it("falls back to UTC for invalid timezone", () => {
      const date = new Date("2026-01-01T12:00:00Z");
      const result = formatInTimezone(date, "Invalid/Zone");

      expect(result).toBeTruthy();
    });
  });

  //#endregion formatInTimezone

  //#region getTimezoneOffset

  describe("getTimezoneOffset", () => {
    it("returns 0 for UTC", () => {
      const offset = getTimezoneOffset("UTC");

      expect(offset).toBe(0);
    });

    it("returns correct offset for known timezone", () => {
      // Asia/Kolkata is always UTC+5:30 (no DST)
      const offset = getTimezoneOffset("Asia/Kolkata");

      expect(offset).toBe(330); // 5 * 60 + 30 = 330 minutes
    });

    it("returns 0 for invalid timezone", () => {
      const offset = getTimezoneOffset("Invalid/Zone");

      expect(offset).toBe(0);
    });

    it("accounts for DST when date is provided", () => {
      // New York: UTC-5 in winter, UTC-4 in summer
      const winter = new Date("2026-01-15T12:00:00Z");
      const summer = new Date("2026-07-15T12:00:00Z");

      const winterOffset = getTimezoneOffset("America/New_York", winter);
      const summerOffset = getTimezoneOffset("America/New_York", summer);

      expect(winterOffset).toBe(-300); // -5 hours
      expect(summerOffset).toBe(-240); // -4 hours
    });
  });

  //#endregion getTimezoneOffset

  //#region listTimezones

  describe("listTimezones", () => {
    it("returns array of timezone objects", () => {
      const timezones = listTimezones();

      expect(Array.isArray(timezones)).toBe(true);
      expect(timezones.length).toBeGreaterThan(100);
    });

    it("includes common timezones", () => {
      const timezones = listTimezones();
      const ids = timezones.map((tz) => tz.id);

      expect(ids).toContain("America/New_York");
      expect(ids).toContain("Europe/London");
      expect(ids).toContain("Asia/Tokyo");
      expect(ids).toContain("UTC");
    });

    it("returns correctly structured objects", () => {
      const timezones = listTimezones();
      const utc = timezones.find((tz) => tz.id === "UTC");

      expect(utc).toBeDefined();
      expect(utc?.id).toBe("UTC");
      expect(utc?.offset).toBe(0);
      expect(utc?.offsetLabel).toBe("+00:00");
      expect(utc?.label).toBe("UTC (UTC+00:00)");
    });

    it("is sorted by offset then name", () => {
      const timezones = listTimezones();

      for (let i = 1; i < timezones.length; i++) {
        const prev = timezones[i - 1];
        const curr = timezones[i];

        if (prev.offset === curr.offset) {
          expect(prev.id.localeCompare(curr.id)).toBeLessThanOrEqual(0);
        } else {
          expect(prev.offset).toBeLessThan(curr.offset);
        }
      }
    });
  });

  //#endregion listTimezones

  //#region isValidTimezone

  describe("isValidTimezone", () => {
    it("returns true for valid timezone", () => {
      expect(isValidTimezone("America/New_York")).toBe(true);
      expect(isValidTimezone("UTC")).toBe(true);
      expect(isValidTimezone("Europe/London")).toBe(true);
    });

    it("returns false for invalid timezone", () => {
      expect(isValidTimezone("Invalid/Zone")).toBe(false);
      expect(isValidTimezone("")).toBe(false);
      expect(isValidTimezone("NotATimezone")).toBe(false);
    });
  });

  //#endregion isValidTimezone

  //#region getCurrentDateForTimezone

  describe("getCurrentDateForTimezone", () => {
    it("returns a Date object", () => {
      const date = getCurrentDateForTimezone("UTC");

      expect(date instanceof Date).toBe(true);
    });

    it("returns date with time set to midnight", () => {
      const date = getCurrentDateForTimezone("UTC");

      expect(date.getHours()).toBe(0);
      expect(date.getMinutes()).toBe(0);
      expect(date.getSeconds()).toBe(0);
    });
  });

  //#endregion getCurrentDateForTimezone

  //#region getCurrentDateTimeForTimezone

  describe("getCurrentDateTimeForTimezone", () => {
    it("returns a Date object", () => {
      const date = getCurrentDateTimeForTimezone("UTC");

      expect(date instanceof Date).toBe(true);
    });

    it("includes time components", () => {
      const date = getCurrentDateTimeForTimezone("UTC");

      // Just verify it's a valid date - exact time depends on when test runs
      expect(date.getTime()).toBeLessThanOrEqual(Date.now());
    });
  });

  //#endregion getCurrentDateTimeForTimezone
});
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- timezone.spec
```
