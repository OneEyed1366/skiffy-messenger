# T5.08: useControlledState Hook

## Metadata

| Field        | Value      |
| ------------ | ---------- |
| **ID**       | T5.08      |
| **Layer**    | L5 - Hooks |
| **Status**   | pending    |
| **Priority** | high       |
| **Estimate** | 2h         |
| **Parallel** | true       |
| **Assignee** | -          |
| **Created**  | 2026-01-04 |
| **Updated**  | 2026-01-04 |

## Dependencies

| Task ID | Name          |
| ------- | ------------- |
| T0.15   | types-utility |

## Blocks

| Task ID | Name                                          |
| ------- | --------------------------------------------- |
| T6.\*   | Form input components                         |
| T10b.\* | Components with controlled/uncontrolled modes |

## Description

Create a generic `useControlledState` hook that manages the controlled/uncontrolled component pattern. When an external `value` prop is provided, the component is "controlled" and defers to that value. When only `defaultValue` is provided (or neither), the component is "uncontrolled" and manages its own internal state.

This pattern is common in form inputs, modals, accordions, and other interactive components that can be used in both controlled and uncontrolled modes.

## Source Files

- `vendor/desktop/webapp/channels/src/components/quick_input/quick_input.tsx` (lines 124-142) - Example of inline controlled pattern
- `vendor/desktop/webapp/channels/src/components/widgets/inputs/input/input.tsx` (lines 117-185) - Validation with controlled state

### Source Analysis

The Mattermost codebase implements controlled/uncontrolled patterns inline without a reusable hook. Common patterns observed:

| Pattern              | Implementation                           |
| -------------------- | ---------------------------------------- |
| Controlled detection | `value !== undefined`                    |
| Internal state sync  | `useEffect` watching external value      |
| Default value        | `useState(defaultValue ?? initialValue)` |
| Setter behavior      | Update internal state, call `onChange`   |

Key behaviors to implement:

- If `value` is provided → component is controlled, use `value` directly
- If only `defaultValue` → component is uncontrolled, use internal state initialized with `defaultValue`
- If neither → use internal state initialized with `undefined`
- `setValue` should update internal state AND call `onChange` if provided

## Migration Target

- **Target File**: `apps/v2/src/hooks/useControlledState/useControlledState.ts`
- **Index Export**: `apps/v2/src/hooks/useControlledState/index.ts`

## Implementation

```typescript
// apps/v2/src/hooks/useControlledState/useControlledState.ts

/**
 * Hook for controlled/uncontrolled component pattern
 * Migrated from: Inline patterns in vendor/desktop/webapp/channels/src/components/
 *
 * Manages internal state but defers to external value if provided.
 * Enables components to work in both controlled and uncontrolled modes.
 */

import { useCallback, useRef, useState } from "react";

//#region Types

type IUseControlledStateOptions<T> = {
  /**
   * Controlled value. When provided, component defers to this value.
   * When `undefined`, component uses internal state.
   */
  value?: T;

  /**
   * Default value for uncontrolled mode.
   * Only used when `value` is `undefined`.
   */
  defaultValue?: T;

  /**
   * Callback fired when value changes.
   * Called regardless of controlled/uncontrolled mode.
   */
  onChange?: (value: T) => void;
};

type IUseControlledStateReturn<T> = readonly [
  /** Current value (controlled or internal) */
  value: T,
  /** Setter function that updates state and calls onChange */
  setValue: (value: T | ((prev: T) => T)) => void,
  /** Whether the component is in controlled mode */
  isControlled: boolean,
];

//#endregion Types

//#region Hook

/**
 * Manages controlled/uncontrolled component state pattern.
 *
 * - When `value` is provided → controlled mode, uses external value
 * - When only `defaultValue` → uncontrolled mode, manages internal state
 * - When neither → uncontrolled mode with `undefined` initial state
 *
 * @typeParam T - The type of the state value
 * @param options - Configuration options
 * @returns Tuple of [currentValue, setValue, isControlled]
 *
 * @example
 * // Uncontrolled with default
 * const [value, setValue] = useControlledState({
 *   defaultValue: '',
 *   onChange: (v) => console.log('Changed:', v),
 * });
 *
 * @example
 * // Controlled mode
 * const [value, setValue] = useControlledState({
 *   value: props.value,
 *   onChange: props.onChange,
 * });
 *
 * @example
 * // Component supporting both modes
 * type IProps = {
 *   value?: string;
 *   defaultValue?: string;
 *   onChange?: (value: string) => void;
 * };
 *
 * function Input({ value: valueProp, defaultValue, onChange }: IProps) {
 *   const [value, setValue] = useControlledState({
 *     value: valueProp,
 *     defaultValue: defaultValue ?? '',
 *     onChange,
 *   });
 *
 *   return (
 *     <TextInput
 *       value={value}
 *       onChangeText={setValue}
 *     />
 *   );
 * }
 */
export function useControlledState<T>(
  options: IUseControlledStateOptions<T>,
): IUseControlledStateReturn<T>;

export function useControlledState<T>(
  options: IUseControlledStateOptions<T | undefined>,
): IUseControlledStateReturn<T | undefined>;

export function useControlledState<T>(
  options: IUseControlledStateOptions<T | undefined>,
): IUseControlledStateReturn<T | undefined> {
  const { value: controlledValue, defaultValue, onChange } = options;

  // Determine if controlled on first render and warn if it changes
  const isControlled = controlledValue !== undefined;
  const isControlledRef = useRef(isControlled);

  if (__DEV__) {
    if (isControlledRef.current !== isControlled) {
      console.warn(
        "useControlledState: Component is switching between controlled and uncontrolled modes. " +
          "This may cause unexpected behavior. " +
          `Switching from ${isControlledRef.current ? "controlled" : "uncontrolled"} to ${isControlled ? "controlled" : "uncontrolled"}.`,
      );
    }
  }

  // Internal state for uncontrolled mode
  const [internalValue, setInternalValue] = useState<T | undefined>(
    defaultValue,
  );

  // Use controlled value if provided, otherwise use internal state
  const value = isControlled ? controlledValue : internalValue;

  // Setter that updates internal state and calls onChange
  const setValue = useCallback(
    (nextValue: T | undefined | ((prev: T | undefined) => T | undefined)) => {
      const resolvedValue =
        typeof nextValue === "function"
          ? (nextValue as (prev: T | undefined) => T | undefined)(value)
          : nextValue;

      // Always update internal state (even in controlled mode for consistency)
      if (!isControlled) {
        setInternalValue(resolvedValue);
      }

      // Call onChange callback
      onChange?.(resolvedValue as T);
    },
    [isControlled, onChange, value],
  );

  return [value, setValue, isControlled] as const;
}

//#endregion Hook

//#region Utility Types

/**
 * Props pattern for components supporting controlled/uncontrolled modes.
 * Use this to define component props that follow the pattern.
 *
 * @typeParam T - The type of the value
 *
 * @example
 * type IInputProps = IControllableProps<string> & {
 *   placeholder?: string;
 * };
 */
export type IControllableProps<T> = {
  /**
   * Controlled value. Makes the component controlled when provided.
   */
  value?: T;

  /**
   * Default value for uncontrolled mode.
   */
  defaultValue?: T;

  /**
   * Callback fired when value changes.
   */
  onChange?: (value: T) => void;
};

//#endregion Utility Types
```

## Index Export

```typescript
// apps/v2/src/hooks/useControlledState/index.ts

export { useControlledState } from "./useControlledState";
export type { IControllableProps } from "./useControlledState";
```

## Acceptance Criteria

- [ ] Hook returns tuple `[value, setValue, isControlled]`
- [ ] Controlled mode: uses external `value` prop
- [ ] Uncontrolled mode: uses internal state initialized with `defaultValue`
- [ ] `setValue` accepts both value and updater function
- [ ] `onChange` callback called on every `setValue`
- [ ] Dev warning when switching between controlled/uncontrolled
- [ ] Generic type parameter for type safety
- [ ] `IControllableProps<T>` utility type exported
- [ ] All types use `I` prefix naming convention
- [ ] TypeScript strict mode passes
- [ ] No `any` types
- [ ] Exported from `hooks/useControlledState/index.ts`

## Testing

```typescript
// apps/v2/src/hooks/useControlledState/useControlledState.spec.ts

import { act, renderHook } from "@testing-library/react-native";

import { useControlledState } from "./useControlledState";

//#region Uncontrolled Mode Tests

describe("useControlledState - uncontrolled mode", () => {
  it("uses defaultValue as initial state", () => {
    const { result } = renderHook(() =>
      useControlledState({ defaultValue: "initial" }),
    );

    const [value, , isControlled] = result.current;

    expect(value).toBe("initial");
    expect(isControlled).toBe(false);
  });

  it("uses undefined when no defaultValue provided", () => {
    const { result } = renderHook(() => useControlledState<string>({}));

    const [value] = result.current;

    expect(value).toBeUndefined();
  });

  it("updates internal state when setValue called", () => {
    const { result } = renderHook(() =>
      useControlledState({ defaultValue: "initial" }),
    );

    act(() => {
      const [, setValue] = result.current;
      setValue("updated");
    });

    const [value] = result.current;
    expect(value).toBe("updated");
  });

  it("calls onChange when setValue called", () => {
    const onChange = jest.fn();
    const { result } = renderHook(() =>
      useControlledState({ defaultValue: "initial", onChange }),
    );

    act(() => {
      const [, setValue] = result.current;
      setValue("updated");
    });

    expect(onChange).toHaveBeenCalledWith("updated");
    expect(onChange).toHaveBeenCalledTimes(1);
  });

  it("supports updater function in setValue", () => {
    const { result } = renderHook(() =>
      useControlledState({ defaultValue: 0 }),
    );

    act(() => {
      const [, setValue] = result.current;
      setValue((prev) => (prev ?? 0) + 1);
    });

    const [value] = result.current;
    expect(value).toBe(1);
  });

  it("handles multiple updates correctly", () => {
    const onChange = jest.fn();
    const { result } = renderHook(() =>
      useControlledState({ defaultValue: 0, onChange }),
    );

    act(() => {
      const [, setValue] = result.current;
      setValue(1);
    });

    act(() => {
      const [, setValue] = result.current;
      setValue(2);
    });

    const [value] = result.current;
    expect(value).toBe(2);
    expect(onChange).toHaveBeenCalledTimes(2);
  });
});

//#endregion Uncontrolled Mode Tests

//#region Controlled Mode Tests

describe("useControlledState - controlled mode", () => {
  it("uses controlled value when provided", () => {
    const { result } = renderHook(() =>
      useControlledState({ value: "controlled", defaultValue: "default" }),
    );

    const [value, , isControlled] = result.current;

    expect(value).toBe("controlled");
    expect(isControlled).toBe(true);
  });

  it("ignores defaultValue when value is provided", () => {
    const { result } = renderHook(() =>
      useControlledState({ value: "controlled", defaultValue: "ignored" }),
    );

    const [value] = result.current;
    expect(value).toBe("controlled");
  });

  it("reflects external value changes", () => {
    const { result, rerender } = renderHook(
      (props) => useControlledState(props),
      { initialProps: { value: "first" } },
    );

    expect(result.current[0]).toBe("first");

    rerender({ value: "second" });

    expect(result.current[0]).toBe("second");
  });

  it("calls onChange but does not update internal state", () => {
    const onChange = jest.fn();
    const { result } = renderHook(() =>
      useControlledState({ value: "controlled", onChange }),
    );

    act(() => {
      const [, setValue] = result.current;
      setValue("new-value");
    });

    // Value remains controlled
    const [value] = result.current;
    expect(value).toBe("controlled");

    // But onChange is called
    expect(onChange).toHaveBeenCalledWith("new-value");
  });

  it("handles undefined controlled value as uncontrolled", () => {
    const { result } = renderHook(() =>
      useControlledState<string>({ value: undefined, defaultValue: "default" }),
    );

    const [value, , isControlled] = result.current;

    expect(value).toBe("default");
    expect(isControlled).toBe(false);
  });
});

//#endregion Controlled Mode Tests

//#region Type Safety Tests

describe("useControlledState - type safety", () => {
  it("preserves generic type through setValue", () => {
    type IUser = { name: string; age: number };
    const defaultUser: IUser = { name: "John", age: 30 };

    const { result } = renderHook(() =>
      useControlledState<IUser>({ defaultValue: defaultUser }),
    );

    act(() => {
      const [, setValue] = result.current;
      setValue({ name: "Jane", age: 25 });
    });

    const [value] = result.current;
    expect(value).toEqual({ name: "Jane", age: 25 });
  });

  it("works with nullable types", () => {
    const { result } = renderHook(() =>
      useControlledState<string | null>({ defaultValue: null }),
    );

    const [value] = result.current;
    expect(value).toBeNull();

    act(() => {
      const [, setValue] = result.current;
      setValue("not null");
    });

    expect(result.current[0]).toBe("not null");
  });

  it("works with number type", () => {
    const { result } = renderHook(() =>
      useControlledState({ defaultValue: 42 }),
    );

    const [value] = result.current;
    expect(value).toBe(42);
  });

  it("works with boolean type", () => {
    const { result } = renderHook(() =>
      useControlledState({ defaultValue: false }),
    );

    act(() => {
      const [, setValue] = result.current;
      setValue(true);
    });

    const [value] = result.current;
    expect(value).toBe(true);
  });

  it("works with array type", () => {
    const { result } = renderHook(() =>
      useControlledState<string[]>({ defaultValue: ["a", "b"] }),
    );

    act(() => {
      const [, setValue] = result.current;
      setValue((prev) => [...(prev ?? []), "c"]);
    });

    const [value] = result.current;
    expect(value).toEqual(["a", "b", "c"]);
  });
});

//#endregion Type Safety Tests

//#region Edge Cases Tests

describe("useControlledState - edge cases", () => {
  it("handles empty string as controlled value", () => {
    const { result } = renderHook(() =>
      useControlledState({ value: "", defaultValue: "default" }),
    );

    const [value, , isControlled] = result.current;

    // Empty string is still a defined value
    expect(value).toBe("");
    expect(isControlled).toBe(true);
  });

  it("handles zero as controlled value", () => {
    const { result } = renderHook(() =>
      useControlledState({ value: 0, defaultValue: 100 }),
    );

    const [value, , isControlled] = result.current;

    expect(value).toBe(0);
    expect(isControlled).toBe(true);
  });

  it("handles false as controlled value", () => {
    const { result } = renderHook(() =>
      useControlledState({ value: false, defaultValue: true }),
    );

    const [value, , isControlled] = result.current;

    expect(value).toBe(false);
    expect(isControlled).toBe(true);
  });

  it("onChange is optional", () => {
    const { result } = renderHook(() =>
      useControlledState({ defaultValue: "test" }),
    );

    // Should not throw
    act(() => {
      const [, setValue] = result.current;
      setValue("new");
    });

    const [value] = result.current;
    expect(value).toBe("new");
  });

  it("stable setValue reference across renders", () => {
    const { result, rerender } = renderHook(
      (props) => useControlledState(props),
      { initialProps: { defaultValue: "test" } },
    );

    const firstSetValue = result.current[1];

    rerender({ defaultValue: "test" });

    const secondSetValue = result.current[1];

    // Note: setValue reference may change if dependencies change
    // This test documents current behavior
    expect(typeof firstSetValue).toBe("function");
    expect(typeof secondSetValue).toBe("function");
  });
});

//#endregion Edge Cases Tests

//#region Dev Warning Tests

describe("useControlledState - dev warnings", () => {
  const originalWarn = console.warn;

  beforeEach(() => {
    console.warn = jest.fn();
  });

  afterEach(() => {
    console.warn = originalWarn;
  });

  it("warns when switching from uncontrolled to controlled", () => {
    const { rerender } = renderHook(
      (props) => useControlledState<string>(props),
      { initialProps: { defaultValue: "uncontrolled" } },
    );

    rerender({ value: "now-controlled", defaultValue: "uncontrolled" });

    expect(console.warn).toHaveBeenCalledWith(
      expect.stringContaining("switching between controlled and uncontrolled"),
    );
  });

  it("warns when switching from controlled to uncontrolled", () => {
    const { rerender } = renderHook(
      (props) => useControlledState<string>(props),
      { initialProps: { value: "controlled" } },
    );

    rerender({ defaultValue: "now-uncontrolled" });

    expect(console.warn).toHaveBeenCalledWith(
      expect.stringContaining("switching between controlled and uncontrolled"),
    );
  });

  it("does not warn when staying in same mode", () => {
    const { rerender } = renderHook((props) => useControlledState(props), {
      initialProps: { value: "controlled" },
    });

    rerender({ value: "still-controlled" });

    expect(console.warn).not.toHaveBeenCalled();
  });
});

//#endregion Dev Warning Tests
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- useControlledState
```

## Usage Examples

### Basic Input Component

```typescript
import { TextInput } from "react-native";
import { useControlledState } from "@/hooks/useControlledState";
import type { IControllableProps } from "@/hooks/useControlledState";

type IInputProps = IControllableProps<string> & {
  placeholder?: string;
};

export function Input({
  value: valueProp,
  defaultValue = "",
  onChange,
  placeholder,
}: IInputProps) {
  const [value, setValue] = useControlledState({
    value: valueProp,
    defaultValue,
    onChange,
  });

  return (
    <TextInput
      value={value}
      onChangeText={setValue}
      placeholder={placeholder}
    />
  );
}

// Usage - Uncontrolled
<Input defaultValue="Hello" onChange={(v) => console.log(v)} />

// Usage - Controlled
const [text, setText] = useState("");
<Input value={text} onChange={setText} />
```

### Toggle Component

```typescript
import { Pressable, Text } from "react-native";
import { useControlledState } from "@/hooks/useControlledState";

type IToggleProps = {
  value?: boolean;
  defaultValue?: boolean;
  onChange?: (value: boolean) => void;
  label: string;
};

export function Toggle({
  value: valueProp,
  defaultValue = false,
  onChange,
  label,
}: IToggleProps) {
  const [isOn, setIsOn] = useControlledState({
    value: valueProp,
    defaultValue,
    onChange,
  });

  return (
    <Pressable onPress={() => setIsOn(!isOn)}>
      <Text>{label}: {isOn ? "ON" : "OFF"}</Text>
    </Pressable>
  );
}
```

### Accordion Component

```typescript
import { useControlledState } from "@/hooks/useControlledState";

type IAccordionProps = {
  expanded?: boolean;
  defaultExpanded?: boolean;
  onExpandedChange?: (expanded: boolean) => void;
  children: React.ReactNode;
};

export function Accordion({
  expanded: expandedProp,
  defaultExpanded = false,
  onExpandedChange,
  children,
}: IAccordionProps) {
  const [expanded, setExpanded] = useControlledState({
    value: expandedProp,
    defaultValue: defaultExpanded,
    onChange: onExpandedChange,
  });

  return (
    <View>
      <Pressable onPress={() => setExpanded(!expanded)}>
        <Text>{expanded ? "Collapse" : "Expand"}</Text>
      </Pressable>
      {expanded && children}
    </View>
  );
}
```
