# T4.01: Date/Time Formatting Utilities

## Metadata

| Field        | Value                 |
| ------------ | --------------------- |
| **ID**       | T4.01                 |
| **Layer**    | L4 - Formatting Utils |
| **Status**   | pending               |
| **Priority** | high                  |
| **Estimate** | 3h                    |
| **Parallel** | true                  |
| **Assignee** | -                     |
| **Created**  | 2026-01-04            |
| **Updated**  | 2026-01-04            |

## Dependencies

| Task ID | Name          |
| ------- | ------------- |
| T0.15   | types-utility |

## Blocks

| Task ID | Name                         |
| ------- | ---------------------------- |
| T6.13   | component-timestamp          |
| T10b.\* | Components with date display |

## Description

Migrate date/time formatting utilities from Mattermost. The original uses `moment-timezone` and `luxon` libraries. Replace with native `Intl.DateTimeFormat` and `Intl.RelativeTimeFormat` APIs for zero-dependency, locale-aware formatting.

## Source Files

- `vendor/desktop/webapp/channels/src/utils/datetime.ts` (lines 1-111)
- `vendor/desktop/webapp/channels/src/utils/datetime.test.ts`

### Source Analysis

The original implementation uses:

- **moment-timezone**: For date arithmetic, timezone handling, and `startOf()` truncation
- **luxon**: For locale-aware string formatting via `toFormat()` and `toLocaleString()`
- **react-intl**: For localized "Today"/"Yesterday"/"Tomorrow" labels

Key functions migrated:
| Original Function | Purpose |
|-------------------|---------|
| `isSameDay` | Check if two dates are same calendar day |
| `isSameMonth` | Check if two dates are same month/year |
| `isSameYear` | Check if two dates are same year |
| `isToday` | Check if date is today |
| `isYesterday` | Check if date is yesterday |
| `isWithinLastWeek` | Check if date is within last 6 days |
| `getDiff` | Calculate difference between dates in units |
| `isWithin` | Check if date is within threshold of another |
| `relativeFormatDate` | Format with "Today"/"Yesterday" labels |
| `toUTCUnixInSeconds` | Convert to Unix timestamp |

## Migration Target

- **Target File**: `apps/v2/src/utils/datetime/datetime.ts`
- **Index Export**: `apps/v2/src/utils/datetime/index.ts`

## Implementation

```typescript
// apps/v2/src/utils/datetime/datetime.ts

/**
 * Date/time formatting utilities
 * Migrated from: vendor/desktop/webapp/channels/src/utils/datetime.ts
 *
 * Uses native Intl API instead of moment-timezone/luxon for better bundle size
 */

//#region Types

type IDateInput = Date | number | string;

type IRelativeTimeUnit =
  | "year"
  | "quarter"
  | "month"
  | "week"
  | "day"
  | "hour"
  | "minute"
  | "second";

type IFormatDateOptions = {
  locale?: string;
  timeZone?: string;
};

type IFormatTimeOptions = IFormatDateOptions & {
  hour12?: boolean;
  showSeconds?: boolean;
};

type IFormatDateTimeOptions = IFormatDateOptions & {
  hour12?: boolean;
  showSeconds?: boolean;
};

type IRelativeTimeOptions = {
  locale?: string;
  style?: "long" | "short" | "narrow";
};

type IRelativeDateLabels = {
  today?: string;
  yesterday?: string;
  tomorrow?: string;
};

//#endregion Types

//#region Constants

const MS_PER_SECOND = 1000;
const MS_PER_MINUTE = MS_PER_SECOND * 60;
const MS_PER_HOUR = MS_PER_MINUTE * 60;
const MS_PER_DAY = MS_PER_HOUR * 24;
const MS_PER_WEEK = MS_PER_DAY * 7;
const MS_PER_MONTH = MS_PER_DAY * 30;
const MS_PER_QUARTER = MS_PER_DAY * 91;
const MS_PER_YEAR = MS_PER_DAY * 365;

/**
 * Units that should truncate to start of period when comparing
 */
const TRUNCATE_UNITS = new Set<IRelativeTimeUnit>([
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "second",
]);

//#endregion Constants

//#region Helpers

/**
 * Normalizes input to a Date object.
 */
function toDate(input: IDateInput): Date {
  if (input instanceof Date) {
    return input;
  }
  return new Date(input);
}

/**
 * Returns the start of a day (00:00:00.000) for a given date.
 */
function startOfDay(date: Date): Date {
  const result = new Date(date);
  result.setHours(0, 0, 0, 0);
  return result;
}

/**
 * Truncate a date to the start of a given unit.
 */
function truncateToUnit(date: Date, unit: IRelativeTimeUnit): Date {
  const result = new Date(date);

  switch (unit) {
    case "second":
      result.setMilliseconds(0);
      break;
    case "minute":
      result.setSeconds(0, 0);
      break;
    case "hour":
      result.setMinutes(0, 0, 0);
      break;
    case "day":
      result.setHours(0, 0, 0, 0);
      break;
    case "week": {
      result.setHours(0, 0, 0, 0);
      const day = result.getDay();
      result.setDate(result.getDate() - day);
      break;
    }
    case "month":
      result.setHours(0, 0, 0, 0);
      result.setDate(1);
      break;
    case "quarter": {
      result.setHours(0, 0, 0, 0);
      result.setDate(1);
      const quarter = Math.floor(result.getMonth() / 3);
      result.setMonth(quarter * 3);
      break;
    }
    case "year":
      result.setHours(0, 0, 0, 0);
      result.setMonth(0, 1);
      break;
  }

  return result;
}

/**
 * Get the browser's current timezone.
 */
function getBrowserTimezone(): string {
  return Intl.DateTimeFormat().resolvedOptions().timeZone;
}

//#endregion Helpers

//#region Date Comparison

/**
 * Checks if two dates are the same calendar day.
 *
 * @param a - First date
 * @param b - Second date (defaults to now)
 * @returns True if both dates are the same day
 *
 * @example
 * isSameDay(new Date('2026-01-04'), new Date('2026-01-04')); // true
 * isSameDay(new Date('2026-01-04'), new Date('2026-01-05')); // false
 */
export function isSameDay(a: IDateInput, b: IDateInput = new Date()): boolean {
  const dateA = toDate(a);
  const dateB = toDate(b);

  return (
    dateA.getFullYear() === dateB.getFullYear() &&
    dateA.getMonth() === dateB.getMonth() &&
    dateA.getDate() === dateB.getDate()
  );
}

/**
 * Checks if two dates are in the same month and year.
 *
 * @param a - First date
 * @param b - Second date (defaults to now)
 * @returns True if both dates are in the same month
 */
export function isSameMonth(
  a: IDateInput,
  b: IDateInput = new Date(),
): boolean {
  const dateA = toDate(a);
  const dateB = toDate(b);

  return (
    dateA.getFullYear() === dateB.getFullYear() &&
    dateA.getMonth() === dateB.getMonth()
  );
}

/**
 * Checks if two dates are in the same year.
 *
 * @param a - First date
 * @param b - Second date (defaults to now)
 * @returns True if both dates are in the same year
 */
export function isSameYear(a: IDateInput, b: IDateInput = new Date()): boolean {
  const dateA = toDate(a);
  const dateB = toDate(b);

  return dateA.getFullYear() === dateB.getFullYear();
}

/**
 * Checks if a date is today.
 *
 * @param date - The date to check
 * @returns True if the date is today
 *
 * @example
 * isToday(new Date()); // true
 */
export function isToday(date: IDateInput): boolean {
  return isSameDay(date, new Date());
}

/**
 * Checks if a date is yesterday.
 *
 * @param date - The date to check
 * @returns True if the date is yesterday
 *
 * @example
 * const yesterday = new Date();
 * yesterday.setDate(yesterday.getDate() - 1);
 * isYesterday(yesterday); // true
 */
export function isYesterday(date: IDateInput): boolean {
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);

  return isSameDay(date, yesterday);
}

/**
 * Checks if a date is tomorrow.
 *
 * @param date - The date to check
 * @returns True if the date is tomorrow
 */
export function isTomorrow(date: IDateInput): boolean {
  const tomorrow = new Date();
  tomorrow.setDate(tomorrow.getDate() + 1);

  return isSameDay(date, tomorrow);
}

/**
 * Checks if a date is within the last 7 days (including today).
 *
 * @param date - The date to check
 * @returns True if the date is within the last week
 */
export function isWithinLastWeek(date: IDateInput): boolean {
  const inputDate = toDate(date);
  const sixDaysAgo = new Date();
  sixDaysAgo.setDate(sixDaysAgo.getDate() - 6);
  sixDaysAgo.setHours(0, 0, 0, 0);

  return inputDate >= sixDaysAgo;
}

//#endregion Date Comparison

//#region Date Difference

/**
 * Calculates the difference between two dates in the specified unit.
 *
 * @param a - First date
 * @param b - Second date
 * @param unit - The unit to calculate difference in
 * @param timeZone - Timezone for calculations (defaults to browser timezone)
 * @param truncate - Whether to truncate to start of unit (default: true for day+, false for hour/minute)
 * @returns The difference as an integer (positive if a > b)
 *
 * @example
 * const now = new Date();
 * const yesterday = new Date(now);
 * yesterday.setDate(yesterday.getDate() - 1);
 * getDiff(now, yesterday, 'day'); // 1
 */
export function getDiff(
  a: IDateInput,
  b: IDateInput,
  unit: IRelativeTimeUnit,
  timeZone: string = getBrowserTimezone(),
  truncate: boolean = TRUNCATE_UNITS.has(unit),
): number {
  let dateA = toDate(a);
  let dateB = toDate(b);

  if (truncate) {
    dateA = truncateToUnit(dateA, unit);
    dateB = truncateToUnit(dateB, unit);
  }

  const diffMs = dateA.getTime() - dateB.getTime();

  switch (unit) {
    case "year":
      return Math.floor(diffMs / MS_PER_YEAR);
    case "quarter":
      return Math.floor(diffMs / MS_PER_QUARTER);
    case "month":
      return Math.floor(diffMs / MS_PER_MONTH);
    case "week":
      return Math.floor(diffMs / MS_PER_WEEK);
    case "day":
      return Math.round(diffMs / MS_PER_DAY);
    case "hour":
      return Math.round(diffMs / MS_PER_HOUR);
    case "minute":
      return Math.round(diffMs / MS_PER_MINUTE);
    case "second":
      return Math.round(diffMs / MS_PER_SECOND);
  }
}

/**
 * Check if date `a` is within `threshold` units of date `b`.
 *
 * @param a - First date
 * @param b - Second date
 * @param unit - The unit to measure
 * @param threshold - Number of units (default: 1)
 * @param timeZone - Timezone for calculations
 * @param truncate - Whether to truncate to start of unit
 * @returns True if within threshold
 */
export function isWithin(
  a: IDateInput,
  b: IDateInput,
  unit: IRelativeTimeUnit,
  threshold: number = 1,
  timeZone: string = getBrowserTimezone(),
  truncate: boolean = TRUNCATE_UNITS.has(unit),
): boolean {
  const diff = getDiff(a, b, unit, timeZone, truncate);
  return threshold >= 0
    ? diff <= threshold && diff >= 0
    : diff >= threshold && diff <= 0;
}

//#endregion Date Difference

//#region Formatting

/**
 * Formats a date as a localized date string.
 *
 * @param date - The date to format
 * @param options - Formatting options
 * @returns Formatted date string (e.g., "January 4, 2026" or "04.01.2026")
 *
 * @example
 * formatDate(new Date('2026-01-04')); // "January 4, 2026" (en-US)
 * formatDate(new Date('2026-01-04'), { locale: 'de-DE' }); // "4. Januar 2026"
 */
export function formatDate(
  date: IDateInput,
  options: IFormatDateOptions = {},
): string {
  const { locale, timeZone } = options;
  const dateObj = toDate(date);

  return new Intl.DateTimeFormat(locale, {
    year: "numeric",
    month: "long",
    day: "numeric",
    timeZone,
  }).format(dateObj);
}

/**
 * Formats a date as a short date string.
 *
 * @param date - The date to format
 * @param options - Formatting options
 * @returns Formatted short date string (e.g., "1/4/26" or "04.01.26")
 *
 * @example
 * formatDateShort(new Date('2026-01-04')); // "1/4/26" (en-US)
 */
export function formatDateShort(
  date: IDateInput,
  options: IFormatDateOptions = {},
): string {
  const { locale, timeZone } = options;
  const dateObj = toDate(date);

  return new Intl.DateTimeFormat(locale, {
    year: "2-digit",
    month: "numeric",
    day: "numeric",
    timeZone,
  }).format(dateObj);
}

/**
 * Formats a date as a localized time string.
 *
 * @param date - The date to format
 * @param options - Formatting options
 * @returns Formatted time string (e.g., "2:30 PM" or "14:30")
 *
 * @example
 * formatTime(new Date('2026-01-04T14:30:00')); // "2:30 PM" (en-US)
 * formatTime(new Date('2026-01-04T14:30:00'), { hour12: false }); // "14:30"
 */
export function formatTime(
  date: IDateInput,
  options: IFormatTimeOptions = {},
): string {
  const { locale, timeZone, hour12, showSeconds = false } = options;
  const dateObj = toDate(date);

  return new Intl.DateTimeFormat(locale, {
    hour: "numeric",
    minute: "2-digit",
    second: showSeconds ? "2-digit" : undefined,
    hour12,
    timeZone,
  }).format(dateObj);
}

/**
 * Formats a date as a localized date and time string.
 *
 * @param date - The date to format
 * @param options - Formatting options
 * @returns Formatted date and time string (e.g., "January 4, 2026 at 2:30 PM")
 *
 * @example
 * formatDateTime(new Date('2026-01-04T14:30:00'));
 * // "January 4, 2026 at 2:30 PM" (en-US)
 */
export function formatDateTime(
  date: IDateInput,
  options: IFormatDateTimeOptions = {},
): string {
  const { locale, timeZone, hour12, showSeconds = false } = options;
  const dateObj = toDate(date);

  return new Intl.DateTimeFormat(locale, {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
    second: showSeconds ? "2-digit" : undefined,
    hour12,
    timeZone,
  }).format(dateObj);
}

/**
 * Formats a date as a short date and time string.
 *
 * @param date - The date to format
 * @param options - Formatting options
 * @returns Formatted short date and time string (e.g., "1/4/26, 2:30 PM")
 */
export function formatDateTimeShort(
  date: IDateInput,
  options: IFormatDateTimeOptions = {},
): string {
  const { locale, timeZone, hour12, showSeconds = false } = options;
  const dateObj = toDate(date);

  return new Intl.DateTimeFormat(locale, {
    year: "2-digit",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
    second: showSeconds ? "2-digit" : undefined,
    hour12,
    timeZone,
  }).format(dateObj);
}

//#endregion Formatting

//#region Relative Time

/**
 * Formats a date as a relative time string (e.g., "5 minutes ago", "in 2 days").
 *
 * @param date - The date to format relative to now
 * @param options - Formatting options
 * @returns Relative time string
 *
 * @example
 * // 5 minutes ago
 * const fiveMinAgo = new Date(Date.now() - 5 * 60 * 1000);
 * getRelativeTime(fiveMinAgo); // "5 minutes ago"
 *
 * // In 2 days
 * const inTwoDays = new Date(Date.now() + 2 * 24 * 60 * 60 * 1000);
 * getRelativeTime(inTwoDays); // "in 2 days"
 */
export function getRelativeTime(
  date: IDateInput,
  options: IRelativeTimeOptions = {},
): string {
  const { locale, style = "long" } = options;
  const dateObj = toDate(date);
  const now = Date.now();
  const diffMs = dateObj.getTime() - now;
  const absDiffMs = Math.abs(diffMs);

  const rtf = new Intl.RelativeTimeFormat(locale, {
    numeric: "auto",
    style,
  });

  // Determine the best unit to use
  if (absDiffMs < MS_PER_MINUTE) {
    const seconds = Math.round(diffMs / MS_PER_SECOND);
    return rtf.format(seconds, "second");
  }

  if (absDiffMs < MS_PER_HOUR) {
    const minutes = Math.round(diffMs / MS_PER_MINUTE);
    return rtf.format(minutes, "minute");
  }

  if (absDiffMs < MS_PER_DAY) {
    const hours = Math.round(diffMs / MS_PER_HOUR);
    return rtf.format(hours, "hour");
  }

  if (absDiffMs < MS_PER_WEEK) {
    const days = Math.round(diffMs / MS_PER_DAY);
    return rtf.format(days, "day");
  }

  if (absDiffMs < MS_PER_MONTH) {
    const weeks = Math.round(diffMs / MS_PER_WEEK);
    return rtf.format(weeks, "week");
  }

  if (absDiffMs < MS_PER_YEAR) {
    const months = Math.round(diffMs / MS_PER_MONTH);
    return rtf.format(months, "month");
  }

  const years = Math.round(diffMs / MS_PER_YEAR);
  return rtf.format(years, "year");
}

/**
 * Formats a date with "Today", "Yesterday", "Tomorrow", or the formatted date.
 * Useful for message timestamps and date separators.
 *
 * @param date - The date to format
 * @param options - Formatting options
 * @param labels - Custom labels for today/yesterday/tomorrow (for i18n)
 * @returns "Today", "Yesterday", "Tomorrow", or formatted date string
 *
 * @example
 * formatRelativeDate(new Date()); // "Today"
 *
 * const yesterday = new Date();
 * yesterday.setDate(yesterday.getDate() - 1);
 * formatRelativeDate(yesterday); // "Yesterday"
 *
 * formatRelativeDate(new Date('2026-01-01')); // "January 1, 2026"
 */
export function formatRelativeDate(
  date: IDateInput,
  options: IFormatDateOptions = {},
  labels: IRelativeDateLabels = {},
): string {
  const {
    today = "Today",
    yesterday = "Yesterday",
    tomorrow = "Tomorrow",
  } = labels;

  if (isToday(date)) {
    return today;
  }

  if (isYesterday(date)) {
    return yesterday;
  }

  if (isTomorrow(date)) {
    return tomorrow;
  }

  return formatDate(date, options);
}

//#endregion Relative Time

//#region Unix Timestamp

/**
 * Converts a date to Unix timestamp in seconds.
 *
 * @param date - The date to convert
 * @returns Unix timestamp in seconds
 *
 * @example
 * toUnixSeconds(new Date('2026-01-04T00:00:00Z')); // 1767484800
 */
export function toUnixSeconds(date: IDateInput): number {
  const dateObj = toDate(date);
  return Math.floor(dateObj.getTime() / MS_PER_SECOND);
}

/**
 * Creates a Date from Unix timestamp in seconds.
 *
 * @param timestamp - Unix timestamp in seconds
 * @returns Date object
 *
 * @example
 * fromUnixSeconds(1767484800); // Date representing 2026-01-04T00:00:00Z
 */
export function fromUnixSeconds(timestamp: number): Date {
  return new Date(timestamp * MS_PER_SECOND);
}

//#endregion Unix Timestamp
```

## Index Export

```typescript
// apps/v2/src/utils/datetime/index.ts

export {
  // Date Comparison
  isSameDay,
  isSameMonth,
  isSameYear,
  isToday,
  isYesterday,
  isTomorrow,
  isWithinLastWeek,
  // Date Difference
  getDiff,
  isWithin,
  // Formatting
  formatDate,
  formatDateShort,
  formatTime,
  formatDateTime,
  formatDateTimeShort,
  // Relative Time
  getRelativeTime,
  formatRelativeDate,
  // Unix Timestamp
  toUnixSeconds,
  fromUnixSeconds,
} from "./datetime";
```

## Acceptance Criteria

- [ ] Uses `Intl.DateTimeFormat` for locale-aware formatting (no moment/date-fns)
- [ ] Uses `Intl.RelativeTimeFormat` for relative time strings
- [ ] All types use `I` prefix naming convention
- [ ] Functions accept flexible input (Date, number, string)
- [ ] `isToday`, `isYesterday`, `isSameDay` work correctly across day boundaries
- [ ] `getRelativeTime` returns human-readable strings ("5 minutes ago")
- [ ] `formatRelativeDate` returns "Today"/"Yesterday"/"Tomorrow" with i18n support
- [ ] Exported from `utils/datetime/index.ts`
- [ ] TypeScript strict mode passes
- [ ] No `any` types
- [ ] No external dependencies (moment, date-fns, luxon)

## Testing

```typescript
// apps/v2/src/utils/datetime/datetime.spec.ts

import {
  isSameDay,
  isSameMonth,
  isSameYear,
  isToday,
  isYesterday,
  isTomorrow,
  isWithinLastWeek,
  getDiff,
  isWithin,
  formatDate,
  formatDateShort,
  formatTime,
  formatDateTime,
  formatDateTimeShort,
  getRelativeTime,
  formatRelativeDate,
  toUnixSeconds,
  fromUnixSeconds,
} from "./datetime";

//#region Date Comparison Tests

describe("isSameDay", () => {
  it("returns true for same day", () => {
    const a = new Date("2026-01-04T10:00:00");
    const b = new Date("2026-01-04T22:00:00");

    expect(isSameDay(a, b)).toBe(true);
  });

  it("returns false for different days", () => {
    const a = new Date("2026-01-04T23:59:59");
    const b = new Date("2026-01-05T00:00:00");

    expect(isSameDay(a, b)).toBe(false);
  });

  it("accepts number timestamp", () => {
    const timestamp = Date.now();

    expect(isSameDay(timestamp, new Date())).toBe(true);
  });

  it("accepts ISO string", () => {
    const today = new Date();
    const isoString = today.toISOString();

    expect(isSameDay(isoString, today)).toBe(true);
  });
});

describe("isToday", () => {
  it("returns true for current date", () => {
    expect(isToday(new Date())).toBe(true);
  });

  it("returns true for today at midnight", () => {
    const midnight = new Date();
    midnight.setHours(0, 0, 0, 0);

    expect(isToday(midnight)).toBe(true);
  });

  it("returns true for today at 11:59 PM", () => {
    const endOfDay = new Date();
    endOfDay.setHours(23, 59, 59, 999);

    expect(isToday(endOfDay)).toBe(true);
  });

  it("returns false for tomorrow", () => {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);

    expect(isToday(tomorrow)).toBe(false);
  });

  it("returns false for yesterday", () => {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);

    expect(isToday(yesterday)).toBe(false);
  });
});

describe("isYesterday", () => {
  it("returns true for yesterday", () => {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);

    expect(isYesterday(yesterday)).toBe(true);
  });

  it("returns true for yesterday at midnight", () => {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday.setHours(0, 0, 0, 0);

    expect(isYesterday(yesterday)).toBe(true);
  });

  it("returns true for yesterday at 11:59 PM", () => {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday.setHours(23, 59, 59, 999);

    expect(isYesterday(yesterday)).toBe(true);
  });

  it("returns false for today", () => {
    expect(isYesterday(new Date())).toBe(false);
  });

  it("returns false for two days ago", () => {
    const twoDaysAgo = new Date();
    twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);

    expect(isYesterday(twoDaysAgo)).toBe(false);
  });
});

describe("isTomorrow", () => {
  it("returns true for tomorrow", () => {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);

    expect(isTomorrow(tomorrow)).toBe(true);
  });

  it("returns false for today", () => {
    expect(isTomorrow(new Date())).toBe(false);
  });
});

describe("isSameMonth", () => {
  it("returns true for same month", () => {
    const a = new Date("2026-01-01");
    const b = new Date("2026-01-31");

    expect(isSameMonth(a, b)).toBe(true);
  });

  it("returns false for different months", () => {
    const a = new Date("2026-01-31");
    const b = new Date("2026-02-01");

    expect(isSameMonth(a, b)).toBe(false);
  });
});

describe("isSameYear", () => {
  it("returns true for same year", () => {
    const a = new Date("2026-01-01");
    const b = new Date("2026-12-31");

    expect(isSameYear(a, b)).toBe(true);
  });

  it("returns false for different years", () => {
    const a = new Date("2025-12-31");
    const b = new Date("2026-01-01");

    expect(isSameYear(a, b)).toBe(false);
  });
});

describe("isWithinLastWeek", () => {
  it("returns true for today", () => {
    expect(isWithinLastWeek(new Date())).toBe(true);
  });

  it("returns true for 6 days ago", () => {
    const sixDaysAgo = new Date();
    sixDaysAgo.setDate(sixDaysAgo.getDate() - 6);

    expect(isWithinLastWeek(sixDaysAgo)).toBe(true);
  });

  it("returns false for 7 days ago", () => {
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    sevenDaysAgo.setHours(0, 0, 0, 0);

    expect(isWithinLastWeek(sevenDaysAgo)).toBe(false);
  });
});

//#endregion Date Comparison Tests

//#region Date Difference Tests

describe("getDiff", () => {
  it("returns 0 for same day", () => {
    const now = new Date();
    const sameDay = new Date(now);
    sameDay.setHours(now.getHours() + 1);

    expect(getDiff(sameDay, now, "day")).toBe(0);
  });

  it("returns 1 for tomorrow vs today", () => {
    const now = new Date();
    now.setHours(12, 0, 0, 0);
    const tomorrow = new Date(now);
    tomorrow.setDate(tomorrow.getDate() + 1);

    expect(getDiff(tomorrow, now, "day")).toBe(1);
  });

  it("returns -1 for yesterday vs today", () => {
    const now = new Date();
    now.setHours(12, 0, 0, 0);
    const yesterday = new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);

    expect(getDiff(yesterday, now, "day")).toBe(-1);
  });

  it("calculates hours correctly", () => {
    const now = new Date();
    const threeHoursLater = new Date(now.getTime() + 3 * 60 * 60 * 1000);

    expect(getDiff(threeHoursLater, now, "hour")).toBe(3);
  });

  it("calculates minutes correctly", () => {
    const now = new Date();
    const thirtyMinLater = new Date(now.getTime() + 30 * 60 * 1000);

    expect(getDiff(thirtyMinLater, now, "minute")).toBe(30);
  });
});

describe("isWithin", () => {
  it("returns true when within threshold", () => {
    const now = new Date();
    const soonAfter = new Date(now.getTime() + 30 * 60 * 1000); // 30 min later

    expect(isWithin(soonAfter, now, "hour", 1)).toBe(true);
  });

  it("returns false when outside threshold", () => {
    const now = new Date();
    const muchLater = new Date(now.getTime() + 3 * 60 * 60 * 1000); // 3 hours later

    expect(isWithin(muchLater, now, "hour", 1)).toBe(false);
  });
});

//#endregion Date Difference Tests

//#region Formatting Tests

describe("formatDate", () => {
  it("formats date with default locale", () => {
    const date = new Date("2026-01-04T12:00:00");
    const result = formatDate(date);

    expect(result).toContain("2026");
    expect(result).toContain("4");
  });

  it("formats date with specific locale", () => {
    const date = new Date("2026-01-04T12:00:00");
    const result = formatDate(date, { locale: "en-US" });

    expect(result).toBe("January 4, 2026");
  });
});

describe("formatDateShort", () => {
  it("formats short date", () => {
    const date = new Date("2026-01-04T12:00:00");
    const result = formatDateShort(date, { locale: "en-US" });

    expect(result).toContain("1");
    expect(result).toContain("4");
    expect(result).toContain("26");
  });
});

describe("formatTime", () => {
  it("formats time with 12-hour format", () => {
    const date = new Date("2026-01-04T14:30:00");
    const result = formatTime(date, { locale: "en-US", hour12: true });

    expect(result).toContain("2:30");
    expect(result).toContain("PM");
  });

  it("formats time with 24-hour format", () => {
    const date = new Date("2026-01-04T14:30:00");
    const result = formatTime(date, { locale: "en-US", hour12: false });

    expect(result).toContain("14:30");
  });

  it("includes seconds when requested", () => {
    const date = new Date("2026-01-04T14:30:45");
    const result = formatTime(date, {
      locale: "en-US",
      hour12: false,
      showSeconds: true,
    });

    expect(result).toContain("45");
  });
});

describe("formatDateTime", () => {
  it("formats date and time", () => {
    const date = new Date("2026-01-04T14:30:00");
    const result = formatDateTime(date, { locale: "en-US" });

    expect(result).toContain("January");
    expect(result).toContain("4");
    expect(result).toContain("2026");
    expect(result).toContain("2:30");
  });
});

describe("formatDateTimeShort", () => {
  it("formats short date and time", () => {
    const date = new Date("2026-01-04T14:30:00");
    const result = formatDateTimeShort(date, { locale: "en-US" });

    expect(result).toContain("1");
    expect(result).toContain("4");
  });
});

//#endregion Formatting Tests

//#region Relative Time Tests

describe("getRelativeTime", () => {
  it("formats seconds ago", () => {
    const thirtySecondsAgo = new Date(Date.now() - 30 * 1000);
    const result = getRelativeTime(thirtySecondsAgo, { locale: "en-US" });

    expect(result).toContain("second");
  });

  it("formats minutes ago", () => {
    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
    const result = getRelativeTime(fiveMinutesAgo, { locale: "en-US" });

    expect(result).toContain("5");
    expect(result).toContain("minute");
  });

  it("formats hours ago", () => {
    const twoHoursAgo = new Date(Date.now() - 2 * 60 * 60 * 1000);
    const result = getRelativeTime(twoHoursAgo, { locale: "en-US" });

    expect(result).toContain("2");
    expect(result).toContain("hour");
  });

  it("formats days in future", () => {
    const inThreeDays = new Date(Date.now() + 3 * 24 * 60 * 60 * 1000);
    const result = getRelativeTime(inThreeDays, { locale: "en-US" });

    expect(result).toContain("3");
    expect(result).toContain("day");
  });
});

describe("formatRelativeDate", () => {
  it("returns 'Today' for today", () => {
    const result = formatRelativeDate(new Date());

    expect(result).toBe("Today");
  });

  it("returns 'Yesterday' for yesterday", () => {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const result = formatRelativeDate(yesterday);

    expect(result).toBe("Yesterday");
  });

  it("returns 'Tomorrow' for tomorrow", () => {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    const result = formatRelativeDate(tomorrow);

    expect(result).toBe("Tomorrow");
  });

  it("returns formatted date for other days", () => {
    const lastWeek = new Date();
    lastWeek.setDate(lastWeek.getDate() - 7);
    const result = formatRelativeDate(lastWeek, { locale: "en-US" });

    expect(result).not.toBe("Today");
    expect(result).not.toBe("Yesterday");
    expect(result).not.toBe("Tomorrow");
    expect(result).toContain("202");
  });

  it("uses custom labels for i18n", () => {
    const result = formatRelativeDate(
      new Date(),
      {},
      { today: "Heute", yesterday: "Gestern", tomorrow: "Morgen" },
    );

    expect(result).toBe("Heute");
  });
});

//#endregion Relative Time Tests

//#region Unix Timestamp Tests

describe("toUnixSeconds", () => {
  it("converts date to Unix timestamp", () => {
    const date = new Date("2026-01-04T00:00:00Z");
    const result = toUnixSeconds(date);

    expect(result).toBe(1767484800);
  });

  it("truncates milliseconds", () => {
    const date = new Date("2026-01-04T00:00:00.999Z");
    const result = toUnixSeconds(date);

    expect(result).toBe(1767484800);
  });
});

describe("fromUnixSeconds", () => {
  it("creates date from Unix timestamp", () => {
    const result = fromUnixSeconds(1767484800);

    expect(result.toISOString()).toBe("2026-01-04T00:00:00.000Z");
  });
});

//#endregion Unix Timestamp Tests
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- datetime
```
