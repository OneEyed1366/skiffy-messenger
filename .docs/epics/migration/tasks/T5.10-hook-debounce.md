# T5.10: Debounce and Throttle Hooks

## Metadata

| Field        | Value      |
| ------------ | ---------- |
| **ID**       | T5.10      |
| **Layer**    | L5 - Hooks |
| **Status**   | pending    |
| **Priority** | high       |
| **Estimate** | 2h         |
| **Parallel** | true       |
| **Assignee** | -          |
| **Created**  | 2026-01-04 |
| **Updated**  | 2026-01-04 |

## Dependencies

| Task ID | Name          |
| ------- | ------------- |
| T0.15   | types-utility |

## Blocks

| Task ID | Name                          |
| ------- | ----------------------------- |
| T6.\*   | Components with search inputs |
| T10b.\* | Components with scroll events |

## Description

Create `useDebounce` and `useThrottle` hooks for controlling the rate of value changes. These patterns are heavily used throughout the Mattermost codebase for:

- Search input debouncing (prevent API calls on every keystroke)
- Scroll event throttling (limit expensive recalculations)
- Resize event handling (prevent layout thrashing)
- WebSocket message batching

The original implementation uses `lodash/debounce` and `lodash/throttle`, plus a custom `debounce` function in `mattermost-redux/actions/helpers.ts`. We replace these with zero-dependency React hooks.

## Source Files

- `vendor/desktop/webapp/channels/src/packages/mattermost-redux/src/actions/helpers.ts` (lines 117-141)
- `vendor/desktop/webapp/channels/src/components/common/hooks/useGetAgentsBridgeEnabled.ts` (debounce pattern)
- `vendor/desktop/webapp/channels/src/components/channel_members_rhs/channel_members_rhs.tsx` (useCallback + debounce)
- `vendor/desktop/webapp/platform/components/src/common/hooks/useMeasurePunchouts.ts` (throttle pattern)

### Source Analysis

The codebase uses several debounce/throttle patterns:

| Pattern                            | Usage                                                        |
| ---------------------------------- | ------------------------------------------------------------ |
| `lodash/debounce`                  | Search inputs, scroll handlers, resize observers             |
| `lodash/throttle`                  | Mouse events, scroll tracking, resize handlers               |
| Custom `debounce()`                | Redux actions with optional immediate execution and callback |
| Manual `setTimeout`/`clearTimeout` | Inline debouncing in useCallback                             |

Key features needed:

- **useDebounce**: Returns debounced value after delay of inactivity
- **useDebouncedCallback**: Returns memoized debounced function with cancel/flush
- **useThrottle**: Returns throttled value at fixed intervals
- **useThrottledCallback**: Returns memoized throttled function with cancel

## Migration Target

- **Target File**: `apps/v2/src/hooks/useDebounce/useDebounce.ts`
- **Index Export**: `apps/v2/src/hooks/useDebounce/index.ts`

## Implementation

```typescript
// apps/v2/src/hooks/useDebounce/useDebounce.ts

/**
 * Debounce and throttle hooks
 * Migrated from: lodash/debounce, lodash/throttle, mattermost-redux/actions/helpers
 *
 * Zero-dependency implementations using native setTimeout/Date.now()
 */

import { useEffect, useRef, useState, useCallback } from "react";

//#region Types

type IDebounceOptions = {
  /** Delay in milliseconds (default: 300) */
  delay?: number;
  /** Execute on leading edge instead of trailing (default: false) */
  leading?: boolean;
  /** Maximum time to wait before forced execution (default: undefined) */
  maxWait?: number;
};

type IThrottleOptions = {
  /** Interval in milliseconds (default: 300) */
  interval?: number;
  /** Execute on leading edge (default: true) */
  leading?: boolean;
  /** Execute on trailing edge (default: true) */
  trailing?: boolean;
};

type IDebouncedFunction<T extends (...args: unknown[]) => unknown> = {
  (...args: Parameters<T>): void;
  /** Cancel pending execution */
  cancel: () => void;
  /** Immediately execute pending call */
  flush: () => void;
  /** Check if there's a pending execution */
  pending: () => boolean;
};

type IThrottledFunction<T extends (...args: unknown[]) => unknown> = {
  (...args: Parameters<T>): void;
  /** Cancel pending execution */
  cancel: () => void;
};

//#endregion Types

//#region useDebounce

/**
 * Returns a debounced value that only updates after the specified delay
 * of inactivity.
 *
 * @param value - The value to debounce
 * @param delay - Delay in milliseconds (default: 300)
 * @returns The debounced value
 *
 * @example
 * const [searchTerm, setSearchTerm] = useState('');
 * const debouncedSearch = useDebounce(searchTerm, 500);
 *
 * useEffect(() => {
 *   if (debouncedSearch) {
 *     fetchResults(debouncedSearch);
 *   }
 * }, [debouncedSearch]);
 */
export function useDebounce<T>(value: T, delay: number = 300): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
}

//#endregion useDebounce

//#region useDebouncedCallback

/**
 * Returns a memoized debounced version of the callback function.
 * The debounced function delays invoking the callback until after
 * the specified delay has elapsed since the last call.
 *
 * @param callback - The function to debounce
 * @param options - Debounce options
 * @returns Debounced function with cancel, flush, and pending methods
 *
 * @example
 * const debouncedSearch = useDebouncedCallback(
 *   (term: string) => fetchResults(term),
 *   { delay: 500 }
 * );
 *
 * // In event handler
 * <TextInput onChangeText={debouncedSearch} />
 *
 * // Cancel on unmount or navigation
 * useEffect(() => {
 *   return () => debouncedSearch.cancel();
 * }, []);
 */
export function useDebouncedCallback<T extends (...args: never[]) => unknown>(
  callback: T,
  options: IDebounceOptions = {},
): IDebouncedFunction<T> {
  const { delay = 300, leading = false, maxWait } = options;

  const callbackRef = useRef(callback);
  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const maxWaitTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const lastArgsRef = useRef<Parameters<T> | null>(null);
  const lastCallTimeRef = useRef<number | null>(null);
  const hasLeadingCalledRef = useRef(false);

  // Keep callback ref updated
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  const invokeCallback = useCallback(() => {
    if (lastArgsRef.current !== null) {
      callbackRef.current(...lastArgsRef.current);
      lastArgsRef.current = null;
      hasLeadingCalledRef.current = false;
    }
  }, []);

  const cancel = useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
    if (maxWaitTimeoutRef.current) {
      clearTimeout(maxWaitTimeoutRef.current);
      maxWaitTimeoutRef.current = null;
    }
    lastArgsRef.current = null;
    lastCallTimeRef.current = null;
    hasLeadingCalledRef.current = false;
  }, []);

  const flush = useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
    if (maxWaitTimeoutRef.current) {
      clearTimeout(maxWaitTimeoutRef.current);
      maxWaitTimeoutRef.current = null;
    }
    invokeCallback();
  }, [invokeCallback]);

  const pending = useCallback(() => {
    return timeoutRef.current !== null;
  }, []);

  const debouncedFn = useCallback(
    (...args: Parameters<T>) => {
      const now = Date.now();
      lastArgsRef.current = args;

      // Handle leading edge
      if (leading && !hasLeadingCalledRef.current) {
        hasLeadingCalledRef.current = true;
        callbackRef.current(...args);
        lastArgsRef.current = null;
        lastCallTimeRef.current = now;
      }

      // Clear existing timeout
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      // Set up trailing edge timeout
      timeoutRef.current = setTimeout(() => {
        timeoutRef.current = null;
        if (maxWaitTimeoutRef.current) {
          clearTimeout(maxWaitTimeoutRef.current);
          maxWaitTimeoutRef.current = null;
        }
        if (!leading || lastArgsRef.current !== null) {
          invokeCallback();
        }
        hasLeadingCalledRef.current = false;
      }, delay);

      // Set up maxWait timeout if specified and not already set
      if (maxWait !== undefined && !maxWaitTimeoutRef.current) {
        maxWaitTimeoutRef.current = setTimeout(() => {
          maxWaitTimeoutRef.current = null;
          if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
            timeoutRef.current = null;
          }
          invokeCallback();
          hasLeadingCalledRef.current = false;
        }, maxWait);
      }
    },
    [delay, leading, maxWait, invokeCallback],
  );

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      cancel();
    };
  }, [cancel]);

  // Return function with methods attached
  const result = debouncedFn as IDebouncedFunction<T>;
  result.cancel = cancel;
  result.flush = flush;
  result.pending = pending;

  return result;
}

//#endregion useDebouncedCallback

//#region useThrottle

/**
 * Returns a throttled value that updates at most once per interval.
 *
 * @param value - The value to throttle
 * @param interval - Minimum interval between updates in milliseconds (default: 300)
 * @returns The throttled value
 *
 * @example
 * const [scrollY, setScrollY] = useState(0);
 * const throttledScrollY = useThrottle(scrollY, 100);
 *
 * // throttledScrollY updates at most every 100ms
 */
export function useThrottle<T>(value: T, interval: number = 300): T {
  const [throttledValue, setThrottledValue] = useState<T>(value);
  const lastUpdatedRef = useRef<number>(Date.now());
  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  useEffect(() => {
    const now = Date.now();
    const elapsed = now - lastUpdatedRef.current;

    if (elapsed >= interval) {
      // Enough time has passed, update immediately
      lastUpdatedRef.current = now;
      setThrottledValue(value);
    } else {
      // Schedule update for remaining time
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      timeoutRef.current = setTimeout(() => {
        lastUpdatedRef.current = Date.now();
        setThrottledValue(value);
      }, interval - elapsed);
    }

    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, [value, interval]);

  return throttledValue;
}

//#endregion useThrottle

//#region useThrottledCallback

/**
 * Returns a memoized throttled version of the callback function.
 * The throttled function is invoked at most once per interval.
 *
 * @param callback - The function to throttle
 * @param options - Throttle options
 * @returns Throttled function with cancel method
 *
 * @example
 * const throttledScroll = useThrottledCallback(
 *   (scrollOffset: number) => updateHeader(scrollOffset),
 *   { interval: 100 }
 * );
 *
 * // In scroll handler
 * <ScrollView onScroll={(e) => throttledScroll(e.nativeEvent.contentOffset.y)} />
 */
export function useThrottledCallback<T extends (...args: never[]) => unknown>(
  callback: T,
  options: IThrottleOptions = {},
): IThrottledFunction<T> {
  const { interval = 300, leading = true, trailing = true } = options;

  const callbackRef = useRef(callback);
  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const lastArgsRef = useRef<Parameters<T> | null>(null);
  const lastCallTimeRef = useRef<number>(0);

  // Keep callback ref updated
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  const cancel = useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
    lastArgsRef.current = null;
  }, []);

  const throttledFn = useCallback(
    (...args: Parameters<T>) => {
      const now = Date.now();
      const elapsed = now - lastCallTimeRef.current;

      lastArgsRef.current = args;

      const invokeTrailing = () => {
        if (trailing && lastArgsRef.current !== null) {
          lastCallTimeRef.current = Date.now();
          callbackRef.current(...lastArgsRef.current);
          lastArgsRef.current = null;
        }
        timeoutRef.current = null;
      };

      if (elapsed >= interval) {
        // Enough time has passed
        if (timeoutRef.current) {
          clearTimeout(timeoutRef.current);
          timeoutRef.current = null;
        }

        if (leading) {
          lastCallTimeRef.current = now;
          callbackRef.current(...args);
          lastArgsRef.current = null;
        } else if (trailing) {
          // Schedule trailing call
          timeoutRef.current = setTimeout(invokeTrailing, interval);
        }
      } else if (!timeoutRef.current && trailing) {
        // Schedule trailing call for remaining time
        const remaining = interval - elapsed;
        timeoutRef.current = setTimeout(invokeTrailing, remaining);
      }
    },
    [interval, leading, trailing],
  );

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      cancel();
    };
  }, [cancel]);

  // Return function with cancel method attached
  const result = throttledFn as IThrottledFunction<T>;
  result.cancel = cancel;

  return result;
}

//#endregion useThrottledCallback
```

## Index Export

```typescript
// apps/v2/src/hooks/useDebounce/index.ts

export {
  useDebounce,
  useDebouncedCallback,
  useThrottle,
  useThrottledCallback,
} from "./useDebounce";
```

## Acceptance Criteria

- [ ] `useDebounce` returns debounced value after delay of inactivity
- [ ] `useDebouncedCallback` returns memoized function with `cancel`, `flush`, `pending` methods
- [ ] `useThrottle` returns value that updates at most once per interval
- [ ] `useThrottledCallback` returns memoized function with `cancel` method
- [ ] Supports `leading` option for immediate first execution
- [ ] Supports `trailing` option for execution after interval
- [ ] Supports `maxWait` option to force execution after maximum delay
- [ ] Properly cleans up timers on unmount
- [ ] All types use `I` prefix naming convention
- [ ] No external dependencies (lodash, throttle-debounce)
- [ ] TypeScript strict mode passes
- [ ] No `any` types

## Testing

```typescript
// apps/v2/src/hooks/useDebounce/useDebounce.spec.tsx

import { renderHook, act } from "@testing-library/react-native";

import {
  useDebounce,
  useDebouncedCallback,
  useThrottle,
  useThrottledCallback,
} from "./useDebounce";

//#region useDebounce Tests

describe("useDebounce", () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it("returns initial value immediately", () => {
    const { result } = renderHook(() => useDebounce("initial", 500));

    expect(result.current).toBe("initial");
  });

  it("debounces value changes", () => {
    const { result, rerender } = renderHook(
      ({ value }) => useDebounce(value, 500),
      { initialProps: { value: "initial" } },
    );

    expect(result.current).toBe("initial");

    rerender({ value: "changed" });
    expect(result.current).toBe("initial");

    act(() => {
      jest.advanceTimersByTime(300);
    });
    expect(result.current).toBe("initial");

    act(() => {
      jest.advanceTimersByTime(200);
    });
    expect(result.current).toBe("changed");
  });

  it("resets timer on rapid value changes", () => {
    const { result, rerender } = renderHook(
      ({ value }) => useDebounce(value, 500),
      { initialProps: { value: "a" } },
    );

    rerender({ value: "b" });
    act(() => {
      jest.advanceTimersByTime(300);
    });

    rerender({ value: "c" });
    act(() => {
      jest.advanceTimersByTime(300);
    });

    expect(result.current).toBe("a");

    act(() => {
      jest.advanceTimersByTime(200);
    });
    expect(result.current).toBe("c");
  });

  it("uses default delay of 300ms", () => {
    const { result, rerender } = renderHook(({ value }) => useDebounce(value), {
      initialProps: { value: "initial" },
    });

    rerender({ value: "changed" });

    act(() => {
      jest.advanceTimersByTime(299);
    });
    expect(result.current).toBe("initial");

    act(() => {
      jest.advanceTimersByTime(1);
    });
    expect(result.current).toBe("changed");
  });
});

//#endregion useDebounce Tests

//#region useDebouncedCallback Tests

describe("useDebouncedCallback", () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it("debounces callback execution", () => {
    const callback = jest.fn();
    const { result } = renderHook(() =>
      useDebouncedCallback(callback, { delay: 500 }),
    );

    act(() => {
      result.current("arg1");
      result.current("arg2");
      result.current("arg3");
    });

    expect(callback).not.toHaveBeenCalled();

    act(() => {
      jest.advanceTimersByTime(500);
    });

    expect(callback).toHaveBeenCalledTimes(1);
    expect(callback).toHaveBeenCalledWith("arg3");
  });

  it("supports leading option", () => {
    const callback = jest.fn();
    const { result } = renderHook(() =>
      useDebouncedCallback(callback, { delay: 500, leading: true }),
    );

    act(() => {
      result.current("first");
    });

    expect(callback).toHaveBeenCalledTimes(1);
    expect(callback).toHaveBeenCalledWith("first");

    act(() => {
      result.current("second");
      result.current("third");
    });

    // Still only 1 call (leading already fired)
    expect(callback).toHaveBeenCalledTimes(1);

    act(() => {
      jest.advanceTimersByTime(500);
    });

    // Trailing call with last args
    expect(callback).toHaveBeenCalledTimes(2);
    expect(callback).toHaveBeenLastCalledWith("third");
  });

  it("supports maxWait option", () => {
    const callback = jest.fn();
    const { result } = renderHook(() =>
      useDebouncedCallback(callback, { delay: 500, maxWait: 1000 }),
    );

    // Keep calling to reset debounce timer
    act(() => {
      result.current("call1");
    });

    act(() => {
      jest.advanceTimersByTime(400);
      result.current("call2");
    });

    act(() => {
      jest.advanceTimersByTime(400);
      result.current("call3");
    });

    // Still within maxWait, debounce keeps resetting
    expect(callback).not.toHaveBeenCalled();

    act(() => {
      jest.advanceTimersByTime(200);
    });

    // maxWait of 1000ms reached, should have been called
    expect(callback).toHaveBeenCalledTimes(1);
    expect(callback).toHaveBeenCalledWith("call3");
  });

  it("cancel prevents execution", () => {
    const callback = jest.fn();
    const { result } = renderHook(() =>
      useDebouncedCallback(callback, { delay: 500 }),
    );

    act(() => {
      result.current("arg");
    });

    act(() => {
      result.current.cancel();
      jest.advanceTimersByTime(500);
    });

    expect(callback).not.toHaveBeenCalled();
  });

  it("flush executes immediately", () => {
    const callback = jest.fn();
    const { result } = renderHook(() =>
      useDebouncedCallback(callback, { delay: 500 }),
    );

    act(() => {
      result.current("arg");
    });

    expect(callback).not.toHaveBeenCalled();

    act(() => {
      result.current.flush();
    });

    expect(callback).toHaveBeenCalledTimes(1);
    expect(callback).toHaveBeenCalledWith("arg");
  });

  it("pending returns correct state", () => {
    const callback = jest.fn();
    const { result } = renderHook(() =>
      useDebouncedCallback(callback, { delay: 500 }),
    );

    expect(result.current.pending()).toBe(false);

    act(() => {
      result.current("arg");
    });

    expect(result.current.pending()).toBe(true);

    act(() => {
      jest.advanceTimersByTime(500);
    });

    expect(result.current.pending()).toBe(false);
  });

  it("cleans up on unmount", () => {
    const callback = jest.fn();
    const { result, unmount } = renderHook(() =>
      useDebouncedCallback(callback, { delay: 500 }),
    );

    act(() => {
      result.current("arg");
    });

    unmount();

    act(() => {
      jest.advanceTimersByTime(500);
    });

    expect(callback).not.toHaveBeenCalled();
  });
});

//#endregion useDebouncedCallback Tests

//#region useThrottle Tests

describe("useThrottle", () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it("returns initial value immediately", () => {
    const { result } = renderHook(() => useThrottle("initial", 500));

    expect(result.current).toBe("initial");
  });

  it("throttles rapid value changes", () => {
    const { result, rerender } = renderHook(
      ({ value }) => useThrottle(value, 500),
      { initialProps: { value: 0 } },
    );

    expect(result.current).toBe(0);

    // Rapid changes within throttle interval
    rerender({ value: 1 });
    rerender({ value: 2 });
    rerender({ value: 3 });

    // First change goes through immediately (leading edge)
    expect(result.current).toBe(1);

    act(() => {
      jest.advanceTimersByTime(500);
    });

    // After interval, trailing value is applied
    expect(result.current).toBe(3);
  });

  it("allows updates after interval has passed", () => {
    const { result, rerender } = renderHook(
      ({ value }) => useThrottle(value, 500),
      { initialProps: { value: "a" } },
    );

    rerender({ value: "b" });
    expect(result.current).toBe("b");

    act(() => {
      jest.advanceTimersByTime(500);
    });

    rerender({ value: "c" });
    expect(result.current).toBe("c");
  });
});

//#endregion useThrottle Tests

//#region useThrottledCallback Tests

describe("useThrottledCallback", () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it("throttles callback execution", () => {
    const callback = jest.fn();
    const { result } = renderHook(() =>
      useThrottledCallback(callback, { interval: 500 }),
    );

    act(() => {
      result.current("call1");
    });

    // Leading call executes immediately
    expect(callback).toHaveBeenCalledTimes(1);
    expect(callback).toHaveBeenCalledWith("call1");

    act(() => {
      result.current("call2");
      result.current("call3");
    });

    // Still throttled, no additional calls yet
    expect(callback).toHaveBeenCalledTimes(1);

    act(() => {
      jest.advanceTimersByTime(500);
    });

    // Trailing call with last args
    expect(callback).toHaveBeenCalledTimes(2);
    expect(callback).toHaveBeenLastCalledWith("call3");
  });

  it("respects leading: false option", () => {
    const callback = jest.fn();
    const { result } = renderHook(() =>
      useThrottledCallback(callback, { interval: 500, leading: false }),
    );

    act(() => {
      result.current("call1");
    });

    // No immediate call
    expect(callback).not.toHaveBeenCalled();

    act(() => {
      jest.advanceTimersByTime(500);
    });

    // Called on trailing edge
    expect(callback).toHaveBeenCalledTimes(1);
    expect(callback).toHaveBeenCalledWith("call1");
  });

  it("respects trailing: false option", () => {
    const callback = jest.fn();
    const { result } = renderHook(() =>
      useThrottledCallback(callback, { interval: 500, trailing: false }),
    );

    act(() => {
      result.current("call1");
    });

    expect(callback).toHaveBeenCalledTimes(1);

    act(() => {
      result.current("call2");
      jest.advanceTimersByTime(500);
    });

    // No trailing call
    expect(callback).toHaveBeenCalledTimes(1);

    act(() => {
      result.current("call3");
    });

    // New leading call after interval
    expect(callback).toHaveBeenCalledTimes(2);
    expect(callback).toHaveBeenLastCalledWith("call3");
  });

  it("cancel prevents pending trailing call", () => {
    const callback = jest.fn();
    const { result } = renderHook(() =>
      useThrottledCallback(callback, { interval: 500 }),
    );

    act(() => {
      result.current("call1");
      result.current("call2");
    });

    expect(callback).toHaveBeenCalledTimes(1);

    act(() => {
      result.current.cancel();
      jest.advanceTimersByTime(500);
    });

    // Trailing call was cancelled
    expect(callback).toHaveBeenCalledTimes(1);
  });

  it("cleans up on unmount", () => {
    const callback = jest.fn();
    const { result, unmount } = renderHook(() =>
      useThrottledCallback(callback, { interval: 500 }),
    );

    act(() => {
      result.current("call1");
      result.current("call2");
    });

    expect(callback).toHaveBeenCalledTimes(1);

    unmount();

    act(() => {
      jest.advanceTimersByTime(500);
    });

    // Trailing call was cleaned up
    expect(callback).toHaveBeenCalledTimes(1);
  });
});

//#endregion useThrottledCallback Tests
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- useDebounce
```
