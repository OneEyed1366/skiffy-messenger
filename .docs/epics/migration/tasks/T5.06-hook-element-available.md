# T5.06: useElementAvailable Hook

## Metadata

| Field        | Value      |
| ------------ | ---------- |
| **ID**       | T5.06      |
| **Layer**    | L5 - Hooks |
| **Status**   | pending    |
| **Priority** | low        |
| **Estimate** | 1h         |
| **Parallel** | true       |
| **Assignee** | -          |
| **Created**  | 2026-01-04 |
| **Updated**  | 2026-01-04 |

## Dependencies

| Task ID | Name          |
| ------- | ------------- |
| T0.15   | types-utility |

## Blocks

| Task ID | Name |
| ------- | ---- |
| -       | -    |

## Description

Migrate `useElementAvailable` hook from Mattermost. This hook polls for DOM element existence by ID using `setInterval`. Used by `useMeasurePunchouts` for tour/spotlight features.

**Web-Only Pattern**: This hook relies on `document.getElementById()` which is not available in React Native. In RN, component availability is managed declaratively through React's render lifecycle and refs â€” elements exist when rendered, don't exist when not rendered.

## Source Files

- `vendor/desktop/webapp/platform/components/src/common/hooks/useElementAvailable.ts` (lines 1-35)

### Source Analysis

The original implementation:

- **Polling**: Uses `setInterval` to check if all elements exist every N ms (default 250ms)
- **DOM API**: Relies on `document.getElementById()`
- **Use case**: Wait for DOM elements before measuring positions (tour spotlights)
- **Consumer**: `useMeasurePunchouts` hook for tour punchout overlays

Key characteristics:
| Aspect | Implementation |
|--------|----------------|
| Strategy | Polling via `setInterval` |
| Default interval | 250ms |
| Termination | Stops polling when all elements found |
| Return value | `boolean` (true when all available) |

## Migration Strategy

**Option A: Web-Only Export** (Recommended for Tauri desktop)

Export this hook only for web/desktop targets. Mark as web-only in the codebase.

**Option B: Skip Migration**

For mobile-first RN apps, this pattern is unnecessary. React Native manages element lifecycle through:

1. Conditional rendering (`{show && <Component />}`)
2. `ref` callbacks (called when mounted/unmounted)
3. `onLayout` events (element measured after render)

## React Native Alternatives

### Pattern 1: Ref Callback (Element Mount Detection)

```typescript
// RN: Detect when element is mounted
function useMounted() {
  const [mounted, setMounted] = useState(false);
  const ref = useCallback((node: View | null) => {
    setMounted(node !== null);
  }, []);
  return { ref, mounted };
}
```

### Pattern 2: onLayout (Element Measured)

```typescript
// RN: Detect when element is laid out and measurable
function useLayoutReady() {
  const [ready, setReady] = useState(false);
  const onLayout = useCallback(() => setReady(true), []);
  return { onLayout, ready };
}
```

### Pattern 3: Context-Based Readiness

```typescript
// RN: Multiple elements ready (declarative approach)
const TourContext = createContext<{
  registerElement: (id: string) => void;
  unregisterElement: (id: string) => void;
  allReady: boolean;
}>({ registerElement: () => {}, unregisterElement: () => {}, allReady: false });
```

## Migration Target

- **Target File**: `apps/v2/src/hooks/useElementAvailable/useElementAvailable.ts`
- **Index Export**: `apps/v2/src/hooks/useElementAvailable/index.ts`
- **Platform**: Web-only (Tauri desktop)

## Implementation

```typescript
// apps/v2/src/hooks/useElementAvailable/useElementAvailable.ts

/**
 * Hook that waits for DOM elements to exist by ID.
 * Migrated from: vendor/desktop/webapp/platform/components/src/common/hooks/useElementAvailable.ts
 *
 * @platform web-only - Uses document.getElementById(), not available in React Native.
 * For RN, use ref callbacks or onLayout events instead.
 */

import { useEffect, useRef, useState } from "react";

//#region Types

type IUseElementAvailableOptions = {
  /**
   * Polling interval in milliseconds.
   * @default 250
   */
  intervalMs?: number;
};

//#endregion Types

//#region Hook

/**
 * Polls for DOM elements by ID until all are available.
 *
 * @param elementIds - Array of element IDs to wait for
 * @param options - Configuration options
 * @returns `true` when all elements exist in the DOM
 *
 * @platform web - Not available in React Native
 *
 * @example
 * const ready = useElementAvailable(['header', 'sidebar']);
 * if (ready) {
 *   // Safe to measure elements
 * }
 */
export function useElementAvailable(
  elementIds: string[],
  options: IUseElementAvailableOptions = {},
): boolean {
  const { intervalMs = 250 } = options;
  const intervalRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const [available, setAvailable] = useState(false);

  useEffect(() => {
    // Skip if already available or no elements to check
    if (available || elementIds.length === 0) {
      return;
    }

    // Check immediately before starting interval
    const checkElements = (): boolean => {
      return elementIds.every((id) => document.getElementById(id) !== null);
    };

    if (checkElements()) {
      setAvailable(true);
      return;
    }

    // Start polling
    intervalRef.current = setInterval(() => {
      if (checkElements()) {
        setAvailable(true);
        if (intervalRef.current) {
          clearInterval(intervalRef.current);
          intervalRef.current = null;
        }
      }
    }, intervalMs);

    // Cleanup on unmount
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    };
  }, [elementIds, intervalMs, available]);

  return available;
}

//#endregion Hook
```

## Index Export

```typescript
// apps/v2/src/hooks/useElementAvailable/index.ts

export { useElementAvailable } from "./useElementAvailable";
```

## Acceptance Criteria

- [ ] Hook polls for elements using `setInterval`
- [ ] Returns `true` when all elements exist
- [ ] Cleans up interval on unmount
- [ ] Checks immediately before starting interval (optimization)
- [ ] All types use `I` prefix naming convention
- [ ] TypeScript strict mode passes
- [ ] No `any` types
- [ ] File header documents web-only limitation
- [ ] JSDoc includes `@platform web` tag

## Testing

```typescript
// apps/v2/src/hooks/useElementAvailable/useElementAvailable.spec.tsx

/**
 * @jest-environment jsdom
 */

import { renderHook, act, waitFor } from "@testing-library/react-native";

import { useElementAvailable } from "./useElementAvailable";

//#region Test Setup

beforeEach(() => {
  document.body.innerHTML = "";
  jest.useFakeTimers();
});

afterEach(() => {
  jest.useRealTimers();
});

//#endregion Test Setup

//#region Hook Tests

describe("useElementAvailable", () => {
  it("returns false initially when element does not exist", () => {
    const { result } = renderHook(() => useElementAvailable(["test-element"]));

    expect(result.current).toBe(false);
  });

  it("returns true immediately when element already exists", () => {
    const div = document.createElement("div");
    div.id = "existing-element";
    document.body.appendChild(div);

    const { result } = renderHook(() =>
      useElementAvailable(["existing-element"]),
    );

    expect(result.current).toBe(true);
  });

  it("returns true when element becomes available", async () => {
    const { result } = renderHook(() =>
      useElementAvailable(["delayed-element"], { intervalMs: 100 }),
    );

    expect(result.current).toBe(false);

    // Add element after a delay
    act(() => {
      const div = document.createElement("div");
      div.id = "delayed-element";
      document.body.appendChild(div);
      jest.advanceTimersByTime(100);
    });

    await waitFor(() => {
      expect(result.current).toBe(true);
    });
  });

  it("waits for all elements when multiple IDs provided", async () => {
    const { result } = renderHook(() =>
      useElementAvailable(["element-a", "element-b"], { intervalMs: 100 }),
    );

    expect(result.current).toBe(false);

    // Add only first element
    act(() => {
      const divA = document.createElement("div");
      divA.id = "element-a";
      document.body.appendChild(divA);
      jest.advanceTimersByTime(100);
    });

    expect(result.current).toBe(false);

    // Add second element
    act(() => {
      const divB = document.createElement("div");
      divB.id = "element-b";
      document.body.appendChild(divB);
      jest.advanceTimersByTime(100);
    });

    await waitFor(() => {
      expect(result.current).toBe(true);
    });
  });

  it("returns true immediately for empty element array", () => {
    const { result } = renderHook(() => useElementAvailable([]));

    expect(result.current).toBe(false);
  });

  it("stops polling after elements are found", async () => {
    const clearIntervalSpy = jest.spyOn(global, "clearInterval");

    const { result } = renderHook(() =>
      useElementAvailable(["poll-test"], { intervalMs: 100 }),
    );

    act(() => {
      const div = document.createElement("div");
      div.id = "poll-test";
      document.body.appendChild(div);
      jest.advanceTimersByTime(100);
    });

    await waitFor(() => {
      expect(result.current).toBe(true);
    });

    expect(clearIntervalSpy).toHaveBeenCalled();
  });

  it("cleans up interval on unmount", () => {
    const clearIntervalSpy = jest.spyOn(global, "clearInterval");

    const { unmount } = renderHook(() =>
      useElementAvailable(["unmount-test"], { intervalMs: 100 }),
    );

    unmount();

    expect(clearIntervalSpy).toHaveBeenCalled();
  });
});

//#endregion Hook Tests
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- useElementAvailable
```

## Notes

### React Native Alternative Pattern

If tour/spotlight functionality is needed in RN, implement a context-based solution:

```typescript
// Example: TourSpotlightContext for RN
type ITourElement = {
  id: string;
  measure: () => Promise<{ x: number; y: number; width: number; height: number }>;
};

const TourContext = createContext<{
  elements: Map<string, ITourElement>;
  register: (id: string, ref: RefObject<View>) => void;
  unregister: (id: string) => void;
}>(null!);

// Usage in components:
function SpotlightTarget({ id, children }) {
  const ref = useRef<View>(null);
  const { register, unregister } = useTourContext();

  useEffect(() => {
    register(id, ref);
    return () => unregister(id);
  }, [id]);

  return <View ref={ref}>{children}</View>;
}
```

This declarative approach is more idiomatic for React Native and avoids polling.
