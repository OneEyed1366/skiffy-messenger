# T5.14: useScrollPosition Hook

## Metadata

| Field        | Value      |
| ------------ | ---------- |
| **ID**       | T5.14      |
| **Layer**    | L5 - Hooks |
| **Status**   | pending    |
| **Priority** | medium     |
| **Estimate** | 1.5h       |
| **Parallel** | true       |
| **Assignee** | -          |
| **Created**  | 2026-01-06 |
| **Updated**  | 2026-01-06 |

## Dependencies

| Task ID | Name          |
| ------- | ------------- |
| T5.10   | hook-debounce |

## Blocks

| Task ID | Name                  |
| ------- | --------------------- |
| T10.\*  | Header components     |
| T11.\*  | Infinite scroll lists |

## Description

Track scroll position of window or element. Supports throttling for performance.

**Note:** Not found in vendor codebase - created from scratch based on common patterns.

## Migration Target

- **Target File**: `apps/v2/src/hooks/useScrollPosition/useScrollPosition.ts`
- **Target File (RN)**: `apps/v2/src/hooks/useScrollPosition/useScrollPosition.native.ts`
- **Index Export**: `apps/v2/src/hooks/useScrollPosition/index.ts`

## Implementation (Web)

```typescript
// apps/v2/src/hooks/useScrollPosition/useScrollPosition.ts

/**
 * Scroll position tracking hook
 * @platform web
 */

import {
  useState,
  useEffect,
  useCallback,
  useRef,
  type RefObject,
} from "react";

//#region Types

type IScrollPosition = {
  x: number;
  y: number;
};

type IScrollDirection = "up" | "down" | "left" | "right" | null;

type IScrollPositionResult = {
  /** Current scroll position */
  position: IScrollPosition;
  /** Current scroll direction */
  direction: IScrollDirection;
  /** Whether currently scrolling */
  isScrolling: boolean;
};

type IScrollPositionOptions = {
  /** Throttle interval in ms (default: 100) */
  throttleMs?: number;
  /** Element ref to track (default: window) */
  elementRef?: RefObject<HTMLElement>;
};

//#endregion Types

//#region Hook

/**
 * Track scroll position with direction detection
 *
 * @param options - Configuration options
 * @returns Current scroll position, direction, and scrolling state
 *
 * @example
 * // Track window scroll
 * const { position, direction } = useScrollPosition();
 *
 * // Hide header on scroll down
 * const showHeader = direction !== 'down' || position.y < 100;
 *
 * @example
 * // Track element scroll
 * const scrollRef = useRef<HTMLDivElement>(null);
 * const { position } = useScrollPosition({ elementRef: scrollRef });
 */
export function useScrollPosition(
  options: IScrollPositionOptions = {},
): IScrollPositionResult {
  const { throttleMs = 100, elementRef } = options;

  const [position, setPosition] = useState<IScrollPosition>({ x: 0, y: 0 });
  const [direction, setDirection] = useState<IScrollDirection>(null);
  const [isScrolling, setIsScrolling] = useState(false);

  const prevPositionRef = useRef<IScrollPosition>({ x: 0, y: 0 });
  const scrollingTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(
    null,
  );
  const lastUpdateRef = useRef<number>(0);

  const updatePosition = useCallback(() => {
    const now = Date.now();
    if (now - lastUpdateRef.current < throttleMs) return;
    lastUpdateRef.current = now;

    const newX = elementRef?.current
      ? elementRef.current.scrollLeft
      : window.scrollX;
    const newY = elementRef?.current
      ? elementRef.current.scrollTop
      : window.scrollY;

    const newPosition = { x: newX, y: newY };
    const prevPosition = prevPositionRef.current;

    // Determine direction
    let newDirection: IScrollDirection = null;
    const deltaY = newY - prevPosition.y;
    const deltaX = newX - prevPosition.x;

    if (Math.abs(deltaY) > Math.abs(deltaX)) {
      newDirection = deltaY > 0 ? "down" : deltaY < 0 ? "up" : null;
    } else if (deltaX !== 0) {
      newDirection = deltaX > 0 ? "right" : "left";
    }

    prevPositionRef.current = newPosition;
    setPosition(newPosition);
    setDirection(newDirection);
    setIsScrolling(true);

    // Reset isScrolling after scroll ends
    if (scrollingTimeoutRef.current) {
      clearTimeout(scrollingTimeoutRef.current);
    }
    scrollingTimeoutRef.current = setTimeout(() => {
      setIsScrolling(false);
      setDirection(null);
    }, 150);
  }, [throttleMs, elementRef]);

  useEffect(() => {
    const target = elementRef?.current ?? window;
    target.addEventListener("scroll", updatePosition, { passive: true });

    return () => {
      target.removeEventListener("scroll", updatePosition);
      if (scrollingTimeoutRef.current) {
        clearTimeout(scrollingTimeoutRef.current);
      }
    };
  }, [updatePosition, elementRef]);

  return { position, direction, isScrolling };
}

//#endregion Hook
```

## Implementation (React Native)

```typescript
// apps/v2/src/hooks/useScrollPosition/useScrollPosition.native.ts

/**
 * Scroll position hook for React Native
 * Use with ScrollView/FlatList onScroll event
 *
 * @platform native
 */

import { useState, useCallback, useRef } from "react";
import type { NativeScrollEvent, NativeSyntheticEvent } from "react-native";

//#region Types

type IScrollPosition = {
  x: number;
  y: number;
};

type IScrollDirection = "up" | "down" | "left" | "right" | null;

type IScrollPositionResult = {
  /** Current scroll position */
  position: IScrollPosition;
  /** Current scroll direction */
  direction: IScrollDirection;
  /** onScroll handler to pass to ScrollView/FlatList */
  onScroll: (event: NativeSyntheticEvent<NativeScrollEvent>) => void;
  /** scrollEventThrottle value to pass to ScrollView/FlatList */
  scrollEventThrottle: number;
};

type IScrollPositionOptions = {
  /** Throttle interval in ms (default: 16 for 60fps) */
  throttleMs?: number;
};

//#endregion Types

//#region Hook

/**
 * Track scroll position in React Native ScrollView/FlatList
 *
 * @param options - Configuration options
 * @returns Position, direction, and scroll handler
 *
 * @example
 * const { position, direction, onScroll, scrollEventThrottle } = useScrollPosition();
 *
 * <ScrollView
 *   onScroll={onScroll}
 *   scrollEventThrottle={scrollEventThrottle}
 * >
 *   {content}
 * </ScrollView>
 *
 * @example
 * // Hide header on scroll down
 * const showHeader = direction !== 'down' || position.y < 100;
 */
export function useScrollPosition(
  options: IScrollPositionOptions = {},
): IScrollPositionResult {
  const { throttleMs = 16 } = options;

  const [position, setPosition] = useState<IScrollPosition>({ x: 0, y: 0 });
  const [direction, setDirection] = useState<IScrollDirection>(null);
  const prevPositionRef = useRef<IScrollPosition>({ x: 0, y: 0 });

  const onScroll = useCallback(
    (event: NativeSyntheticEvent<NativeScrollEvent>) => {
      const { contentOffset } = event.nativeEvent;
      const newPosition = { x: contentOffset.x, y: contentOffset.y };
      const prevPosition = prevPositionRef.current;

      // Determine direction
      const deltaY = newPosition.y - prevPosition.y;
      const deltaX = newPosition.x - prevPosition.x;

      let newDirection: IScrollDirection = null;
      if (Math.abs(deltaY) > Math.abs(deltaX)) {
        newDirection = deltaY > 0 ? "down" : deltaY < 0 ? "up" : null;
      } else if (deltaX !== 0) {
        newDirection = deltaX > 0 ? "right" : "left";
      }

      prevPositionRef.current = newPosition;
      setPosition(newPosition);
      setDirection(newDirection);
    },
    [],
  );

  return {
    position,
    direction,
    onScroll,
    scrollEventThrottle: throttleMs,
  };
}

//#endregion Hook
```

## Index Export

```typescript
// apps/v2/src/hooks/useScrollPosition/index.ts

export { useScrollPosition } from "./useScrollPosition";
```

## Acceptance Criteria

- [ ] Web version tracks window or element scroll
- [ ] RN version provides onScroll handler for ScrollView
- [ ] Detects scroll direction (up/down/left/right)
- [ ] Supports throttling for performance
- [ ] `isScrolling` state (web only)
- [ ] Returns `scrollEventThrottle` for RN
- [ ] Properly cleans up listeners
- [ ] All types use `I` prefix naming convention
- [ ] TypeScript strict mode passes
- [ ] No `any` types

## Testing (Web)

```typescript
// apps/v2/src/hooks/useScrollPosition/useScrollPosition.spec.ts

/**
 * @jest-environment jsdom
 */

import { renderHook, act } from "@testing-library/react-native";

import { useScrollPosition } from "./useScrollPosition";

describe("useScrollPosition (web)", () => {
  beforeEach(() => {
    jest.useFakeTimers();
    // Reset scroll position
    Object.defineProperty(window, "scrollX", { value: 0, writable: true });
    Object.defineProperty(window, "scrollY", { value: 0, writable: true });
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it("returns initial position of 0,0", () => {
    const { result } = renderHook(() => useScrollPosition());

    expect(result.current.position).toEqual({ x: 0, y: 0 });
    expect(result.current.direction).toBeNull();
    expect(result.current.isScrolling).toBe(false);
  });

  it("updates position on scroll", () => {
    const { result } = renderHook(() => useScrollPosition({ throttleMs: 0 }));

    act(() => {
      Object.defineProperty(window, "scrollY", { value: 100, writable: true });
      window.dispatchEvent(new Event("scroll"));
    });

    expect(result.current.position.y).toBe(100);
  });

  it("detects scroll direction down", () => {
    const { result } = renderHook(() => useScrollPosition({ throttleMs: 0 }));

    act(() => {
      Object.defineProperty(window, "scrollY", { value: 100, writable: true });
      window.dispatchEvent(new Event("scroll"));
    });

    expect(result.current.direction).toBe("down");
  });

  it("detects scroll direction up", () => {
    const { result } = renderHook(() => useScrollPosition({ throttleMs: 0 }));

    // Scroll down first
    act(() => {
      Object.defineProperty(window, "scrollY", { value: 100, writable: true });
      window.dispatchEvent(new Event("scroll"));
    });

    // Then scroll up
    act(() => {
      Object.defineProperty(window, "scrollY", { value: 50, writable: true });
      window.dispatchEvent(new Event("scroll"));
    });

    expect(result.current.direction).toBe("up");
  });

  it("sets isScrolling to true while scrolling", () => {
    const { result } = renderHook(() => useScrollPosition({ throttleMs: 0 }));

    act(() => {
      Object.defineProperty(window, "scrollY", { value: 100, writable: true });
      window.dispatchEvent(new Event("scroll"));
    });

    expect(result.current.isScrolling).toBe(true);
  });

  it("resets isScrolling after scroll stops", () => {
    const { result } = renderHook(() => useScrollPosition({ throttleMs: 0 }));

    act(() => {
      Object.defineProperty(window, "scrollY", { value: 100, writable: true });
      window.dispatchEvent(new Event("scroll"));
    });

    expect(result.current.isScrolling).toBe(true);

    act(() => {
      jest.advanceTimersByTime(200);
    });

    expect(result.current.isScrolling).toBe(false);
  });

  it("cleans up on unmount", () => {
    const removeEventListenerSpy = jest.spyOn(window, "removeEventListener");
    const { unmount } = renderHook(() => useScrollPosition());

    unmount();

    expect(removeEventListenerSpy).toHaveBeenCalledWith(
      "scroll",
      expect.any(Function),
    );
  });
});
```

## Testing (React Native)

```typescript
// apps/v2/src/hooks/useScrollPosition/useScrollPosition.native.spec.ts

import { renderHook, act } from "@testing-library/react-native";

import { useScrollPosition } from "./useScrollPosition.native";

describe("useScrollPosition (native)", () => {
  const createScrollEvent = (x: number, y: number) => ({
    nativeEvent: {
      contentOffset: { x, y },
    },
  });

  it("returns initial position of 0,0", () => {
    const { result } = renderHook(() => useScrollPosition());

    expect(result.current.position).toEqual({ x: 0, y: 0 });
    expect(result.current.direction).toBeNull();
  });

  it("returns onScroll handler", () => {
    const { result } = renderHook(() => useScrollPosition());

    expect(typeof result.current.onScroll).toBe("function");
  });

  it("returns scrollEventThrottle", () => {
    const { result } = renderHook(() => useScrollPosition());

    expect(result.current.scrollEventThrottle).toBe(16);
  });

  it("updates position on scroll", () => {
    const { result } = renderHook(() => useScrollPosition());

    act(() => {
      result.current.onScroll(createScrollEvent(0, 100) as any);
    });

    expect(result.current.position).toEqual({ x: 0, y: 100 });
  });

  it("detects scroll direction down", () => {
    const { result } = renderHook(() => useScrollPosition());

    act(() => {
      result.current.onScroll(createScrollEvent(0, 100) as any);
    });

    expect(result.current.direction).toBe("down");
  });

  it("detects scroll direction up", () => {
    const { result } = renderHook(() => useScrollPosition());

    act(() => {
      result.current.onScroll(createScrollEvent(0, 100) as any);
    });

    act(() => {
      result.current.onScroll(createScrollEvent(0, 50) as any);
    });

    expect(result.current.direction).toBe("up");
  });

  it("detects horizontal scroll direction", () => {
    const { result } = renderHook(() => useScrollPosition());

    act(() => {
      result.current.onScroll(createScrollEvent(100, 0) as any);
    });

    expect(result.current.direction).toBe("right");

    act(() => {
      result.current.onScroll(createScrollEvent(50, 0) as any);
    });

    expect(result.current.direction).toBe("left");
  });

  it("respects custom throttle", () => {
    const { result } = renderHook(() => useScrollPosition({ throttleMs: 32 }));

    expect(result.current.scrollEventThrottle).toBe(32);
  });
});
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- useScrollPosition
```
