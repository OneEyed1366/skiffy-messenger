# T5.04: ResizeObserver Hook

## Metadata

| Field        | Value      |
| ------------ | ---------- |
| **ID**       | T5.04      |
| **Layer**    | L5 - Hooks |
| **Status**   | pending    |
| **Priority** | medium     |
| **Estimate** | 2h         |
| **Parallel** | true       |
| **Assignee** | -          |
| **Created**  | 2026-01-04 |
| **Updated**  | 2026-01-04 |

## Dependencies

| Task ID | Name          |
| ------- | ------------- |
| T0.15   | types-utility |

## Blocks

| Task ID | Name                           |
| ------- | ------------------------------ |
| T10b.\* | Components with dynamic sizing |

## Platform Compatibility

| Platform | Supported | Notes                                    |
| -------- | --------- | ---------------------------------------- |
| Web      | Yes       | Full ResizeObserver API                  |
| Desktop  | Yes       | Tauri webview has ResizeObserver support |
| iOS      | No        | Native layout system, no ResizeObserver  |
| Android  | No        | Native layout system, no ResizeObserver  |

**Important**: This hook is **web/desktop only**. On native platforms (iOS/Android), React Native's `onLayout` prop should be used instead. The hook provides a no-op fallback for native to prevent runtime errors when code is shared.

## Description

Migrate ResizeObserver wrapper hook from Mattermost. The original implementation uses the native ResizeObserver API to track element dimension changes. Since ResizeObserver is a web API, this hook is only functional on web and Tauri desktop platforms.

For React Native mobile, use the built-in `onLayout` prop on View components instead.

## Source Files

- `vendor/desktop/webapp/platform/components/src/common/hooks/useFollowElementDimensions.ts` (lines 1-28)
- `vendor/desktop/webapp/channels/src/components/advanced_text_editor/formatting_bar/hooks.tsx` (lines 13-50)
- `vendor/desktop/webapp/channels/src/components/dynamic_virtualized_list/list_item_size_observer.ts` (lines 1-65)

### Source Analysis

The original implementations show several patterns:

| Pattern                      | Source File             | Purpose                                   |
| ---------------------------- | ----------------------- | ----------------------------------------- |
| `useFollowElementDimensions` | platform/components     | Track element by ID, returns DOMRect      |
| `useResponsiveFormattingBar` | formatting_bar/hooks    | Track ref element with debounce           |
| `ListItemSizeObserver`       | list_item_size_observer | Singleton shared observer for performance |

Key characteristics:

- Uses native `ResizeObserver` API
- Returns `DOMRectReadOnly` or derived dimensions
- Cleanup via `observer.unobserve()` or `observer.disconnect()`
- Some use debouncing for performance

## Migration Target

- **Target File**: `apps/v2/src/hooks/useResizeObserver/useResizeObserver.ts`
- **Index Export**: `apps/v2/src/hooks/useResizeObserver/index.ts`

## Implementation

```typescript
// apps/v2/src/hooks/useResizeObserver/useResizeObserver.ts

/**
 * ResizeObserver wrapper hook
 * Migrated from: vendor/desktop/webapp/platform/components/src/common/hooks/useFollowElementDimensions.ts
 *
 * Platform: Web/Desktop only (Tauri)
 * For React Native mobile, use View's onLayout prop instead.
 */

import { useEffect, useRef, useState } from "react";
import { Platform } from "react-native";

//#region Types

type IDimensions = {
  width: number;
  height: number;
  x: number;
  y: number;
};

type IResizeObserverOptions = {
  /** Debounce delay in ms (default: 0) */
  debounceMs?: number;
  /** Box model to observe (default: 'content-box') */
  box?: ResizeObserverBoxOptions;
};

type IResizeObserverResult<T extends Element> = {
  ref: React.RefObject<T>;
  dimensions: IDimensions;
};

//#endregion Types

//#region Constants

const DEFAULT_DIMENSIONS: IDimensions = {
  width: 0,
  height: 0,
  x: 0,
  y: 0,
};

const IS_WEB = Platform.OS === "web";

//#endregion Constants

//#region Hook

/**
 * Observes element resize events and returns current dimensions.
 *
 * **Platform Support**: Web and Tauri desktop only.
 * On native platforms (iOS/Android), returns default dimensions and a no-op ref.
 * Use View's `onLayout` prop for native dimension tracking.
 *
 * @param options - Configuration options
 * @returns Object with ref to attach and current dimensions
 *
 * @example
 * // Web/Desktop usage
 * function ResponsiveComponent() {
 *   const { ref, dimensions } = useResizeObserver<HTMLDivElement>();
 *
 *   return (
 *     <div ref={ref}>
 *       Width: {dimensions.width}, Height: {dimensions.height}
 *     </div>
 *   );
 * }
 *
 * @example
 * // Cross-platform pattern
 * function CrossPlatformComponent() {
 *   const { ref, dimensions } = useResizeObserver<View>();
 *   const [nativeDimensions, setNativeDimensions] = useState({ width: 0, height: 0 });
 *
 *   const handleLayout = (event: LayoutChangeEvent) => {
 *     const { width, height } = event.nativeEvent.layout;
 *     setNativeDimensions({ width, height });
 *   };
 *
 *   // Use Platform.select to choose dimensions source
 *   const finalDimensions = Platform.select({
 *     web: dimensions,
 *     default: nativeDimensions,
 *   });
 *
 *   return (
 *     <View ref={ref} onLayout={handleLayout}>
 *       <Text>Width: {finalDimensions.width}</Text>
 *     </View>
 *   );
 * }
 */
export function useResizeObserver<T extends Element = Element>(
  options: IResizeObserverOptions = {},
): IResizeObserverResult<T> {
  const { debounceMs = 0, box = "content-box" } = options;
  const ref = useRef<T>(null);
  const [dimensions, setDimensions] = useState<IDimensions>(DEFAULT_DIMENSIONS);
  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  useEffect(() => {
    // Early return for non-web platforms
    if (!IS_WEB) {
      return undefined;
    }

    const element = ref.current;
    if (!element) {
      return undefined;
    }

    const updateDimensions = (entry: ResizeObserverEntry) => {
      const contentRect = entry.contentRect;
      setDimensions({
        width: contentRect.width,
        height: contentRect.height,
        x: contentRect.x,
        y: contentRect.y,
      });
    };

    const handleResize = (entries: ResizeObserverEntry[]) => {
      if (entries.length === 0) {
        return;
      }

      const entry = entries[0];

      if (debounceMs > 0) {
        if (timeoutRef.current) {
          clearTimeout(timeoutRef.current);
        }
        timeoutRef.current = setTimeout(() => {
          updateDimensions(entry);
        }, debounceMs);
      } else {
        updateDimensions(entry);
      }
    };

    const observer = new ResizeObserver(handleResize);
    observer.observe(element, { box });

    return () => {
      observer.disconnect();
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, [debounceMs, box]);

  return { ref, dimensions };
}

//#endregion Hook

//#region Utility

/**
 * Observes an element by ID and returns its dimensions.
 * Useful when you don't have direct ref access to the element.
 *
 * **Platform Support**: Web and Tauri desktop only.
 *
 * @param elementId - DOM element ID to observe
 * @param options - Configuration options
 * @returns Current dimensions of the element
 *
 * @example
 * function SidebarTracker() {
 *   const sidebarDimensions = useElementDimensions('main-sidebar');
 *
 *   return <Text>Sidebar width: {sidebarDimensions.width}</Text>;
 * }
 */
export function useElementDimensions(
  elementId: string,
  options: IResizeObserverOptions = {},
): IDimensions {
  const { debounceMs = 0, box = "content-box" } = options;
  const [dimensions, setDimensions] = useState<IDimensions>(DEFAULT_DIMENSIONS);
  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  useEffect(() => {
    // Early return for non-web platforms
    if (!IS_WEB) {
      return undefined;
    }

    const element = document.getElementById(elementId);
    if (!element) {
      return undefined;
    }

    const updateDimensions = (entry: ResizeObserverEntry) => {
      const contentRect = entry.contentRect;
      setDimensions({
        width: contentRect.width,
        height: contentRect.height,
        x: contentRect.x,
        y: contentRect.y,
      });
    };

    const handleResize = (entries: ResizeObserverEntry[]) => {
      if (entries.length === 0) {
        return;
      }

      const entry = entries[0];

      if (debounceMs > 0) {
        if (timeoutRef.current) {
          clearTimeout(timeoutRef.current);
        }
        timeoutRef.current = setTimeout(() => {
          updateDimensions(entry);
        }, debounceMs);
      } else {
        updateDimensions(entry);
      }
    };

    const observer = new ResizeObserver(handleResize);
    observer.observe(element, { box });

    return () => {
      observer.disconnect();
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, [elementId, debounceMs, box]);

  return dimensions;
}

//#endregion Utility
```

## Index Export

```typescript
// apps/v2/src/hooks/useResizeObserver/index.ts

export { useResizeObserver, useElementDimensions } from "./useResizeObserver";
```

## Acceptance Criteria

- [ ] Hook uses native `ResizeObserver` API (no polyfills)
- [ ] Platform check returns no-op/defaults on native platforms
- [ ] Returns stable ref object for element attachment
- [ ] Returns `IDimensions` with width, height, x, y
- [ ] Supports optional debouncing for performance
- [ ] Supports box model option (content-box, border-box)
- [ ] `useElementDimensions` variant for ID-based lookup
- [ ] Proper cleanup on unmount (observer.disconnect)
- [ ] All types use `I` prefix naming convention
- [ ] TypeScript strict mode passes
- [ ] No `any` types
- [ ] JSDoc documents platform limitations

## Testing

```typescript
// apps/v2/src/hooks/useResizeObserver/useResizeObserver.spec.tsx

/**
 * @jest-environment jsdom
 */

import { renderHook, act } from "@testing-library/react-native";
import { Platform } from "react-native";

import { useResizeObserver, useElementDimensions } from "./useResizeObserver";

//#region Mocks

// Mock ResizeObserver
class MockResizeObserver {
  callback: ResizeObserverCallback;
  elements: Element[] = [];

  constructor(callback: ResizeObserverCallback) {
    this.callback = callback;
  }

  observe(element: Element) {
    this.elements.push(element);
  }

  unobserve(element: Element) {
    this.elements = this.elements.filter((el) => el !== element);
  }

  disconnect() {
    this.elements = [];
  }

  // Test helper to simulate resize
  simulateResize(width: number, height: number) {
    const entries: ResizeObserverEntry[] = this.elements.map((element) => ({
      target: element,
      contentRect: {
        width,
        height,
        x: 0,
        y: 0,
        top: 0,
        left: 0,
        bottom: height,
        right: width,
      } as DOMRectReadOnly,
      borderBoxSize: [
        { blockSize: height, inlineSize: width },
      ] as ResizeObserverSize[],
      contentBoxSize: [
        { blockSize: height, inlineSize: width },
      ] as ResizeObserverSize[],
      devicePixelContentBoxSize: [
        { blockSize: height, inlineSize: width },
      ] as ResizeObserverSize[],
    }));
    this.callback(entries, this);
  }
}

let mockObserverInstance: MockResizeObserver | null = null;

beforeAll(() => {
  (
    global as unknown as { ResizeObserver: typeof MockResizeObserver }
  ).ResizeObserver = class extends MockResizeObserver {
    constructor(callback: ResizeObserverCallback) {
      super(callback);
      mockObserverInstance = this;
    }
  };
});

beforeEach(() => {
  mockObserverInstance = null;
  jest.spyOn(Platform, "OS", "get").mockReturnValue("web");
});

afterEach(() => {
  jest.restoreAllMocks();
});

//#endregion Mocks

//#region useResizeObserver Tests

describe("useResizeObserver", () => {
  it("returns default dimensions initially", () => {
    const { result } = renderHook(() => useResizeObserver());

    expect(result.current.dimensions).toEqual({
      width: 0,
      height: 0,
      x: 0,
      y: 0,
    });
  });

  it("returns a ref object", () => {
    const { result } = renderHook(() => useResizeObserver());

    expect(result.current.ref).toBeDefined();
    expect(result.current.ref.current).toBeNull();
  });

  it("updates dimensions on resize", () => {
    const { result } = renderHook(() => useResizeObserver<HTMLDivElement>());

    // Simulate attaching ref to an element
    const mockElement = document.createElement("div");
    Object.defineProperty(result.current.ref, "current", {
      value: mockElement,
      writable: true,
    });

    // Re-render to trigger effect with attached ref
    const { result: result2 } = renderHook(() =>
      useResizeObserver<HTMLDivElement>(),
    );
    Object.defineProperty(result2.current.ref, "current", {
      value: mockElement,
      writable: true,
    });

    // Simulate resize via mock observer
    act(() => {
      mockObserverInstance?.simulateResize(300, 200);
    });

    expect(result2.current.dimensions.width).toBe(300);
    expect(result2.current.dimensions.height).toBe(200);
  });

  it("returns default dimensions on native platform", () => {
    jest.spyOn(Platform, "OS", "get").mockReturnValue("ios");

    const { result } = renderHook(() => useResizeObserver());

    expect(result.current.dimensions).toEqual({
      width: 0,
      height: 0,
      x: 0,
      y: 0,
    });
  });

  it("does not create observer on native platform", () => {
    jest.spyOn(Platform, "OS", "get").mockReturnValue("android");

    renderHook(() => useResizeObserver());

    expect(mockObserverInstance).toBeNull();
  });

  it("cleans up observer on unmount", () => {
    const { result, unmount } = renderHook(() =>
      useResizeObserver<HTMLDivElement>(),
    );

    const mockElement = document.createElement("div");
    Object.defineProperty(result.current.ref, "current", {
      value: mockElement,
      writable: true,
    });

    const disconnectSpy = jest.spyOn(
      MockResizeObserver.prototype,
      "disconnect",
    );

    unmount();

    expect(disconnectSpy).toHaveBeenCalled();
  });
});

//#endregion useResizeObserver Tests

//#region useElementDimensions Tests

describe("useElementDimensions", () => {
  beforeEach(() => {
    // Setup mock element in DOM
    const mockElement = document.createElement("div");
    mockElement.id = "test-element";
    document.body.appendChild(mockElement);
  });

  afterEach(() => {
    const element = document.getElementById("test-element");
    if (element) {
      element.remove();
    }
  });

  it("returns default dimensions initially", () => {
    const { result } = renderHook(() => useElementDimensions("test-element"));

    expect(result.current).toEqual({
      width: 0,
      height: 0,
      x: 0,
      y: 0,
    });
  });

  it("returns default dimensions for non-existent element", () => {
    const { result } = renderHook(() => useElementDimensions("non-existent"));

    expect(result.current).toEqual({
      width: 0,
      height: 0,
      x: 0,
      y: 0,
    });
  });

  it("updates dimensions on element resize", () => {
    const { result } = renderHook(() => useElementDimensions("test-element"));

    act(() => {
      mockObserverInstance?.simulateResize(400, 250);
    });

    expect(result.current.width).toBe(400);
    expect(result.current.height).toBe(250);
  });

  it("returns default dimensions on native platform", () => {
    jest.spyOn(Platform, "OS", "get").mockReturnValue("ios");

    const { result } = renderHook(() => useElementDimensions("test-element"));

    expect(result.current).toEqual({
      width: 0,
      height: 0,
      x: 0,
      y: 0,
    });
  });
});

//#endregion useElementDimensions Tests

//#region Debounce Tests

describe("debounce option", () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it("debounces dimension updates", () => {
    const { result } = renderHook(() =>
      useResizeObserver<HTMLDivElement>({ debounceMs: 100 }),
    );

    const mockElement = document.createElement("div");
    Object.defineProperty(result.current.ref, "current", {
      value: mockElement,
      writable: true,
    });

    // Re-render to attach observer
    const { result: result2 } = renderHook(() =>
      useResizeObserver<HTMLDivElement>({ debounceMs: 100 }),
    );
    Object.defineProperty(result2.current.ref, "current", {
      value: mockElement,
      writable: true,
    });

    // Simulate rapid resizes
    act(() => {
      mockObserverInstance?.simulateResize(100, 100);
      mockObserverInstance?.simulateResize(200, 200);
      mockObserverInstance?.simulateResize(300, 300);
    });

    // Dimensions should not update immediately
    expect(result2.current.dimensions.width).toBe(0);

    // Fast-forward debounce timer
    act(() => {
      jest.advanceTimersByTime(100);
    });

    // Should have final dimensions
    expect(result2.current.dimensions.width).toBe(300);
    expect(result2.current.dimensions.height).toBe(300);
  });
});

//#endregion Debounce Tests
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- useResizeObserver
```

## Native Alternative

For React Native mobile (iOS/Android), use the built-in `onLayout` prop:

```typescript
import { useState } from "react";
import { View, Text, LayoutChangeEvent } from "react-native";

function NativeResizeExample() {
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

  const handleLayout = (event: LayoutChangeEvent) => {
    const { width, height } = event.nativeEvent.layout;
    setDimensions({ width, height });
  };

  return (
    <View onLayout={handleLayout}>
      <Text>Width: {dimensions.width}, Height: {dimensions.height}</Text>
    </View>
  );
}
```

## Cross-Platform Pattern

Use `Platform.select` to choose the appropriate dimension source:

```typescript
import { useState } from "react";
import { Platform, View, LayoutChangeEvent } from "react-native";
import { useResizeObserver } from "@/hooks/useResizeObserver";

function CrossPlatformComponent() {
  const { ref, dimensions: webDimensions } = useResizeObserver<View>();
  const [nativeDimensions, setNativeDimensions] = useState({
    width: 0,
    height: 0,
  });

  const handleLayout = (event: LayoutChangeEvent) => {
    const { width, height } = event.nativeEvent.layout;
    setNativeDimensions({ width, height });
  };

  const dimensions = Platform.select({
    web: webDimensions,
    default: nativeDimensions,
  });

  return (
    <View ref={ref} onLayout={handleLayout}>
      <Text>Width: {dimensions?.width ?? 0}</Text>
    </View>
  );
}
```
