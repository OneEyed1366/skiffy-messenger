# T3.06: Storage Utilities

## Metadata

| Field        | Value               |
| ------------ | ------------------- |
| **ID**       | T3.06               |
| **Layer**    | L3 - Platform Utils |
| **Status**   | pending             |
| **Priority** | high                |
| **Estimate** | 2h                  |
| **Parallel** | true                |
| **Assignee** | -                   |
| **Created**  | 2026-01-07          |
| **Updated**  | 2026-01-07          |

## Dependencies

| Task ID | Name               |
| ------- | ------------------ |
| T3.01   | Platform Detection |

## Blocks

| Task ID | Name                 |
| ------- | -------------------- |
| T4.\*   | State management     |
| T10d.\* | Authentication flows |
| T10e.\* | User preferences     |

## Description

Migrate storage utilities from Mattermost's `stores/local_storage_store.ts` to React Native. Uses `@react-native-async-storage/async-storage` for general key-value storage and `expo-secure-store` for sensitive data like tokens and credentials.

**Storage Types:**

- **AsyncStorage**: General-purpose, unencrypted, larger capacity
- **SecureStore**: Encrypted, for sensitive data, size-limited (2048 bytes on iOS)

**Platform Considerations:**

- **iOS**: Keychain for SecureStore, NSUserDefaults for AsyncStorage
- **Android**: Keystore for SecureStore, SharedPreferences for AsyncStorage
- **Web**: localStorage fallback (not secure)

## Source Files

- `vendor/desktop/webapp/channels/src/stores/local_storage_store.ts`
- `@react-native-async-storage/async-storage` documentation
- `expo-secure-store` documentation

## Target File

`apps/v2/src/utils/storage.ts`

## Implementation

````typescript
// apps/v2/src/utils/storage.ts

/**
 * Storage utilities
 * Migrated from: vendor/desktop/webapp/channels/src/stores/local_storage_store.ts
 *
 * Provides cross-platform storage using AsyncStorage for general data
 * and SecureStore for sensitive data (tokens, credentials).
 */

import AsyncStorage from "@react-native-async-storage/async-storage";
import * as SecureStore from "expo-secure-store";
import { Platform } from "react-native";

//#region Types

export type IStorageKey = string;

export type IStorageOptions = {
  /** Prefix for all keys (useful for namespacing) */
  prefix?: string;
};

export type ISecureStoreOptions = {
  /** iOS: Keychain access group for sharing between apps */
  keychainAccessGroup?: string;
  /** iOS: Keychain accessibility level */
  keychainAccessible?: SecureStore.KeychainAccessibilityConstant;
  /** Android: Require device authentication to access */
  requireAuthentication?: boolean;
};

//#endregion

//#region Constants

/** Storage key prefix for app data */
export const STORAGE_PREFIX = "@retrievly:";

/** Secure storage key prefix */
export const SECURE_STORAGE_PREFIX = "@retrievly:secure:";

//#endregion

//#region General Storage (AsyncStorage)

/**
 * Get a value from general storage.
 *
 * @param key - Storage key
 * @returns Promise resolving to stored value or null if not found
 *
 * @example
 * ```typescript
 * const theme = await getItem("user_theme");
 * if (theme) {
 *   applyTheme(theme);
 * }
 * ```
 */
export async function getItem(key: IStorageKey): Promise<string | null> {
  try {
    const value = await AsyncStorage.getItem(`${STORAGE_PREFIX}${key}`);
    return value;
  } catch (error) {
    console.error(`Failed to get item "${key}":`, error);
    return null;
  }
}

/**
 * Store a value in general storage.
 *
 * @param key - Storage key
 * @param value - Value to store
 *
 * @example
 * ```typescript
 * await setItem("user_theme", "dark");
 * await setItem("last_channel_id", channelId);
 * ```
 */
export async function setItem(key: IStorageKey, value: string): Promise<void> {
  try {
    await AsyncStorage.setItem(`${STORAGE_PREFIX}${key}`, value);
  } catch (error) {
    console.error(`Failed to set item "${key}":`, error);
    throw error;
  }
}

/**
 * Remove a value from general storage.
 *
 * @param key - Storage key to remove
 *
 * @example
 * ```typescript
 * await removeItem("cached_data");
 * ```
 */
export async function removeItem(key: IStorageKey): Promise<void> {
  try {
    await AsyncStorage.removeItem(`${STORAGE_PREFIX}${key}`);
  } catch (error) {
    console.error(`Failed to remove item "${key}":`, error);
    throw error;
  }
}

/**
 * Get multiple values from general storage.
 *
 * @param keys - Array of storage keys
 * @returns Promise resolving to object with key-value pairs
 *
 * @example
 * ```typescript
 * const values = await getMultipleItems(["theme", "language", "notifications"]);
 * console.log(values.theme, values.language);
 * ```
 */
export async function getMultipleItems(
  keys: IStorageKey[],
): Promise<Record<string, string | null>> {
  try {
    const prefixedKeys = keys.map((key) => `${STORAGE_PREFIX}${key}`);
    const pairs = await AsyncStorage.multiGet(prefixedKeys);

    const result: Record<string, string | null> = {};
    pairs.forEach(([prefixedKey, value]) => {
      const key = prefixedKey.replace(STORAGE_PREFIX, "");
      result[key] = value;
    });

    return result;
  } catch (error) {
    console.error("Failed to get multiple items:", error);
    return {};
  }
}

/**
 * Store multiple values in general storage.
 *
 * @param items - Object with key-value pairs to store
 *
 * @example
 * ```typescript
 * await setMultipleItems({
 *   theme: "dark",
 *   language: "en",
 *   notifications: "true",
 * });
 * ```
 */
export async function setMultipleItems(
  items: Record<string, string>,
): Promise<void> {
  try {
    const pairs: [string, string][] = Object.entries(items).map(
      ([key, value]) => [`${STORAGE_PREFIX}${key}`, value],
    );
    await AsyncStorage.multiSet(pairs);
  } catch (error) {
    console.error("Failed to set multiple items:", error);
    throw error;
  }
}

/**
 * Clear all app data from general storage.
 *
 * Only removes keys with the app prefix, not all AsyncStorage data.
 *
 * @example
 * ```typescript
 * // On logout
 * await clear();
 * ```
 */
export async function clear(): Promise<void> {
  try {
    const allKeys = await AsyncStorage.getAllKeys();
    const appKeys = allKeys.filter((key) => key.startsWith(STORAGE_PREFIX));
    if (appKeys.length > 0) {
      await AsyncStorage.multiRemove(appKeys);
    }
  } catch (error) {
    console.error("Failed to clear storage:", error);
    throw error;
  }
}

/**
 * Get all keys stored by the app.
 *
 * @returns Promise resolving to array of storage keys (without prefix)
 */
export async function getAllKeys(): Promise<string[]> {
  try {
    const allKeys = await AsyncStorage.getAllKeys();
    return allKeys
      .filter((key) => key.startsWith(STORAGE_PREFIX))
      .map((key) => key.replace(STORAGE_PREFIX, ""));
  } catch (error) {
    console.error("Failed to get all keys:", error);
    return [];
  }
}

//#endregion

//#region Secure Storage (SecureStore)

/**
 * Check if SecureStore is available on this device.
 *
 * @returns Promise resolving to true if secure storage is available
 */
export async function isSecureStoreAvailable(): Promise<boolean> {
  try {
    return await SecureStore.isAvailableAsync();
  } catch {
    return false;
  }
}

/**
 * Get a value from secure storage.
 *
 * Use for sensitive data like tokens, passwords, API keys.
 *
 * @param key - Storage key
 * @param options - SecureStore options
 * @returns Promise resolving to stored value or null if not found
 *
 * @example
 * ```typescript
 * const token = await getSecureItem("auth_token");
 * if (token) {
 *   setAuthHeader(token);
 * }
 * ```
 */
export async function getSecureItem(
  key: IStorageKey,
  options?: ISecureStoreOptions,
): Promise<string | null> {
  try {
    // Web fallback - use localStorage (not truly secure)
    if (Platform.OS === "web") {
      console.warn("SecureStore not available on web, using localStorage");
      return localStorage.getItem(`${SECURE_STORAGE_PREFIX}${key}`);
    }

    const value = await SecureStore.getItemAsync(
      `${SECURE_STORAGE_PREFIX}${key}`,
      options,
    );
    return value;
  } catch (error) {
    console.error(`Failed to get secure item "${key}":`, error);
    return null;
  }
}

/**
 * Store a value in secure storage.
 *
 * Use for sensitive data like tokens, passwords, API keys.
 * Note: iOS Keychain has 2048 byte limit per item.
 *
 * @param key - Storage key
 * @param value - Value to store (max ~2KB on iOS)
 * @param options - SecureStore options
 *
 * @example
 * ```typescript
 * await setSecureItem("auth_token", response.token);
 * await setSecureItem("refresh_token", response.refreshToken);
 * ```
 */
export async function setSecureItem(
  key: IStorageKey,
  value: string,
  options?: ISecureStoreOptions,
): Promise<void> {
  try {
    // Web fallback - use localStorage (not truly secure)
    if (Platform.OS === "web") {
      console.warn("SecureStore not available on web, using localStorage");
      localStorage.setItem(`${SECURE_STORAGE_PREFIX}${key}`, value);
      return;
    }

    await SecureStore.setItemAsync(
      `${SECURE_STORAGE_PREFIX}${key}`,
      value,
      options,
    );
  } catch (error) {
    console.error(`Failed to set secure item "${key}":`, error);
    throw error;
  }
}

/**
 * Remove a value from secure storage.
 *
 * @param key - Storage key to remove
 * @param options - SecureStore options
 *
 * @example
 * ```typescript
 * // On logout
 * await removeSecureItem("auth_token");
 * await removeSecureItem("refresh_token");
 * ```
 */
export async function removeSecureItem(
  key: IStorageKey,
  options?: ISecureStoreOptions,
): Promise<void> {
  try {
    // Web fallback
    if (Platform.OS === "web") {
      localStorage.removeItem(`${SECURE_STORAGE_PREFIX}${key}`);
      return;
    }

    await SecureStore.deleteItemAsync(
      `${SECURE_STORAGE_PREFIX}${key}`,
      options,
    );
  } catch (error) {
    console.error(`Failed to remove secure item "${key}":`, error);
    throw error;
  }
}

//#endregion

//#region JSON Helpers

/**
 * Get and parse JSON from general storage.
 *
 * @param key - Storage key
 * @returns Promise resolving to parsed object or null
 *
 * @example
 * ```typescript
 * const settings = await getJsonItem<IUserSettings>("user_settings");
 * if (settings) {
 *   applySettings(settings);
 * }
 * ```
 */
export async function getJsonItem<T>(key: IStorageKey): Promise<T | null> {
  try {
    const value = await getItem(key);
    if (value === null) {
      return null;
    }
    return JSON.parse(value) as T;
  } catch (error) {
    console.error(`Failed to parse JSON for "${key}":`, error);
    return null;
  }
}

/**
 * Stringify and store JSON in general storage.
 *
 * @param key - Storage key
 * @param value - Object to store
 *
 * @example
 * ```typescript
 * await setJsonItem("user_settings", {
 *   theme: "dark",
 *   notifications: true,
 * });
 * ```
 */
export async function setJsonItem<T>(
  key: IStorageKey,
  value: T,
): Promise<void> {
  try {
    const jsonString = JSON.stringify(value);
    await setItem(key, jsonString);
  } catch (error) {
    console.error(`Failed to stringify JSON for "${key}":`, error);
    throw error;
  }
}

//#endregion
````

## Index Export

```typescript
// apps/v2/src/utils/index.ts

export {
  // General Storage
  getItem,
  setItem,
  removeItem,
  getMultipleItems,
  setMultipleItems,
  clear,
  getAllKeys,
  // Secure Storage
  isSecureStoreAvailable,
  getSecureItem,
  setSecureItem,
  removeSecureItem,
  // JSON Helpers
  getJsonItem,
  setJsonItem,
  // Constants
  STORAGE_PREFIX,
  SECURE_STORAGE_PREFIX,
} from "./storage";

export type {
  IStorageKey,
  IStorageOptions,
  ISecureStoreOptions,
} from "./storage";
```

## Platform Considerations

| Feature      | iOS                  | Android              | Web                     |
| ------------ | -------------------- | -------------------- | ----------------------- |
| AsyncStorage | NSUserDefaults       | SharedPreferences    | localStorage            |
| SecureStore  | Keychain             | Keystore             | localStorage (fallback) |
| Encryption   | AES-256 (Keychain)   | AES-256 (Keystore)   | None                    |
| Size limit   | ~2KB per secure item | ~2KB per secure item | ~5MB total              |
| Persistence  | Survives reinstall   | Cleared on uninstall | Cleared on clear data   |

### iOS Specifics

- Keychain items persist across app reinstalls (unless `keychainAccessible` restricts)
- Can share keychain items between apps using access groups
- Hardware-backed encryption on devices with Secure Enclave

### Android Specifics

- Keystore requires device to have secure lock screen for some options
- Data cleared on app uninstall unless backed up
- `requireAuthentication` prompts biometric on each access

### Web Specifics

- **SecureStore not available** - falls back to localStorage with warning
- localStorage has ~5MB limit per origin
- Cleared when user clears browser data

## Acceptance Criteria

- [ ] Uses `@react-native-async-storage/async-storage` for general storage
- [ ] Uses `expo-secure-store` for sensitive data
- [ ] `getItem()` returns string or null
- [ ] `setItem()` stores string values
- [ ] `removeItem()` deletes stored values
- [ ] `getSecureItem()` retrieves from encrypted storage
- [ ] `setSecureItem()` stores in encrypted storage
- [ ] `removeSecureItem()` deletes from encrypted storage
- [ ] `clear()` removes all app data (not other apps' data)
- [ ] Web fallback for SecureStore with console warning
- [ ] Error handling with console.error logging
- [ ] All types prefixed with `I`
- [ ] Uses `#region` comments for organization
- [ ] Exported from `utils/index.ts`
- [ ] No `any` types
- [ ] TypeScript strict mode passes

## Testing

```typescript
// apps/v2/src/utils/storage.spec.ts

import AsyncStorage from "@react-native-async-storage/async-storage";
import * as SecureStore from "expo-secure-store";
import { Platform } from "react-native";

import {
  getItem,
  setItem,
  removeItem,
  getMultipleItems,
  setMultipleItems,
  clear,
  getAllKeys,
  isSecureStoreAvailable,
  getSecureItem,
  setSecureItem,
  removeSecureItem,
  getJsonItem,
  setJsonItem,
  STORAGE_PREFIX,
  SECURE_STORAGE_PREFIX,
} from "./storage";

jest.mock("@react-native-async-storage/async-storage");
jest.mock("expo-secure-store");

const mockAsyncStorage = AsyncStorage as jest.Mocked<typeof AsyncStorage>;
const mockSecureStore = SecureStore as jest.Mocked<typeof SecureStore>;

describe("storage utilities", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  //#region General Storage

  describe("getItem", () => {
    it("returns stored value", async () => {
      mockAsyncStorage.getItem.mockResolvedValue("test-value");

      const result = await getItem("test-key");

      expect(result).toBe("test-value");
      expect(mockAsyncStorage.getItem).toHaveBeenCalledWith(
        `${STORAGE_PREFIX}test-key`,
      );
    });

    it("returns null for missing key", async () => {
      mockAsyncStorage.getItem.mockResolvedValue(null);

      const result = await getItem("missing-key");

      expect(result).toBeNull();
    });

    it("returns null on error", async () => {
      mockAsyncStorage.getItem.mockRejectedValue(new Error("Read failed"));
      const consoleSpy = jest.spyOn(console, "error").mockImplementation();

      const result = await getItem("error-key");

      expect(result).toBeNull();
      expect(consoleSpy).toHaveBeenCalled();
      consoleSpy.mockRestore();
    });
  });

  describe("setItem", () => {
    it("stores value with prefix", async () => {
      mockAsyncStorage.setItem.mockResolvedValue();

      await setItem("test-key", "test-value");

      expect(mockAsyncStorage.setItem).toHaveBeenCalledWith(
        `${STORAGE_PREFIX}test-key`,
        "test-value",
      );
    });

    it("throws on error", async () => {
      mockAsyncStorage.setItem.mockRejectedValue(new Error("Write failed"));
      const consoleSpy = jest.spyOn(console, "error").mockImplementation();

      await expect(setItem("test-key", "value")).rejects.toThrow();

      consoleSpy.mockRestore();
    });
  });

  describe("removeItem", () => {
    it("removes item with prefix", async () => {
      mockAsyncStorage.removeItem.mockResolvedValue();

      await removeItem("test-key");

      expect(mockAsyncStorage.removeItem).toHaveBeenCalledWith(
        `${STORAGE_PREFIX}test-key`,
      );
    });
  });

  describe("getMultipleItems", () => {
    it("returns multiple values", async () => {
      mockAsyncStorage.multiGet.mockResolvedValue([
        [`${STORAGE_PREFIX}key1`, "value1"],
        [`${STORAGE_PREFIX}key2`, "value2"],
      ]);

      const result = await getMultipleItems(["key1", "key2"]);

      expect(result).toEqual({
        key1: "value1",
        key2: "value2",
      });
    });

    it("returns empty object on error", async () => {
      mockAsyncStorage.multiGet.mockRejectedValue(new Error("Failed"));
      const consoleSpy = jest.spyOn(console, "error").mockImplementation();

      const result = await getMultipleItems(["key1"]);

      expect(result).toEqual({});
      consoleSpy.mockRestore();
    });
  });

  describe("setMultipleItems", () => {
    it("stores multiple values", async () => {
      mockAsyncStorage.multiSet.mockResolvedValue();

      await setMultipleItems({ key1: "value1", key2: "value2" });

      expect(mockAsyncStorage.multiSet).toHaveBeenCalledWith([
        [`${STORAGE_PREFIX}key1`, "value1"],
        [`${STORAGE_PREFIX}key2`, "value2"],
      ]);
    });
  });

  describe("clear", () => {
    it("removes only app-prefixed keys", async () => {
      mockAsyncStorage.getAllKeys.mockResolvedValue([
        `${STORAGE_PREFIX}key1`,
        `${STORAGE_PREFIX}key2`,
        "other-app:key",
      ]);
      mockAsyncStorage.multiRemove.mockResolvedValue();

      await clear();

      expect(mockAsyncStorage.multiRemove).toHaveBeenCalledWith([
        `${STORAGE_PREFIX}key1`,
        `${STORAGE_PREFIX}key2`,
      ]);
    });

    it("does nothing when no app keys exist", async () => {
      mockAsyncStorage.getAllKeys.mockResolvedValue(["other-app:key"]);

      await clear();

      expect(mockAsyncStorage.multiRemove).not.toHaveBeenCalled();
    });
  });

  describe("getAllKeys", () => {
    it("returns app keys without prefix", async () => {
      mockAsyncStorage.getAllKeys.mockResolvedValue([
        `${STORAGE_PREFIX}key1`,
        `${STORAGE_PREFIX}key2`,
        "other-app:key",
      ]);

      const keys = await getAllKeys();

      expect(keys).toEqual(["key1", "key2"]);
    });
  });

  //#endregion

  //#region Secure Storage

  describe("isSecureStoreAvailable", () => {
    it("returns true when available", async () => {
      mockSecureStore.isAvailableAsync.mockResolvedValue(true);

      const result = await isSecureStoreAvailable();

      expect(result).toBe(true);
    });

    it("returns false when not available", async () => {
      mockSecureStore.isAvailableAsync.mockResolvedValue(false);

      const result = await isSecureStoreAvailable();

      expect(result).toBe(false);
    });
  });

  describe("getSecureItem", () => {
    it("returns stored value", async () => {
      mockSecureStore.getItemAsync.mockResolvedValue("secret-value");

      const result = await getSecureItem("token");

      expect(result).toBe("secret-value");
      expect(mockSecureStore.getItemAsync).toHaveBeenCalledWith(
        `${SECURE_STORAGE_PREFIX}token`,
        undefined,
      );
    });

    it("returns null on error", async () => {
      mockSecureStore.getItemAsync.mockRejectedValue(
        new Error("Access denied"),
      );
      const consoleSpy = jest.spyOn(console, "error").mockImplementation();

      const result = await getSecureItem("token");

      expect(result).toBeNull();
      consoleSpy.mockRestore();
    });
  });

  describe("setSecureItem", () => {
    it("stores value securely", async () => {
      mockSecureStore.setItemAsync.mockResolvedValue();

      await setSecureItem("token", "secret-value");

      expect(mockSecureStore.setItemAsync).toHaveBeenCalledWith(
        `${SECURE_STORAGE_PREFIX}token`,
        "secret-value",
        undefined,
      );
    });

    it("throws on error", async () => {
      mockSecureStore.setItemAsync.mockRejectedValue(new Error("Write failed"));
      const consoleSpy = jest.spyOn(console, "error").mockImplementation();

      await expect(setSecureItem("token", "value")).rejects.toThrow();

      consoleSpy.mockRestore();
    });
  });

  describe("removeSecureItem", () => {
    it("removes secure item", async () => {
      mockSecureStore.deleteItemAsync.mockResolvedValue();

      await removeSecureItem("token");

      expect(mockSecureStore.deleteItemAsync).toHaveBeenCalledWith(
        `${SECURE_STORAGE_PREFIX}token`,
        undefined,
      );
    });
  });

  //#endregion

  //#region JSON Helpers

  describe("getJsonItem", () => {
    it("parses JSON value", async () => {
      mockAsyncStorage.getItem.mockResolvedValue('{"key":"value"}');

      const result = await getJsonItem<{ key: string }>("json-key");

      expect(result).toEqual({ key: "value" });
    });

    it("returns null for missing key", async () => {
      mockAsyncStorage.getItem.mockResolvedValue(null);

      const result = await getJsonItem("missing");

      expect(result).toBeNull();
    });

    it("returns null for invalid JSON", async () => {
      mockAsyncStorage.getItem.mockResolvedValue("invalid-json");
      const consoleSpy = jest.spyOn(console, "error").mockImplementation();

      const result = await getJsonItem("bad-json");

      expect(result).toBeNull();
      consoleSpy.mockRestore();
    });
  });

  describe("setJsonItem", () => {
    it("stringifies and stores value", async () => {
      mockAsyncStorage.setItem.mockResolvedValue();

      await setJsonItem("json-key", { key: "value" });

      expect(mockAsyncStorage.setItem).toHaveBeenCalledWith(
        `${STORAGE_PREFIX}json-key`,
        '{"key":"value"}',
      );
    });
  });

  //#endregion
});
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- storage
```

### Type Check

```bash
pnpm --filter @retrievly/app tsc --noEmit
```

## Migration Notes

### API Differences from Mattermost

| Original (local_storage_store.ts) | New (storage.ts)  | Notes                  |
| --------------------------------- | ----------------- | ---------------------- |
| `localStorage.getItem()`          | `getItem()`       | Async, prefixed        |
| `localStorage.setItem()`          | `setItem()`       | Async, prefixed        |
| `localStorage.removeItem()`       | `removeItem()`    | Async, prefixed        |
| `localStorage.clear()`            | `clear()`         | Only clears app keys   |
| N/A                               | `getSecureItem()` | New: encrypted storage |
| N/A                               | `setSecureItem()` | New: encrypted storage |

### Security Considerations

1. **Never store sensitive data in AsyncStorage** - use SecureStore
2. **Token storage**: Use `setSecureItem("auth_token", token)`
3. **User credentials**: Never store passwords; use tokens
4. **Web fallback**: SecureStore uses localStorage on web (not encrypted)
5. **Size limits**: SecureStore has ~2KB limit per item on iOS
