# T9.19: useDrafts Hook

## Metadata

| Field        | Value            |
| ------------ | ---------------- |
| **ID**       | T9.19            |
| **Layer**    | L9 - State Hooks |
| **Status**   | pending          |
| **Priority** | medium           |
| **Estimate** | 2h               |
| **Parallel** | true             |
| **Assignee** | -                |
| **Created**  | 2026-01-06       |
| **Updated**  | 2026-01-07       |

## Dependencies

| Task ID | Name           |
| ------- | -------------- |
| T7.33   | useDraftsStore |

## Description

Hook to manage message drafts for channels and threads. Drafts are persisted locally
using Zustand's persist middleware (see T7.33).

**Architecture Note:** Drafts are client-only state (not from server), so this uses
Zustand with persistence. See `.docs/architecture/state-management.md`.

## Source Analysis

- **Redux Selector**: `vendor/desktop/webapp/platform/client/src/selectors/entities/posts.ts` - drafts
- **Storage Key**: `storage.draft_*` in vendor

## Migration Target

- **Target File**: `apps/v2/src/hooks/useDrafts/useDrafts.ts`
- **Index Export**: `apps/v2/src/hooks/useDrafts/index.ts`

## Implementation

````typescript
// apps/v2/src/hooks/useDrafts/useDrafts.ts

import { useDraftsStore } from "@/stores/drafts";
import type { IDraft } from "@/types";

//#region Types

type IUseChannelDraftReturn = {
  /** Current draft for the channel */
  draft: IDraft | undefined;
  /** Update draft content */
  setDraft: (message: string, files?: string[]) => void;
  /** Clear draft */
  clearDraft: () => void;
  /** Check if draft has content */
  hasDraft: boolean;
};

type IUseThreadDraftReturn = {
  /** Current draft for the thread */
  draft: IDraft | undefined;
  /** Update draft content */
  setDraft: (message: string, files?: string[]) => void;
  /** Clear draft */
  clearDraft: () => void;
  /** Check if draft has content */
  hasDraft: boolean;
};

//#endregion Types

//#region Channel Draft Hook

/**
 * Manages draft message for a channel.
 * Drafts are automatically persisted to local storage.
 *
 * @param channelId - Channel ID
 * @returns Draft state and actions
 *
 * @example
 * ```tsx
 * function MessageComposer({ channelId }: { channelId: string }) {
 *   const { draft, setDraft, clearDraft } = useChannelDraft(channelId);
 *
 *   return (
 *     <TextInput
 *       value={draft?.message ?? ''}
 *       onChangeText={(text) => setDraft(text)}
 *       onSubmit={() => {
 *         sendMessage(draft?.message);
 *         clearDraft();
 *       }}
 *     />
 *   );
 * }
 * ```
 */
export function useChannelDraft(channelId: string): IUseChannelDraftReturn {
  const draft = useDraftsStore((state) => state.channelDrafts[channelId]);
  const setChannelDraft = useDraftsStore((state) => state.setChannelDraft);
  const clearChannelDraft = useDraftsStore((state) => state.clearChannelDraft);

  return {
    draft,
    setDraft: (message, files) => setChannelDraft(channelId, message, files),
    clearDraft: () => clearChannelDraft(channelId),
    hasDraft: !!draft?.message?.trim(),
  };
}

//#endregion Channel Draft Hook

//#region Thread Draft Hook

/**
 * Manages draft message for a thread reply.
 * Drafts are automatically persisted to local storage.
 *
 * @param rootId - Root post ID of the thread
 * @returns Draft state and actions
 */
export function useThreadDraft(rootId: string): IUseThreadDraftReturn {
  const draft = useDraftsStore((state) => state.threadDrafts[rootId]);
  const setThreadDraft = useDraftsStore((state) => state.setThreadDraft);
  const clearThreadDraft = useDraftsStore((state) => state.clearThreadDraft);

  return {
    draft,
    setDraft: (message, files) => setThreadDraft(rootId, message, files),
    clearDraft: () => clearThreadDraft(rootId),
    hasDraft: !!draft?.message?.trim(),
  };
}

//#endregion Thread Draft Hook

//#region All Drafts Hook

/**
 * Returns count and list of all drafts (for drafts indicator).
 */
export function useDraftsList() {
  const channelDrafts = useDraftsStore((state) =>
    Object.entries(state.channelDrafts).filter(([_, d]) => d.message?.trim()),
  );
  const threadDrafts = useDraftsStore((state) =>
    Object.entries(state.threadDrafts).filter(([_, d]) => d.message?.trim()),
  );

  return {
    channelDrafts: channelDrafts.map(([channelId, draft]) => ({
      channelId,
      ...draft,
    })),
    threadDrafts: threadDrafts.map(([rootId, draft]) => ({
      rootId,
      ...draft,
    })),
    totalCount: channelDrafts.length + threadDrafts.length,
  };
}

//#endregion All Drafts Hook
````

## Index Export

```typescript
// apps/v2/src/hooks/useDrafts/index.ts

export { useChannelDraft, useThreadDraft, useDraftsList } from "./useDrafts";
```

## Acceptance Criteria

- [ ] `useChannelDraft` returns draft for channel
- [ ] `useThreadDraft` returns draft for thread
- [ ] `setDraft` updates draft with message and optional files
- [ ] `clearDraft` removes draft
- [ ] `hasDraft` returns true if draft has non-empty content
- [ ] `useDraftsList` returns all non-empty drafts with count
- [ ] Drafts persist across app restarts (via useDraftsStore)
- [ ] TypeScript strict mode passes

## Testing

```typescript
// apps/v2/src/hooks/useDrafts/useDrafts.spec.ts

import { renderHook, act } from "@testing-library/react-native";
import { useChannelDraft, useThreadDraft, useDraftsList } from "./useDrafts";
import { useDraftsStore } from "@/stores/drafts";

// Reset store before each test
beforeEach(() => {
  useDraftsStore.getState().reset();
});

describe("useChannelDraft", () => {
  it("returns undefined when no draft exists", () => {
    const { result } = renderHook(() => useChannelDraft("ch-1"));

    expect(result.current.draft).toBeUndefined();
    expect(result.current.hasDraft).toBe(false);
  });

  it("sets and clears draft", () => {
    const { result } = renderHook(() => useChannelDraft("ch-1"));

    act(() => {
      result.current.setDraft("Hello world");
    });

    expect(result.current.draft?.message).toBe("Hello world");
    expect(result.current.hasDraft).toBe(true);

    act(() => {
      result.current.clearDraft();
    });

    expect(result.current.draft).toBeUndefined();
    expect(result.current.hasDraft).toBe(false);
  });

  it("sets draft with files", () => {
    const { result } = renderHook(() => useChannelDraft("ch-1"));

    act(() => {
      result.current.setDraft("Check this file", ["file-1", "file-2"]);
    });

    expect(result.current.draft?.files).toEqual(["file-1", "file-2"]);
  });
});

describe("useDraftsList", () => {
  it("returns count of non-empty drafts", () => {
    // Set up some drafts
    act(() => {
      useDraftsStore.getState().setChannelDraft("ch-1", "Draft 1");
      useDraftsStore.getState().setChannelDraft("ch-2", "  "); // Empty
      useDraftsStore.getState().setThreadDraft("post-1", "Thread draft");
    });

    const { result } = renderHook(() => useDraftsList());

    expect(result.current.totalCount).toBe(2); // ch-1 and post-1
    expect(result.current.channelDrafts).toHaveLength(1);
    expect(result.current.threadDrafts).toHaveLength(1);
  });
});
```

## Notes

- **Persistence** — useDraftsStore uses Zustand's `persist` middleware (see T7.33)
- **Empty check** — `hasDraft` trims whitespace before checking
- **File references** — `files` array contains file IDs for pending uploads
