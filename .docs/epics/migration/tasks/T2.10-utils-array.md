# T2.10: Array Utilities

## Metadata

| Field        | Value      |
| ------------ | ---------- |
| **ID**       | T2.10      |
| **Layer**    | L2 - Utils |
| **Status**   | pending    |
| **Priority** | medium     |
| **Estimate** | 0.5h       |
| **Parallel** | true       |
| **Assignee** | -          |
| **Created**  | 2026-01-04 |
| **Updated**  | 2026-01-04 |

## Dependencies

| Task ID | Name        | Why                                          |
| ------- | ----------- | -------------------------------------------- |
| T0.01   | User Types  | `sortUsersAndGroups` requires `IUserProfile` |
| T0.03   | Group Types | `sortUsersAndGroups` requires `IGroup`       |

## Blocks

| Task ID | Name                       |
| ------- | -------------------------- |
| T10c.\* | User/Group list components |
| T8.\*   | Hooks using sorted lists   |

## Description

Migrate array utility functions from Mattermost utils. These helpers provide common array operations for sorting and transforming collections of users and groups.

## Source Files

- `vendor/desktop/webapp/channels/src/utils/utils.tsx` (lines 1643-1658, 1180-1188)

## Target File

`apps/v2/src/utils/array.ts`

## Implementation

```typescript
// apps/v2/src/utils/array.ts

import type { IUserProfile } from "@/types/user";
import type { IGroup } from "@/types/group";

//#region Types

type ISortableEntity = IUserProfile | IGroup;

//#endregion

//#region Sorting

/**
 * Sorts an array of users and groups alphabetically by username or group name.
 * Users are sorted by `username`, groups are sorted by `name`.
 *
 * @param a - First entity (user or group)
 * @param b - Second entity (user or group)
 * @returns Comparison result for Array.sort()
 *
 * @example
 * const mixed = [...users, ...groups];
 * mixed.sort(sortUsersAndGroups);
 */
export function sortUsersAndGroups(
  a: ISortableEntity,
  b: ISortableEntity,
): number {
  const aSortString = "username" in a ? a.username : a.name;
  const bSortString = "username" in b ? b.username : b.name;
  return aSortString.localeCompare(bSortString);
}

//#endregion

//#region Record Utilities

/**
 * Creates a record filled with the same value for indices 0 to length-1.
 *
 * @param value - Value to fill
 * @param length - Number of entries
 * @returns Record with numeric keys
 *
 * @example
 * fillRecord(false, 3) // { 0: false, 1: false, 2: false }
 */
export function fillRecord<T>(value: T, length: number): Record<number, T> {
  const result: Record<number, T> = {};
  for (let i = 0; i < length; i++) {
    result[i] = value;
  }
  return result;
}

//#endregion

//#region Immutable Operations

/**
 * Inserts an item into an array if it's not already present.
 * Returns a new array (immutable).
 *
 * @param array - Source array
 * @param item - Item to insert
 * @returns New array with item added if not duplicate
 *
 * @example
 * insertWithoutDuplicates([1, 2, 3], 4) // [1, 2, 3, 4]
 * insertWithoutDuplicates([1, 2, 3], 2) // [1, 2, 3]
 */
export function insertWithoutDuplicates<T>(array: T[], item: T): T[] {
  if (array.includes(item)) {
    return array;
  }
  return [...array, item];
}

/**
 * Inserts multiple items into an array, excluding duplicates.
 * Returns a new array (immutable).
 *
 * @param array - Source array
 * @param items - Items to insert
 * @returns New array with non-duplicate items added
 *
 * @example
 * insertMultipleWithoutDuplicates([1, 2], [2, 3, 4]) // [1, 2, 3, 4]
 */
export function insertMultipleWithoutDuplicates<T>(
  array: T[],
  items: T[],
): T[] {
  const newItems = items.filter((item) => !array.includes(item));
  if (newItems.length === 0) {
    return array;
  }
  return [...array, ...newItems];
}

/**
 * Removes an item from an array.
 * Returns a new array (immutable).
 *
 * @param array - Source array
 * @param item - Item to remove
 * @returns New array without the item
 *
 * @example
 * removeItem([1, 2, 3], 2) // [1, 3]
 * removeItem([1, 2, 3], 4) // [1, 2, 3]
 */
export function removeItem<T>(array: T[], item: T): T[] {
  const index = array.indexOf(item);
  if (index === -1) {
    return array;
  }
  return [...array.slice(0, index), ...array.slice(index + 1)];
}

//#endregion

//#region Array Helpers

/**
 * Removes duplicate values from an array.
 *
 * @param arr - Input array
 * @returns New array with unique values
 *
 * @example
 * unique([1, 2, 2, 3]) // [1, 2, 3]
 */
export function unique<T>(arr: T[]): T[] {
  return [...new Set(arr)];
}

/**
 * Removes duplicate objects from an array by a key property.
 *
 * @param arr - Input array
 * @param key - Property to use for uniqueness
 * @returns New array with unique objects
 *
 * @example
 * uniqueBy([{ id: 1 }, { id: 1 }, { id: 2 }], 'id') // [{ id: 1 }, { id: 2 }]
 */
export function uniqueBy<T, K extends keyof T>(arr: T[], key: K): T[] {
  const seen = new Set<T[K]>();
  return arr.filter((item) => {
    if (seen.has(item[key])) {
      return false;
    }
    seen.add(item[key]);
    return true;
  });
}

/**
 * Splits an array into chunks of specified size.
 *
 * @param arr - Input array
 * @param size - Chunk size
 * @returns Array of chunks
 *
 * @example
 * chunk([1, 2, 3, 4, 5], 2) // [[1, 2], [3, 4], [5]]
 */
export function chunk<T>(arr: T[], size: number): T[][] {
  if (size <= 0) {
    return [];
  }
  const result: T[][] = [];
  for (let i = 0; i < arr.length; i += size) {
    result.push(arr.slice(i, i + size));
  }
  return result;
}

/**
 * Groups array elements by a key function.
 *
 * @param arr - Input array
 * @param keyFn - Function to extract group key
 * @returns Map of grouped elements
 *
 * @example
 * groupBy([1, 2, 3, 4], n => n % 2 === 0 ? 'even' : 'odd')
 * // Map { 'odd' => [1, 3], 'even' => [2, 4] }
 */
export function groupBy<T, K>(arr: T[], keyFn: (item: T) => K): Map<K, T[]> {
  const result = new Map<K, T[]>();
  for (const item of arr) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group) {
      group.push(item);
    } else {
      result.set(key, [item]);
    }
  }
  return result;
}

//#endregion
```

## Index Export

```typescript
// apps/v2/src/utils/index.ts

export {
  sortUsersAndGroups,
  fillRecord,
  insertWithoutDuplicates,
  insertMultipleWithoutDuplicates,
  removeItem,
  unique,
  uniqueBy,
  chunk,
  groupBy,
} from "./array";
```

## Acceptance Criteria

- [ ] `sortUsersAndGroups` correctly sorts mixed user/group arrays
- [ ] `fillRecord` creates records with correct indices
- [ ] `insertWithoutDuplicates` adds item only if not present
- [ ] `insertMultipleWithoutDuplicates` adds multiple items excluding duplicates
- [ ] `removeItem` removes item immutably
- [ ] `unique` removes duplicate primitives
- [ ] `uniqueBy` removes duplicate objects by key
- [ ] `chunk` splits arrays correctly
- [ ] `groupBy` groups elements correctly
- [ ] All functions are pure (no side effects)
- [ ] TypeScript strict mode passes
- [ ] Exported from `utils/index.ts`

## Testing

```typescript
// apps/v2/src/utils/array.spec.ts

import {
  sortUsersAndGroups,
  fillRecord,
  insertWithoutDuplicates,
  insertMultipleWithoutDuplicates,
  removeItem,
  unique,
  uniqueBy,
  chunk,
  groupBy,
} from "./array";
import type { IUserProfile } from "@/types/user";
import type { IGroup } from "@/types/group";

describe("sortUsersAndGroups", () => {
  it("sorts users by username", () => {
    const users = [
      { username: "charlie" } as IUserProfile,
      { username: "alice" } as IUserProfile,
      { username: "bob" } as IUserProfile,
    ];
    const sorted = [...users].sort(sortUsersAndGroups);
    expect(sorted.map((u) => u.username)).toEqual(["alice", "bob", "charlie"]);
  });

  it("sorts groups by name", () => {
    const groups = [{ name: "zeta" } as IGroup, { name: "alpha" } as IGroup];
    const sorted = [...groups].sort(sortUsersAndGroups);
    expect(sorted.map((g) => g.name)).toEqual(["alpha", "zeta"]);
  });

  it("sorts mixed users and groups together", () => {
    const mixed = [
      { username: "charlie" } as IUserProfile,
      { name: "beta" } as IGroup,
      { username: "alice" } as IUserProfile,
    ];
    const sorted = [...mixed].sort(sortUsersAndGroups);
    expect(sorted).toEqual([
      { username: "alice" },
      { name: "beta" },
      { username: "charlie" },
    ]);
  });
});

describe("fillRecord", () => {
  it("creates record with correct length", () => {
    const result = fillRecord("x", 3);
    expect(result).toEqual({ 0: "x", 1: "x", 2: "x" });
  });

  it("handles zero length", () => {
    const result = fillRecord("x", 0);
    expect(result).toEqual({});
  });

  it("handles boolean values", () => {
    const result = fillRecord(false, 2);
    expect(result).toEqual({ 0: false, 1: false });
  });
});

describe("insertWithoutDuplicates", () => {
  it("adds item if not present", () => {
    expect(insertWithoutDuplicates([1, 2, 3], 4)).toEqual([1, 2, 3, 4]);
  });

  it("returns same array if item exists", () => {
    const arr = [1, 2, 3];
    expect(insertWithoutDuplicates(arr, 2)).toBe(arr);
  });

  it("handles empty array", () => {
    expect(insertWithoutDuplicates([], 1)).toEqual([1]);
  });
});

describe("insertMultipleWithoutDuplicates", () => {
  it("adds only non-duplicate items", () => {
    expect(insertMultipleWithoutDuplicates([1, 2], [2, 3, 4])).toEqual([
      1, 2, 3, 4,
    ]);
  });

  it("returns same array if all items exist", () => {
    const arr = [1, 2, 3];
    expect(insertMultipleWithoutDuplicates(arr, [1, 2])).toBe(arr);
  });

  it("handles empty items array", () => {
    const arr = [1, 2];
    expect(insertMultipleWithoutDuplicates(arr, [])).toBe(arr);
  });
});

describe("removeItem", () => {
  it("removes item from array", () => {
    expect(removeItem([1, 2, 3], 2)).toEqual([1, 3]);
  });

  it("returns same array if item not found", () => {
    const arr = [1, 2, 3];
    expect(removeItem(arr, 4)).toBe(arr);
  });

  it("removes only first occurrence", () => {
    expect(removeItem([1, 2, 2, 3], 2)).toEqual([1, 2, 3]);
  });

  it("handles empty array", () => {
    expect(removeItem([], 1)).toEqual([]);
  });
});

describe("unique", () => {
  it("removes duplicate numbers", () => {
    expect(unique([1, 2, 2, 3, 1])).toEqual([1, 2, 3]);
  });

  it("removes duplicate strings", () => {
    expect(unique(["a", "b", "a"])).toEqual(["a", "b"]);
  });

  it("preserves order of first occurrence", () => {
    expect(unique([3, 1, 2, 1, 3])).toEqual([3, 1, 2]);
  });

  it("handles empty array", () => {
    expect(unique([])).toEqual([]);
  });
});

describe("uniqueBy", () => {
  it("removes duplicates by id", () => {
    const items = [
      { id: 1, name: "a" },
      { id: 2, name: "b" },
      { id: 1, name: "c" },
    ];
    expect(uniqueBy(items, "id")).toEqual([
      { id: 1, name: "a" },
      { id: 2, name: "b" },
    ]);
  });

  it("handles empty array", () => {
    expect(uniqueBy([], "id")).toEqual([]);
  });
});

describe("chunk", () => {
  it("splits array into chunks", () => {
    expect(chunk([1, 2, 3, 4, 5], 2)).toEqual([[1, 2], [3, 4], [5]]);
  });

  it("handles exact division", () => {
    expect(chunk([1, 2, 3, 4], 2)).toEqual([
      [1, 2],
      [3, 4],
    ]);
  });

  it("handles size larger than array", () => {
    expect(chunk([1, 2], 5)).toEqual([[1, 2]]);
  });

  it("handles empty array", () => {
    expect(chunk([], 2)).toEqual([]);
  });

  it("handles zero size", () => {
    expect(chunk([1, 2, 3], 0)).toEqual([]);
  });
});

describe("groupBy", () => {
  it("groups by function result", () => {
    const result = groupBy([1, 2, 3, 4], (n) => (n % 2 === 0 ? "even" : "odd"));
    expect(result.get("odd")).toEqual([1, 3]);
    expect(result.get("even")).toEqual([2, 4]);
  });

  it("handles empty array", () => {
    const result = groupBy([], (n: number) => n);
    expect(result.size).toBe(0);
  });

  it("groups objects by property", () => {
    const items = [
      { type: "a", value: 1 },
      { type: "b", value: 2 },
      { type: "a", value: 3 },
    ];
    const result = groupBy(items, (item) => item.type);
    expect(result.get("a")).toEqual([
      { type: "a", value: 1 },
      { type: "a", value: 3 },
    ]);
    expect(result.get("b")).toEqual([{ type: "b", value: 2 }]);
  });
});
```

Run tests:

```bash
pnpm --filter @retrievly/app test:unit -- array
```
