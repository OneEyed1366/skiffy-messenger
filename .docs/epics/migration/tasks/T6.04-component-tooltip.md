# T6.04: Tooltip Component

## Metadata

| Field        | Value              |
| ------------ | ------------------ |
| **ID**       | T6.04              |
| **Layer**    | L6 - UI Components |
| **Status**   | pending            |
| **Priority** | high               |
| **Estimate** | 4h                 |
| **Parallel** | true               |
| **Assignee** | -                  |
| **Created**  | 2026-01-04         |
| **Updated**  | 2026-01-04         |

## Dependencies

| Task ID | Name          |
| ------- | ------------- |
| T5.01   | hooks-portal  |
| T0.15   | types-utility |

## Blocks

| Task ID | Name                          |
| ------- | ----------------------------- |
| T6.\*   | Components requiring tooltips |
| T10b.\* | Feature components            |

## Description

Migrate the Tooltip component from Mattermost. The original uses `@floating-ui/react` for positioning, hover/focus interactions, and portal rendering. Replace with a React Native compatible implementation using either a RN tooltip library or a custom Portal-based solution.

Key features:

- Trigger on press (mobile) or hover (desktop via Tauri)
- Placement variants (top, bottom, left, right)
- Arrow indicator pointing to trigger element
- Configurable show/hide delay
- Portal rendering to avoid overflow clipping

## Source Files

- `vendor/desktop/webapp/channels/src/components/with_tooltip/index.tsx` (lines 1-222)
- `vendor/desktop/webapp/channels/src/components/with_tooltip/tooltip_content.tsx` (lines 1-71)
- `vendor/desktop/webapp/channels/src/components/with_tooltip/tooltip_shortcut.tsx`
- `vendor/desktop/webapp/channels/src/components/with_tooltip/index.test.tsx`

### Source Analysis

The original implementation uses:

- **@floating-ui/react**: For positioning (`useFloating`), auto-update, offset, flip, arrow middleware
- **FloatingPortal**: For rendering outside DOM hierarchy
- **useHover/useFocus**: For trigger interactions
- **useTransitionStyles**: For fade in/out animations
- **classnames**: For conditional class composition

Key features migrated:
| Original Feature | Purpose |
|-----------------------|----------------------------------------------|
| `useFloating` | Calculates tooltip position relative to trigger |
| `useHover` | Hover trigger with configurable delay |
| `useFocus` | Focus trigger for accessibility |
| `useDismiss` | Close on outside interaction |
| `FloatingArrow` | Arrow pointing to trigger |
| `flip` | Auto-flip placement when constrained |
| Placement variants | top, bottom, left, right positioning |
| Transition styles | Fade in/out with configurable duration |

## Migration Target

- **Target File**: `apps/v2/src/components/Tooltip/Tooltip.tsx`
- **Index Export**: `apps/v2/src/components/Tooltip/index.ts`

## Implementation

```typescript
// apps/v2/src/components/Tooltip/Tooltip.tsx

/**
 * Tooltip component
 * Migrated from: vendor/desktop/webapp/channels/src/components/with_tooltip/index.tsx
 *
 * Uses Portal for rendering and measure API for positioning
 */

import { useCallback, useRef, useState } from "react";
import {
  Animated,
  LayoutRectangle,
  Modal,
  Platform,
  Pressable,
  View,
} from "react-native";
import { StyleSheet, UnistylesVariants } from "react-native-unistyles";

//#region Types

type IPlacement = "top" | "bottom" | "left" | "right";

type IProps = {
  /**
   * Content to display in the tooltip
   */
  content: React.ReactNode;

  /**
   * Tooltip placement relative to trigger
   * @default "top"
   */
  placement?: IPlacement;

  /**
   * Delay before showing tooltip (ms)
   * @default 300
   */
  showDelay?: number;

  /**
   * Delay before hiding tooltip (ms)
   * @default 0
   */
  hideDelay?: number;

  /**
   * Whether tooltip is disabled
   * @default false
   */
  disabled?: boolean;

  /**
   * Trigger element (must accept onPress/onPressIn/onPressOut or onHoverIn/onHoverOut)
   */
  children: React.ReactElement;

  /**
   * Optional callback when tooltip opens
   */
  onOpen?: () => void;

  /**
   * Optional callback when tooltip closes
   */
  onClose?: () => void;

  ref?: React.Ref<View>;
} & UnistylesVariants<typeof styles>;

type ITooltipPosition = {
  top: number;
  left: number;
  arrowTop: number;
  arrowLeft: number;
  arrowRotation: string;
};

//#endregion Types

//#region Constants

const ARROW_SIZE = 8;
const TOOLTIP_OFFSET = 8;
const ANIMATION_DURATION = 150;

//#endregion Constants

//#region Component

export function Tooltip({
  content,
  placement = "top",
  showDelay = 300,
  hideDelay = 0,
  disabled = false,
  children,
  onOpen,
  onClose,
  ref,
}: IProps) {
  const [visible, setVisible] = useState(false);
  const [triggerLayout, setTriggerLayout] = useState<LayoutRectangle | null>(
    null,
  );
  const [tooltipSize, setTooltipSize] = useState({ width: 0, height: 0 });
  const opacity = useRef(new Animated.Value(0)).current;
  const triggerRef = useRef<View>(null);
  const showTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const hideTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  styles.useVariants({ placement });

  const measureTrigger = useCallback(() => {
    triggerRef.current?.measureInWindow((x, y, width, height) => {
      setTriggerLayout({ x, y, width, height });
    });
  }, []);

  const showTooltip = useCallback(() => {
    if (disabled) return;

    if (hideTimeoutRef.current) {
      clearTimeout(hideTimeoutRef.current);
      hideTimeoutRef.current = null;
    }

    measureTrigger();

    showTimeoutRef.current = setTimeout(() => {
      setVisible(true);
      Animated.timing(opacity, {
        toValue: 1,
        duration: ANIMATION_DURATION,
        useNativeDriver: true,
      }).start();
      onOpen?.();
    }, showDelay);
  }, [disabled, measureTrigger, showDelay, opacity, onOpen]);

  const hideTooltip = useCallback(() => {
    if (showTimeoutRef.current) {
      clearTimeout(showTimeoutRef.current);
      showTimeoutRef.current = null;
    }

    hideTimeoutRef.current = setTimeout(() => {
      Animated.timing(opacity, {
        toValue: 0,
        duration: ANIMATION_DURATION,
        useNativeDriver: true,
      }).start(() => {
        setVisible(false);
        onClose?.();
      });
    }, hideDelay);
  }, [hideDelay, opacity, onClose]);

  const calculatePosition = useCallback((): ITooltipPosition | null => {
    if (!triggerLayout) return null;

    const { x, y, width, height } = triggerLayout;
    let top = 0;
    let left = 0;
    let arrowTop = 0;
    let arrowLeft = 0;
    let arrowRotation = "0deg";

    switch (placement) {
      case "top":
        top = y - tooltipSize.height - TOOLTIP_OFFSET;
        left = x + width / 2 - tooltipSize.width / 2;
        arrowTop = tooltipSize.height - 2;
        arrowLeft = tooltipSize.width / 2 - ARROW_SIZE;
        arrowRotation = "180deg";
        break;
      case "bottom":
        top = y + height + TOOLTIP_OFFSET;
        left = x + width / 2 - tooltipSize.width / 2;
        arrowTop = -ARROW_SIZE + 2;
        arrowLeft = tooltipSize.width / 2 - ARROW_SIZE;
        arrowRotation = "0deg";
        break;
      case "left":
        top = y + height / 2 - tooltipSize.height / 2;
        left = x - tooltipSize.width - TOOLTIP_OFFSET;
        arrowTop = tooltipSize.height / 2 - ARROW_SIZE;
        arrowLeft = tooltipSize.width - 2;
        arrowRotation = "90deg";
        break;
      case "right":
        top = y + height / 2 - tooltipSize.height / 2;
        left = x + width + TOOLTIP_OFFSET;
        arrowTop = tooltipSize.height / 2 - ARROW_SIZE;
        arrowLeft = -ARROW_SIZE + 2;
        arrowRotation = "-90deg";
        break;
    }

    return { top, left, arrowTop, arrowLeft, arrowRotation };
  }, [triggerLayout, tooltipSize, placement]);

  const position = calculatePosition();

  // Platform-specific trigger props
  const triggerProps =
    Platform.OS === "web"
      ? {
          onHoverIn: showTooltip,
          onHoverOut: hideTooltip,
          onFocus: showTooltip,
          onBlur: hideTooltip,
        }
      : {
          onLongPress: showTooltip,
          onPressOut: hideTooltip,
        };

  return (
    <View ref={ref}>
      <Pressable ref={triggerRef} {...triggerProps}>
        {children}
      </Pressable>

      <Modal visible={visible} transparent animationType="none">
        <Pressable style={styles.overlay} onPress={hideTooltip}>
          {position && (
            <Animated.View
              style={[
                styles.container,
                {
                  top: position.top,
                  left: position.left,
                  opacity,
                },
              ]}
              onLayout={(e) => {
                const { width, height } = e.nativeEvent.layout;
                if (width !== tooltipSize.width || height !== tooltipSize.height) {
                  setTooltipSize({ width, height });
                }
              }}
            >
              <View style={styles.content}>{content}</View>
              <View
                style={[
                  styles.arrow,
                  {
                    top: position.arrowTop,
                    left: position.arrowLeft,
                    transform: [{ rotate: position.arrowRotation }],
                  },
                ]}
              />
            </Animated.View>
          )}
        </Pressable>
      </Modal>
    </View>
  );
}

//#endregion Component

//#region Styles

const styles = StyleSheet.create((theme) => ({
  overlay: {
    flex: 1,
  },
  container: {
    position: "absolute",
    maxWidth: 280,
    zIndex: 9999,
  },
  content: {
    paddingHorizontal: theme.gap(1.5),
    paddingVertical: theme.gap(1),
    backgroundColor: theme.colors.centerChannelColor,
    borderRadius: theme.radius.s,
  },
  arrow: {
    position: "absolute",
    width: 0,
    height: 0,
    borderLeftWidth: ARROW_SIZE,
    borderRightWidth: ARROW_SIZE,
    borderBottomWidth: ARROW_SIZE,
    borderLeftColor: "transparent",
    borderRightColor: "transparent",
    borderBottomColor: theme.colors.centerChannelColor,
  },
}));

//#endregion Styles
```

## Index Export

```typescript
// apps/v2/src/components/Tooltip/index.ts

export { Tooltip } from "./Tooltip";
```

## Acceptance Criteria

- [ ] Renders tooltip content in Portal/Modal to avoid overflow clipping
- [ ] Supports placement variants: `top`, `bottom`, `left`, `right`
- [ ] Shows arrow indicator pointing to trigger element
- [ ] Triggers on hover/focus for web (desktop)
- [ ] Triggers on long press for mobile
- [ ] Supports configurable show/hide delay
- [ ] Animates fade in/out transitions
- [ ] Closes on outside tap/click
- [ ] Disabled prop prevents tooltip from showing
- [ ] Calls `onOpen`/`onClose` callbacks
- [ ] Uses Unistyles for theming
- [ ] TypeScript strict mode passes
- [ ] No `any` types
- [ ] All types use `I` prefix naming convention
- [ ] Exported from component index

## Testing

```typescript
// apps/v2/src/components/Tooltip/Tooltip.spec.tsx

import { render, fireEvent, waitFor, act } from "@testing-library/react-native";
import { Text } from "react-native";

import { Tooltip } from "./Tooltip";

//#region Rendering Tests

describe("<Tooltip />", () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it("renders children", () => {
    const { getByText } = render(
      <Tooltip content={<Text>Tooltip content</Text>}>
        <Text>Trigger</Text>
      </Tooltip>,
    );

    expect(getByText("Trigger")).toBeTruthy();
  });

  it("does not show tooltip initially", () => {
    const { queryByText } = render(
      <Tooltip content={<Text>Tooltip content</Text>}>
        <Text>Trigger</Text>
      </Tooltip>,
    );

    expect(queryByText("Tooltip content")).toBeNull();
  });

  it("shows tooltip on long press (mobile)", async () => {
    const { getByText, queryByText } = render(
      <Tooltip content={<Text>Tooltip content</Text>} showDelay={0}>
        <Text>Trigger</Text>
      </Tooltip>,
    );

    fireEvent(getByText("Trigger"), "longPress");

    await act(async () => {
      jest.advanceTimersByTime(0);
    });

    await waitFor(() => {
      expect(queryByText("Tooltip content")).toBeTruthy();
    });
  });

  it("hides tooltip on press out", async () => {
    const { getByText, queryByText } = render(
      <Tooltip content={<Text>Tooltip content</Text>} showDelay={0} hideDelay={0}>
        <Text>Trigger</Text>
      </Tooltip>,
    );

    fireEvent(getByText("Trigger"), "longPress");

    await act(async () => {
      jest.advanceTimersByTime(0);
    });

    fireEvent(getByText("Trigger"), "pressOut");

    await act(async () => {
      jest.advanceTimersByTime(200);
    });

    await waitFor(() => {
      expect(queryByText("Tooltip content")).toBeNull();
    });
  });

  it("does not show tooltip when disabled", async () => {
    const { getByText, queryByText } = render(
      <Tooltip content={<Text>Tooltip content</Text>} disabled showDelay={0}>
        <Text>Trigger</Text>
      </Tooltip>,
    );

    fireEvent(getByText("Trigger"), "longPress");

    await act(async () => {
      jest.advanceTimersByTime(0);
    });

    expect(queryByText("Tooltip content")).toBeNull();
  });

  it("calls onOpen callback when tooltip shows", async () => {
    const onOpen = jest.fn();

    const { getByText } = render(
      <Tooltip content={<Text>Tooltip content</Text>} onOpen={onOpen} showDelay={0}>
        <Text>Trigger</Text>
      </Tooltip>,
    );

    fireEvent(getByText("Trigger"), "longPress");

    await act(async () => {
      jest.advanceTimersByTime(0);
    });

    await waitFor(() => {
      expect(onOpen).toHaveBeenCalledTimes(1);
    });
  });

  it("calls onClose callback when tooltip hides", async () => {
    const onClose = jest.fn();

    const { getByText } = render(
      <Tooltip
        content={<Text>Tooltip content</Text>}
        onClose={onClose}
        showDelay={0}
        hideDelay={0}
      >
        <Text>Trigger</Text>
      </Tooltip>,
    );

    fireEvent(getByText("Trigger"), "longPress");

    await act(async () => {
      jest.advanceTimersByTime(0);
    });

    fireEvent(getByText("Trigger"), "pressOut");

    await act(async () => {
      jest.advanceTimersByTime(200);
    });

    await waitFor(() => {
      expect(onClose).toHaveBeenCalledTimes(1);
    });
  });

  it("respects showDelay prop", async () => {
    const { getByText, queryByText } = render(
      <Tooltip content={<Text>Tooltip content</Text>} showDelay={500}>
        <Text>Trigger</Text>
      </Tooltip>,
    );

    fireEvent(getByText("Trigger"), "longPress");

    // Not visible yet
    await act(async () => {
      jest.advanceTimersByTime(200);
    });
    expect(queryByText("Tooltip content")).toBeNull();

    // Visible after delay
    await act(async () => {
      jest.advanceTimersByTime(300);
    });

    await waitFor(() => {
      expect(queryByText("Tooltip content")).toBeTruthy();
    });
  });
});

//#endregion Rendering Tests

//#region Placement Tests

describe("<Tooltip /> placements", () => {
  it.each(["top", "bottom", "left", "right"] as const)(
    "renders with placement %s",
    (placement) => {
      const { getByText } = render(
        <Tooltip content={<Text>Content</Text>} placement={placement}>
          <Text>Trigger</Text>
        </Tooltip>,
      );

      expect(getByText("Trigger")).toBeTruthy();
    },
  );
});

//#endregion Placement Tests
```

### Run Tests

```bash
pnpm --filter @retrievly/app test:unit -- Tooltip
```

## Notes

### Library Alternatives

If the custom implementation proves insufficient, consider these RN tooltip libraries:

| Library                            | Pros                          | Cons                        |
| ---------------------------------- | ----------------------------- | --------------------------- |
| `react-native-tooltip`             | Simple API                    | Limited positioning options |
| `react-native-walkthrough-tooltip` | Rich features, arrows         | Larger bundle size          |
| `@gorhom/portal`                   | Just portal, compose yourself | More setup required         |

### Platform Considerations

- **Mobile**: Long press trigger (prevents accidental activations)
- **Desktop (Tauri)**: Hover + focus triggers via web events
- **Accessibility**: Focus trigger ensures keyboard navigation support
