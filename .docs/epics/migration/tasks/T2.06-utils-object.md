# T2.06: Object Utilities

## Metadata

| Field        | Value      |
| ------------ | ---------- |
| **ID**       | T2.06      |
| **Layer**    | L2 - Utils |
| **Status**   | pending    |
| **Priority** | medium     |
| **Estimate** | 0.5h       |
| **Parallel** | true       |
| **Assignee** | -          |
| **Created**  | 2026-01-04 |
| **Updated**  | 2026-01-04 |

## Dependencies

None

## Blocks

| Task ID | Name             |
| ------- | ---------------- |
| T7.\*   | State management |
| T8.\*   | Hooks            |
| T10.\*  | Components       |

## Description

Migrate object utility functions from Mattermost: `isEmptyObject`, `deleteKeysFromObject`, `fillRecord`.

## Source Files

- `vendor/desktop/webapp/channels/src/utils/utils.tsx` (lines 1180-1188, 1400-1410, 1487-1492)

## Target File

`apps/v2/src/utils/object.ts`

## Implementation

```typescript
// apps/v2/src/utils/object.ts

/**
 * Object utility functions
 * Migrated from: vendor/desktop/webapp/channels/src/utils/utils.tsx
 */

//#region Type Definitions

type IPlainObject = Record<string, unknown>;

//#endregion

//#region Object Checks

/**
 * Checks if an object is empty (null, undefined, or has no own keys)
 *
 * @param object - The value to check
 * @returns true if the object is null, undefined, or has no enumerable own properties
 *
 * @example
 * isEmptyObject(null)       // true
 * isEmptyObject({})         // true
 * isEmptyObject({ a: 1 })   // false
 */
export function isEmptyObject(object: unknown): boolean {
  if (!object) {
    return true;
  }

  if (typeof object !== "object") {
    return true;
  }

  return Object.keys(object).length === 0;
}

//#endregion

//#region Object Manipulation

/**
 * Deletes specified keys from an object (immutable version - returns new object)
 *
 * @param value - The source object
 * @param keys - Array of keys to remove
 * @returns A new object without the specified keys
 *
 * @example
 * const user = { id: 1, name: 'John', password: 'secret' };
 * deleteKeysFromObject(user, ['password']);
 * // Returns: { id: 1, name: 'John' }
 */
export function deleteKeysFromObject<T extends IPlainObject>(
  value: T,
  keys: Array<keyof T>,
): Partial<T> {
  const result = { ...value };

  for (const key of keys) {
    delete result[key];
  }

  return result;
}

/**
 * Creates a Record with numeric keys filled with the same value
 *
 * @param value - The value to fill each slot with
 * @param length - Number of entries to create (0 to length-1)
 * @returns A Record<number, T> with indices 0 to length-1
 *
 * @example
 * fillRecord(false, 3);
 * // Returns: { 0: false, 1: false, 2: false }
 *
 * fillRecord('loading', 5);
 * // Returns: { 0: 'loading', 1: 'loading', 2: 'loading', 3: 'loading', 4: 'loading' }
 */
export function fillRecord<T>(value: T, length: number): Record<number, T> {
  const record: Record<number, T> = {};

  for (let i = 0; i < length; i++) {
    record[i] = value;
  }

  return record;
}

/**
 * Picks specified keys from an object
 *
 * @param value - The source object
 * @param keys - Array of keys to keep
 * @returns A new object with only the specified keys
 *
 * @example
 * const user = { id: 1, name: 'John', email: 'john@example.com' };
 * pickKeysFromObject(user, ['id', 'name']);
 * // Returns: { id: 1, name: 'John' }
 */
export function pickKeysFromObject<T extends IPlainObject, K extends keyof T>(
  value: T,
  keys: K[],
): Pick<T, K> {
  const result = {} as Pick<T, K>;

  for (const key of keys) {
    if (key in value) {
      result[key] = value[key];
    }
  }

  return result;
}

/**
 * Checks if two objects are shallowly equal
 *
 * @param objA - First object
 * @param objB - Second object
 * @returns true if both objects have the same keys with same values (===)
 *
 * @example
 * shallowEqual({ a: 1 }, { a: 1 })   // true
 * shallowEqual({ a: 1 }, { a: 2 })   // false
 * shallowEqual({ a: 1 }, { b: 1 })   // false
 */
export function shallowEqual(
  objA: IPlainObject | null | undefined,
  objB: IPlainObject | null | undefined,
): boolean {
  if (objA === objB) {
    return true;
  }

  if (!objA || !objB) {
    return false;
  }

  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  for (const key of keysA) {
    if (objA[key] !== objB[key]) {
      return false;
    }
  }

  return true;
}

//#endregion

//#region Enum Helpers

/**
 * Creates an enum-like object where each key's value equals its key name.
 * Useful for creating string enum alternatives.
 *
 * @param obj - Object with keys to mirror
 * @returns Object where each value equals its key
 *
 * @example
 * keyMirror({ LOADING: null, SUCCESS: null, ERROR: null })
 * // Returns: { LOADING: 'LOADING', SUCCESS: 'SUCCESS', ERROR: 'ERROR' }
 *
 * const STATUS = keyMirror({ ACTIVE: null, INACTIVE: null });
 * STATUS.ACTIVE // 'ACTIVE'
 */
export function keyMirror<T extends Record<string, unknown>>(
  obj: T,
): { [K in keyof T]: K } {
  const result = {} as { [K in keyof T]: K };

  for (const key of Object.keys(obj) as Array<keyof T>) {
    result[key] = key;
  }

  return result;
}

//#endregion
```

## Index Export

```typescript
// apps/v2/src/utils/index.ts

export {
  isEmptyObject,
  deleteKeysFromObject,
  fillRecord,
  pickKeysFromObject,
  shallowEqual,
  keyMirror,
} from "./object";
```

## Acceptance Criteria

- [ ] All functions implemented with proper TypeScript types
- [ ] Uses `type` keyword (not `interface`)
- [ ] Types prefixed with `I` where applicable
- [ ] Uses `#region` comments for organization
- [ ] `deleteKeysFromObject` is immutable (returns new object, does not mutate input)
- [ ] `keyMirror` creates object where values equal keys
- [ ] Exported from `utils/index.ts`
- [ ] No `any` types
- [ ] TypeScript strict mode passes
- [ ] JSDoc comments with examples on all functions

## Testing

```typescript
// apps/v2/src/utils/object.spec.ts

import {
  isEmptyObject,
  deleteKeysFromObject,
  fillRecord,
  pickKeysFromObject,
  shallowEqual,
  keyMirror,
} from "./object";

describe("isEmptyObject", () => {
  it("returns true for null", () => {
    expect(isEmptyObject(null)).toBe(true);
  });

  it("returns true for undefined", () => {
    expect(isEmptyObject(undefined)).toBe(true);
  });

  it("returns true for empty object", () => {
    expect(isEmptyObject({})).toBe(true);
  });

  it("returns false for object with keys", () => {
    expect(isEmptyObject({ a: 1 })).toBe(false);
  });

  it("returns true for non-objects", () => {
    expect(isEmptyObject("string")).toBe(true);
    expect(isEmptyObject(123)).toBe(true);
  });
});

describe("deleteKeysFromObject", () => {
  it("removes specified keys", () => {
    const input = { a: 1, b: 2, c: 3 };
    const result = deleteKeysFromObject(input, ["b"]);

    expect(result).toEqual({ a: 1, c: 3 });
  });

  it("does not mutate original object", () => {
    const input = { a: 1, b: 2 };
    deleteKeysFromObject(input, ["b"]);

    expect(input).toEqual({ a: 1, b: 2 });
  });

  it("handles non-existent keys gracefully", () => {
    const input = { a: 1 };
    const result = deleteKeysFromObject(input, ["b" as keyof typeof input]);

    expect(result).toEqual({ a: 1 });
  });
});

describe("fillRecord", () => {
  it("creates record with specified length", () => {
    const result = fillRecord("x", 3);

    expect(result).toEqual({ 0: "x", 1: "x", 2: "x" });
  });

  it("returns empty object for length 0", () => {
    const result = fillRecord("x", 0);

    expect(result).toEqual({});
  });

  it("works with complex values", () => {
    const result = fillRecord({ status: "loading" }, 2);

    expect(result[0]).toEqual({ status: "loading" });
    expect(result[1]).toEqual({ status: "loading" });
  });
});

describe("pickKeysFromObject", () => {
  it("picks only specified keys", () => {
    const input = { a: 1, b: 2, c: 3 };
    const result = pickKeysFromObject(input, ["a", "c"]);

    expect(result).toEqual({ a: 1, c: 3 });
  });

  it("ignores non-existent keys", () => {
    const input = { a: 1 };
    const result = pickKeysFromObject(input, ["a", "b" as keyof typeof input]);

    expect(result).toEqual({ a: 1 });
  });
});

describe("shallowEqual", () => {
  it("returns true for same reference", () => {
    const obj = { a: 1 };
    expect(shallowEqual(obj, obj)).toBe(true);
  });

  it("returns true for equal objects", () => {
    expect(shallowEqual({ a: 1, b: 2 }, { a: 1, b: 2 })).toBe(true);
  });

  it("returns false for different values", () => {
    expect(shallowEqual({ a: 1 }, { a: 2 })).toBe(false);
  });

  it("returns false for different keys", () => {
    expect(shallowEqual({ a: 1 }, { b: 1 })).toBe(false);
  });

  it("handles null/undefined", () => {
    expect(shallowEqual(null, null)).toBe(true);
    expect(shallowEqual(null, {})).toBe(false);
    expect(shallowEqual({}, null)).toBe(false);
  });
});

describe("keyMirror", () => {
  it("creates object with values equal to keys", () => {
    const result = keyMirror({ LOADING: null, SUCCESS: null, ERROR: null });

    expect(result).toEqual({
      LOADING: "LOADING",
      SUCCESS: "SUCCESS",
      ERROR: "ERROR",
    });
  });

  it("handles empty object", () => {
    const result = keyMirror({});
    expect(result).toEqual({});
  });

  it("ignores original values", () => {
    const result = keyMirror({ A: 1, B: "ignored", C: { nested: true } });

    expect(result).toEqual({ A: "A", B: "B", C: "C" });
  });

  it("preserves type safety", () => {
    const STATUS = keyMirror({ ACTIVE: null, INACTIVE: null });

    // TypeScript should infer these as literal types
    const active: "ACTIVE" = STATUS.ACTIVE;
    const inactive: "INACTIVE" = STATUS.INACTIVE;

    expect(active).toBe("ACTIVE");
    expect(inactive).toBe("INACTIVE");
  });
});
```

Run tests:

```bash
pnpm --filter @retrievly/app test:unit -- object.spec
```
